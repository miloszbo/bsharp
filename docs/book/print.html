<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BSharp C# Parser Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the BSharp C# parser and analysis toolkit">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BSharp C# Parser Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mikserek/bsharp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bsharp-c-parser-documentation"><a class="header" href="#bsharp-c-parser-documentation">BSharp C# Parser Documentation</a></h1>
<p>BSharp is a comprehensive C# parser and analysis toolkit written in Rust. It provides a complete solution for parsing C# source code into an Abstract Syntax Tree (AST), performing various code analyses, and generating insights about code quality and structure.</p>
<h2 id="what-is-bsharp"><a class="header" href="#what-is-bsharp">What is BSharp?</a></h2>
<p>BSharp consists of several key components:</p>
<ul>
<li><strong>Parser</strong>: A robust C# parser built using the <code>nom</code> parser combinator library</li>
<li><strong>AST</strong>: A complete representation of C# language constructs</li>
<li><strong>Analysis Framework</strong>: Tools for analyzing code structure, dependencies, and quality</li>
<li><strong>CLI Tools</strong>: Command-line utilities for parsing, visualization, and compilation</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li>
<p><strong>Complete C# Language Support</strong>: Supports modern C# features including:</p>
<ul>
<li>Classes, structs, interfaces, records, enums</li>
<li>Methods, properties, fields, events, indexers</li>
<li>All statement types (if, for, while, switch, try-catch, etc.)</li>
<li>Expression parsing with operator precedence</li>
<li>Generic types and constraints</li>
<li>Attributes and modifiers</li>
<li>Preprocessor directives</li>
</ul>
</li>
<li>
<p><strong>Robust Error Handling</strong>: Custom error types with context information for debugging parse failures</p>
</li>
<li>
<p><strong>AST Navigation</strong>: Powerful navigation traits for traversing and analyzing the AST</p>
</li>
<li>
<p><strong>Code Analysis</strong>: Built-in analyzers for:</p>
<ul>
<li>Control flow analysis</li>
<li>Dependency tracking</li>
<li>Code metrics (complexity, maintainability)</li>
<li>Type analysis</li>
<li>Code quality assessment</li>
</ul>
</li>
<li>
<p><strong>Extensible Architecture</strong>: Modular design allowing easy extension of parsing and analysis capabilities</p>
</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The codebase is organized into several main modules:</p>
<pre><code>src/
├── parser/           # Parser implementations (expressions, statements, declarations)
├── syntax/           # Parser infrastructure (AST nodes, helpers, errors)
├── analysis/         # Code analysis framework
├── workspace/        # Solution and project file loading
├── cli/              # Command-line interface
├── codegen/          # Code generation utilities
└── compiler.rs       # Compilation orchestration
</code></pre>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<p><strong>Parser (<code>src/parser/</code>, <code>src/syntax/</code>)</strong></p>
<ul>
<li>Modular parser using nom combinators</li>
<li>Complete C# language support</li>
<li>Rich error diagnostics with ErrorTree</li>
<li>Keyword parsing organized by category</li>
<li>AST nodes follow PascalCase naming without 'Syntax' suffix</li>
</ul>
<p><strong>Workspace Loading (<code>src/workspace/</code>)</strong></p>
<ul>
<li>Solution file (.sln) parsing</li>
<li>Project file (.csproj) parsing with XML</li>
<li>Transitive ProjectReference resolution</li>
<li>Source file discovery with glob patterns</li>
<li>Deterministic project ordering</li>
</ul>
<p><strong>Analysis Framework (<code>src/analysis/</code>)</strong></p>
<ul>
<li>Pipeline-based architecture with phases</li>
<li>Extensible passes and rules system</li>
<li>Metrics collection (complexity, maintainability)</li>
<li>Control flow analysis</li>
<li>Dependency tracking</li>
<li>Code quality assessment</li>
</ul>
<p><strong>Code Generation (<code>src/codegen/</code>, <code>src/compiler.rs</code>)</strong></p>
<ul>
<li>Cranelift backend integration</li>
<li>IR generation from AST</li>
<li>Native code compilation (experimental)</li>
</ul>
<p><strong>CLI Tools (<code>src/cli/</code>)</strong></p>
<ul>
<li><code>parse</code> - Parse C# to JSON</li>
<li><code>tree</code> - Generate AST visualization</li>
<li><code>compile</code> - Compile to native binary</li>
<li><code>analyze</code> - Comprehensive code analysis</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>The easiest way to get started is using the CLI tools:</p>
<pre><code class="language-bash"># Parse a C# file and output JSON
bsharp parse input.cs --output output.json

# Generate AST visualization
bsharp tree input.cs --output ast.svg

# Compile C# code
bsharp compile input.cs
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>BSharp is designed for:</p>
<ul>
<li><strong>Static Analysis Tools</strong>: Build custom analyzers for code quality, security, or style</li>
<li><strong>Code Transformation</strong>: Parse, modify, and regenerate C# code</li>
<li><strong>Language Tooling</strong>: Create IDE extensions, linters, or formatters</li>
<li><strong>Educational Tools</strong>: Understand and visualize C# code structure</li>
<li><strong>Migration Tools</strong>: Analyze legacy code for modernization efforts</li>
</ul>
<p>This documentation will guide you through all aspects of using and extending BSharp.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser-overview"><a class="header" href="#parser-overview">Parser Overview</a></h1>
<p>The BSharp parser is the core component of an alternative C# compiler implementation, responsible for transforming C# source code into a structured Abstract Syntax Tree (AST). Built using the <code>nom</code> parser combinator library, it provides a robust and extensible foundation for parsing modern C# syntax as part of a complete compiler toolchain.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>As part of the BSharp compiler, the parser follows a modular architecture with clear separation of concerns. The parser serves as the frontend of the compiler pipeline, feeding structured AST data to subsequent compilation phases:</p>
<h3 id="parser-infrastructure-srcsyntax"><a class="header" href="#parser-infrastructure-srcsyntax">Parser Infrastructure (<code>src/syntax/</code>)</a></h3>
<ul>
<li><strong><code>mod.rs</code></strong>: Public API and re-exports</li>
<li><strong><code>ast.rs</code></strong>: Root AST node definitions (<code>CompilationUnit</code>, <code>TopLevelDeclaration</code>)</li>
<li><strong><code>errors.rs</code></strong>: Error formatting utilities (<code>format_error_tree</code>)</li>
<li><strong><code>parser_helpers.rs</code></strong>: Core parsing utilities (<code>context</code>, <code>bws</code>, <code>keyword</code>, etc.)</li>
<li><strong><code>test_helpers.rs</code></strong>: Testing utilities (<code>expect_ok</code>, etc.)</li>
<li><strong><code>nodes/</code></strong>: AST node definitions organized by category</li>
</ul>
<h3 id="parser-implementations-srcparser"><a class="header" href="#parser-implementations-srcparser">Parser Implementations (<code>src/parser/</code>)</a></h3>
<p>The parsers are organized by language construct type:</p>
<ul>
<li><strong><code>expressions/</code></strong>: All expression parsing (literals, operators, method calls, etc.)</li>
<li><strong><code>keywords/</code></strong>: Keyword parsing organized by category</li>
<li><strong><code>types/</code></strong>: Type system parsing (primitives, generics, arrays, etc.)</li>
<li><strong><code>helpers/</code></strong>: Declaration helpers and utilities</li>
<li><strong><code>preprocessor/</code></strong>: Preprocessor directive parsing</li>
</ul>
<h3 id="ast-node-definitions-srcsyntaxnodes"><a class="header" href="#ast-node-definitions-srcsyntaxnodes">AST Node Definitions (<code>src/syntax/nodes/</code>)</a></h3>
<p>Structured node definitions that mirror C# language constructs:</p>
<ul>
<li><strong><code>declarations/</code></strong>: All declaration node types</li>
<li><strong><code>expressions/</code></strong>: All expression node types</li>
<li><strong><code>statements/</code></strong>: All statement node types</li>
<li><strong><code>types/</code></strong>: Type system node definitions</li>
</ul>
<h2 id="parser-design-principles"><a class="header" href="#parser-design-principles">Parser Design Principles</a></h2>
<h3 id="1-compositional-design"><a class="header" href="#1-compositional-design">1. Compositional Design</a></h3>
<p>The parser is built from small, focused parser functions that combine to handle complex language constructs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Method declaration combines multiple sub-parsers
fn parse_method_declaration(input: &amp;str) -&gt; BResult&lt;&amp;str, MethodDeclaration&gt; {
    let (input, attributes) = parse_attributes(input)?;
    let (input, modifiers) = parse_modifiers(input)?;
    let (input, return_type) = parse_type(input)?;
    let (input, name) = parse_identifier(input)?;
    let (input, parameters) = parse_parameter_list(input)?;
    let (input, body) = opt(parse_block_statement)(input)?;
    // ... construct and return MethodDeclaration
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-error-recovery-and-context"><a class="header" href="#2-error-recovery-and-context">2. Error Recovery and Context</a></h3>
<p>Custom error types provide detailed context about parse failures:</p>
<ul>
<li>Location information (line, column)</li>
<li>Expected vs. actual input</li>
<li>Contextual error messages</li>
<li>Error recovery strategies</li>
</ul>
<h3 id="3-extensibility"><a class="header" href="#3-extensibility">3. Extensibility</a></h3>
<p>The modular design allows easy addition of new language features:</p>
<ul>
<li>Add new expression types by extending the <code>Expression</code> enum</li>
<li>Implement new statement parsers following established patterns</li>
<li>Extend AST navigation traits for new analysis capabilities</li>
</ul>
<h2 id="parsing-flow"><a class="header" href="#parsing-flow">Parsing Flow</a></h2>
<h3 id="1-entry-point"><a class="header" href="#1-entry-point">1. Entry Point</a></h3>
<p>All parsing begins with the <code>Parser::parse()</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse(&amp;self, input: &amp;str) -&gt; Result&lt;ast::CompilationUnit, String&gt; {
    // Delegates to the main C# parser
    parse_csharp_source(input)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-compilation-unit-parsing"><a class="header" href="#2-compilation-unit-parsing">2. Compilation Unit Parsing</a></h3>
<p>The parser starts by parsing a <code>CompilationUnit</code>, which represents a complete C# source file:</p>
<ul>
<li>Global attributes (assembly/module level)</li>
<li>Using directives</li>
<li>Top-level declarations (namespaces, classes, etc.)</li>
<li>File-scoped namespaces (C# 10+)</li>
<li>Top-level statements (C# 9+)</li>
</ul>
<h3 id="3-recursive-descent"><a class="header" href="#3-recursive-descent">3. Recursive Descent</a></h3>
<p>The parser uses recursive descent to handle nested structures:</p>
<ul>
<li>Namespaces contain type declarations</li>
<li>Types contain member declarations</li>
<li>Methods contain statements</li>
<li>Statements contain expressions</li>
</ul>
<h2 id="key-parser-features"><a class="header" href="#key-parser-features">Key Parser Features</a></h2>
<h3 id="expression-parsing-with-precedence"><a class="header" href="#expression-parsing-with-precedence">Expression Parsing with Precedence</a></h3>
<p>The expression parser handles operator precedence correctly:</p>
<ul>
<li>Primary expressions (literals, identifiers, parentheses)</li>
<li>Unary operators (!, -, +, ++, --, etc.)</li>
<li>Binary operators with correct precedence and associativity</li>
<li>Conditional expressions (ternary operator)</li>
<li>Assignment expressions</li>
</ul>
<h3 id="statement-parsing"><a class="header" href="#statement-parsing">Statement Parsing</a></h3>
<p>Comprehensive support for all C# statement types:</p>
<ul>
<li>Control flow: <code>if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code></li>
<li>Jump statements: <code>break</code>, <code>continue</code>, <code>return</code>, <code>throw</code>, <code>goto</code></li>
<li>Exception handling: <code>try-catch-finally</code></li>
<li>Resource management: <code>using</code>, <code>lock</code></li>
<li>Local declarations and assignments</li>
</ul>
<h3 id="declaration-parsing"><a class="header" href="#declaration-parsing">Declaration Parsing</a></h3>
<p>Full support for C# type and member declarations:</p>
<ul>
<li>Types: classes, structs, interfaces, records, enums, delegates</li>
<li>Members: methods, properties, fields, events, indexers, operators</li>
<li>Modifiers: access modifiers, static, abstract, virtual, override, etc.</li>
<li>Generics: type parameters, constraints, variance</li>
</ul>
<h3 id="modern-c-features"><a class="header" href="#modern-c-features">Modern C# Features</a></h3>
<p>Support for recent C# language additions:</p>
<ul>
<li>Records (C# 9)</li>
<li>File-scoped namespaces (C# 10)</li>
<li>Top-level statements (C# 9)</li>
<li>Pattern matching enhancements</li>
<li>Nullable reference types</li>
</ul>
<h2 id="error-handling-strategy"><a class="header" href="#error-handling-strategy">Error Handling Strategy</a></h2>
<p>The parser uses a multi-layered error handling approach:</p>
<ol>
<li><strong>Parse Errors</strong>: Detailed information about what went wrong during parsing</li>
<li><strong>Context Propagation</strong>: Errors include context about where in the parsing process they occurred</li>
<li><strong>Recovery Mechanisms</strong>: Ability to continue parsing after certain types of errors</li>
<li><strong>User-Friendly Messages</strong>: Clear, actionable error messages for developers</li>
</ol>
<p>This design makes the parser both robust for production compiler use and helpful for development and debugging. While the complete compiler backend is still under development, the parser provides a solid foundation for the full C# compilation pipeline that BSharp aims to deliver.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-parser-components"><a class="header" href="#core-parser-components">Core Parser Components</a></h1>
<p>This document details the fundamental components that make up the BSharp parser infrastructure.</p>
<h2 id="public-parser-api"><a class="header" href="#public-parser-api">Public Parser API</a></h2>
<h3 id="parser-struct"><a class="header" href="#parser-struct">Parser Struct</a></h3>
<p>The main entry point for all parsing operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct Parser;

impl Parser {
    pub fn new() -&gt; Self
    pub fn parse(&amp;self, input: &amp;str) -&gt; Result&lt;ast::CompilationUnit, String&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Parser</code> provides a clean, simple interface that abstracts away the complexity of the underlying parsing implementation.</p>
<h2 id="error-system"><a class="header" href="#error-system">Error System</a></h2>
<h3 id="errortree-nom-supreme"><a class="header" href="#errortree-nom-supreme">ErrorTree (nom-supreme)</a></h3>
<p>BSharp uses nom-supreme's ErrorTree for rich error diagnostics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BResult&lt;I, O&gt; = IResult&lt;I, O, ErrorTree&lt;I&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Location:</strong> Type alias defined in parser infrastructure</p>
<p>Key features:</p>
<ul>
<li><strong>Context Stack</strong>: Maintains parsing contexts via <code>.context()</code> calls</li>
<li><strong>Position Tracking</strong>: Built-in span tracking for error locations</li>
<li><strong>Rich Diagnostics</strong>: Tree structure shows complete parse failure path</li>
<li><strong>Integration</strong>: Seamless with nom combinators</li>
</ul>
<h3 id="error-helpers"><a class="header" href="#error-helpers">Error Helpers</a></h3>
<p>Utility functions for enhanced error handling:</p>
<p><strong>Location:</strong> <code>src/syntax/parser_helpers.rs</code></p>
<ul>
<li><code>context()</code>: Adds contextual information to parser errors</li>
<li><code>bws()</code>: Whitespace-aware wrapper with error context</li>
<li><code>bdelimited()</code>: Delimited parsing with cut on closing delimiter</li>
<li><code>cut()</code>: Commits to parse branch, preventing misleading backtracking</li>
<li>Error recovery mechanisms for common parsing scenarios</li>
</ul>
<h3 id="pretty-error-formatting"><a class="header" href="#pretty-error-formatting">Pretty Error Formatting</a></h3>
<p><strong>Location:</strong> <code>src/syntax/errors.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn format_error_tree(input: &amp;str, error: &amp;ErrorTree&lt;&amp;str&gt;) -&gt; String;
<span class="boring">}</span></code></pre></pre>
<p>Produces rustc-like error messages with:</p>
<ul>
<li>Line and column numbers</li>
<li>Source code context</li>
<li>Caret pointing to error location</li>
<li>Context stack showing parse path</li>
</ul>
<h2 id="ast-foundation"><a class="header" href="#ast-foundation">AST Foundation</a></h2>
<h3 id="compilationunit"><a class="header" href="#compilationunit">CompilationUnit</a></h3>
<p>The root node of every parsed C# file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CompilationUnit {
    pub global_attributes: Vec&lt;GlobalAttribute&gt;,
    pub using_directives: Vec&lt;UsingDirective&gt;,
    pub declarations: Vec&lt;TopLevelDeclaration&gt;,
    pub file_scoped_namespace: Option&lt;FileScopedNamespaceDeclaration&gt;,
    pub top_level_statements: Vec&lt;Statement&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Represents the complete structure of a C# source file, supporting both traditional and modern C# features.</p>
<h3 id="topleveldeclaration"><a class="header" href="#topleveldeclaration">TopLevelDeclaration</a></h3>
<p>Enum representing all possible top-level declarations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TopLevelDeclaration {
    Namespace(NamespaceDeclaration),
    FileScopedNamespace(FileScopedNamespaceDeclaration),
    Class(ClassDeclaration),
    Struct(StructDeclaration),
    Record(RecordDeclaration),
    Interface(InterfaceDeclaration),
    Enum(EnumDeclaration),
    Delegate(DelegateDeclaration),
    GlobalAttribute(GlobalAttribute),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="keyword-parsing"><a class="header" href="#keyword-parsing">Keyword Parsing</a></h2>
<h3 id="keyword-module-organization"><a class="header" href="#keyword-module-organization">Keyword Module Organization</a></h3>
<p><strong>Location:</strong> <code>src/parser/keywords/</code></p>
<p>Keywords are organized by category in dedicated modules for maintainability and consistency:</p>
<pre><code>src/parser/keywords/
├── mod.rs                      # Keyword infrastructure
├── access_keywords.rs          # public, private, protected, internal
├── accessor_keywords.rs        # get, set, init, add, remove
├── type_keywords.rs            # class, struct, interface, enum, record
├── modifier_keywords.rs        # static, abstract, virtual, sealed
├── flow_control_keywords.rs    # if, else, switch, case, default
├── iteration_keywords.rs       # for, foreach, while, do
├── expression_keywords.rs      # new, this, base, typeof, sizeof
├── linq_query_keywords.rs      # from, where, select, orderby
└── ...
</code></pre>
<h3 id="keyword-parsing-strategy"><a class="header" href="#keyword-parsing-strategy">Keyword Parsing Strategy</a></h3>
<p><strong>Word Boundary Enforcement:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn keyword(kw: &amp;'static str) -&gt; impl Fn(&amp;str) -&gt; BResult&lt;&amp;str, &amp;str&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The <code>keyword()</code> helper enforces <code>[A-Za-z0-9_]</code> word boundaries to prevent partial matches:</p>
<ul>
<li>Correctly rejects "int" when parsing "int32"</li>
<li>Ensures "class" doesn't match "classname"</li>
<li>Consistent across all keyword parsers</li>
</ul>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Maintainability</strong>: Easy to find and update keyword parsers</li>
<li><strong>Consistency</strong>: Uniform keyword parsing strategy</li>
<li><strong>Bug Prevention</strong>: Avoids partial match issues</li>
<li><strong>Centralization</strong>: Single source of truth for keywords</li>
</ul>
<h2 id="parser-helpers"><a class="header" href="#parser-helpers">Parser Helpers</a></h2>
<h3 id="context-management"><a class="header" href="#context-management">Context Management</a></h3>
<p>Functions for maintaining parsing context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn context&lt;I, O, F&gt;(
    ctx: &amp;'static str,
    parser: F
) -&gt; impl FnMut(I) -&gt; BResult&lt;I, O&gt;
<span class="boring">}</span></code></pre></pre>
<p>Wraps parsers with contextual information that appears in error messages, making debugging much easier.</p>
<h3 id="parser-composition"><a class="header" href="#parser-composition">Parser Composition</a></h3>
<p>Utilities for combining smaller parsers into larger ones:</p>
<ul>
<li>Sequencing parsers with error propagation</li>
<li>Optional parsing with fallbacks</li>
<li>Alternative parsing with preference ordering</li>
<li>Repetition parsing with separators</li>
</ul>
<h3 id="whitespace-and-comment-handling"><a class="header" href="#whitespace-and-comment-handling">Whitespace and Comment Handling</a></h3>
<p>Consistent handling of whitespace and comments throughout the parser:</p>
<ul>
<li>Automatic whitespace skipping between tokens</li>
<li>Comment preservation for documentation tools</li>
<li>Preprocessor directive handling</li>
</ul>
<h2 id="node-structure-standards"><a class="header" href="#node-structure-standards">Node Structure Standards</a></h2>
<h3 id="common-traits"><a class="header" href="#common-traits">Common Traits</a></h3>
<p>All AST nodes implement standard traits:</p>
<ul>
<li><code>Debug</code>: For debugging and logging</li>
<li><code>PartialEq</code>: For testing and comparison</li>
<li><code>Clone</code>: For AST manipulation</li>
<li><code>Serialize/Deserialize</code>: For JSON export/import</li>
</ul>
<h3 id="node-organization"><a class="header" href="#node-organization">Node Organization</a></h3>
<p>AST nodes are organized hierarchically:</p>
<pre><code>nodes/
├── declarations/     # Type and member declarations
├── expressions/      # All expression types
├── statements/       # All statement types
├── types/           # Type system representations
└── ...              # Other language constructs
</code></pre>
<h3 id="identifier-handling"><a class="header" href="#identifier-handling">Identifier Handling</a></h3>
<p>Consistent identifier representation throughout the AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Identifier {
    pub name: String,
    // Additional metadata like source location
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-system-integration"><a class="header" href="#type-system-integration">Type System Integration</a></h2>
<h3 id="type-representation"><a class="header" href="#type-representation">Type Representation</a></h3>
<p>The parser builds a complete representation of C# types:</p>
<ul>
<li>Primitive types (int, string, bool, etc.)</li>
<li>Reference types (classes, interfaces)</li>
<li>Value types (structs, enums)</li>
<li>Generic types with constraints</li>
<li>Array and pointer types</li>
<li>Nullable types</li>
</ul>
<h3 id="generic-support"><a class="header" href="#generic-support">Generic Support</a></h3>
<p>Full support for C# generics:</p>
<ul>
<li>Type parameters with constraints</li>
<li>Variance annotations (in, out)</li>
<li>Generic method declarations</li>
<li>Complex constraint combinations</li>
</ul>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<h3 id="zero-copy-parsing"><a class="header" href="#zero-copy-parsing">Zero-Copy Parsing</a></h3>
<p>Where possible, the parser avoids unnecessary string allocations:</p>
<ul>
<li>String slices reference original input</li>
<li>Minimal cloning during parsing</li>
<li>Efficient error reporting without excessive allocation</li>
</ul>
<h3 id="ast-ownership"><a class="header" href="#ast-ownership">AST Ownership</a></h3>
<p>Clear ownership semantics for AST nodes:</p>
<ul>
<li>Parent nodes own their children</li>
<li>Shared references through navigation traits</li>
<li>No circular references in the AST structure</li>
</ul>
<p>This foundation provides a robust base for parsing complex C# code while maintaining performance and usability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-structure"><a class="header" href="#ast-structure">AST Structure</a></h1>
<p>The BSharp AST (Abstract Syntax Tree) provides a complete, structured representation of C# source code. This document explains the organization and relationships between different AST node types.</p>
<h2 id="ast-hierarchy"><a class="header" href="#ast-hierarchy">AST Hierarchy</a></h2>
<h3 id="root-node-compilationunit"><a class="header" href="#root-node-compilationunit">Root Node: CompilationUnit</a></h3>
<p>Every parsed C# file results in a <code>CompilationUnit</code>, which serves as the root of the AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CompilationUnit {
    pub global_attributes: Vec&lt;GlobalAttribute&gt;,        // [assembly: ...] attributes
    pub using_directives: Vec&lt;UsingDirective&gt;,          // using statements
    pub declarations: Vec&lt;TopLevelDeclaration&gt;,         // namespaces, types
    pub file_scoped_namespace: Option&lt;FileScopedNamespaceDeclaration&gt;, // C# 10+
    pub top_level_statements: Vec&lt;Statement&gt;,           // C# 9+ top-level code
}
<span class="boring">}</span></code></pre></pre>
<p>This structure supports both traditional C# files and modern features like file-scoped namespaces and top-level statements.</p>
<h2 id="declaration-hierarchy"><a class="header" href="#declaration-hierarchy">Declaration Hierarchy</a></h2>
<h3 id="top-level-declarations"><a class="header" href="#top-level-declarations">Top-Level Declarations</a></h3>
<p>Top-level declarations represent constructs that can appear at the file or namespace level:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TopLevelDeclaration {
    Namespace(NamespaceDeclaration),
    FileScopedNamespace(FileScopedNamespaceDeclaration),
    Class(ClassDeclaration),
    Struct(StructDeclaration),
    Record(RecordDeclaration),
    Interface(InterfaceDeclaration),
    Enum(EnumDeclaration),
    Delegate(DelegateDeclaration),
    GlobalAttribute(GlobalAttribute),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-declarations"><a class="header" href="#type-declarations">Type Declarations</a></h3>
<p>Each type declaration contains comprehensive information about the type:</p>
<h4 id="classdeclaration"><a class="header" href="#classdeclaration">ClassDeclaration</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ClassDeclaration {
    pub attributes: Vec&lt;Attribute&gt;,
    pub modifiers: Vec&lt;Modifier&gt;,
    pub identifier: Identifier,
    pub type_parameters: Option&lt;Vec&lt;TypeParameter&gt;&gt;,
    pub base_types: Vec&lt;Type&gt;,                    // base class and interfaces
    pub body_declarations: Vec&lt;ClassBodyDeclaration&gt;,
    pub type_parameter_constraints: Vec&lt;TypeParameterConstraint&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="methoddeclaration"><a class="header" href="#methoddeclaration">MethodDeclaration</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MethodDeclaration {
    pub attributes: Vec&lt;Attribute&gt;,
    pub modifiers: Vec&lt;Modifier&gt;,
    pub return_type: Option&lt;Type&gt;,               // None for constructors
    pub identifier: Identifier,
    pub type_parameters: Option&lt;Vec&lt;TypeParameter&gt;&gt;,
    pub parameters: Vec&lt;Parameter&gt;,
    pub body: Option&lt;Statement&gt;,                 // None for abstract/interface methods
    pub type_parameter_constraints: Vec&lt;TypeParameterConstraint&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="member-declarations"><a class="header" href="#member-declarations">Member Declarations</a></h3>
<p>Class body declarations represent all possible class members:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ClassBodyDeclaration {
    Method(MethodDeclaration),
    Constructor(ConstructorDeclaration),
    Destructor(DestructorDeclaration),
    Property(PropertyDeclaration),
    Field(FieldDeclaration),
    Event(EventDeclaration),
    Indexer(IndexerDeclaration),
    Operator(OperatorDeclaration),
    NestedClass(ClassDeclaration),
    NestedStruct(StructDeclaration),
    NestedInterface(InterfaceDeclaration),
    NestedEnum(EnumDeclaration),
    NestedDelegate(DelegateDeclaration),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="expression-hierarchy"><a class="header" href="#expression-hierarchy">Expression Hierarchy</a></h2>
<h3 id="expression-types"><a class="header" href="#expression-types">Expression Types</a></h3>
<p>The expression system covers all C# expression types with proper precedence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expression {
    // Primary expressions
    Literal(Literal),
    Identifier(Identifier),
    Parenthesized(Box&lt;Expression&gt;),
    
    // Member access
    MemberAccess { object: Box&lt;Expression&gt;, member: Identifier },
    ElementAccess { object: Box&lt;Expression&gt;, arguments: Vec&lt;Expression&gt; },
    
    // Method calls
    Invocation { expression: Box&lt;Expression&gt;, arguments: Vec&lt;Expression&gt; },
    
    // Operators
    Unary { operator: UnaryOperator, operand: Box&lt;Expression&gt; },
    Binary { left: Box&lt;Expression&gt;, operator: BinaryOperator, right: Box&lt;Expression&gt; },
    
    // Assignment
    Assignment { left: Box&lt;Expression&gt;, operator: AssignmentOperator, right: Box&lt;Expression&gt; },
    
    // Object creation
    ObjectCreation { type_: Type, arguments: Vec&lt;Expression&gt; },
    ArrayCreation { type_: Type, dimensions: Vec&lt;Expression&gt; },
    
    // Modern features
    Lambda(LambdaExpression),
    Query(QueryExpression),
    Await(Box&lt;AwaitExpression&gt;),
    Switch(SwitchExpression),
    
    // Type operations
    Cast { expression: Box&lt;Expression&gt;, target_type: Type },
    TypeCheck { expression: Box&lt;Expression&gt;, target_type: Type },
    
    // And many more...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="literal-types"><a class="header" href="#literal-types">Literal Types</a></h3>
<p>Comprehensive support for C# literals:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Literal {
    Boolean(bool),
    Integer(String),          // Preserves original format
    FloatingPoint(String),    // Preserves original format
    Character(char),
    String(String),
    InterpolatedString(InterpolatedStringLiteral),
    Null,
    Default,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="statement-hierarchy"><a class="header" href="#statement-hierarchy">Statement Hierarchy</a></h2>
<h3 id="statement-types"><a class="header" href="#statement-types">Statement Types</a></h3>
<p>Complete coverage of C# statement types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Statement {
    // Control flow
    If(IfStatement),
    Switch(SwitchStatement),
    For(ForStatement),
    ForEach(ForEachStatement),
    While(WhileStatement),
    DoWhile(DoWhileStatement),
    
    // Jump statements
    Break(BreakStatement),
    Continue(ContinueStatement),
    Return(ReturnStatement),
    Throw(ThrowStatement),
    Goto(GotoStatement),
    
    // Exception handling
    Try(TryStatement),
    
    // Resource management
    Using(UsingStatement),
    Lock(LockStatement),
    
    // Declarations and expressions
    LocalVariableDeclaration(LocalVariableDeclaration),
    ExpressionStatement(Expression),
    Block(Vec&lt;Statement&gt;),
    Empty,
    
    // Modern features
    LocalFunction(LocalFunctionStatement),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="control-flow-statements"><a class="header" href="#control-flow-statements">Control Flow Statements</a></h3>
<p>Complex control flow statements contain nested structures:</p>
<h4 id="ifstatement"><a class="header" href="#ifstatement">IfStatement</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IfStatement {
    pub condition: Expression,
    pub consequence: Box&lt;Statement&gt;,
    pub alternative: Option&lt;Box&lt;Statement&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="trystatement"><a class="header" href="#trystatement">TryStatement</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TryStatement {
    pub body: Box&lt;Statement&gt;,
    pub catch_clauses: Vec&lt;CatchClause&gt;,
    pub finally_clause: Option&lt;FinallyClause&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-system"><a class="header" href="#type-system">Type System</a></h2>
<h3 id="type-representation-1"><a class="header" href="#type-representation-1">Type Representation</a></h3>
<p>The type system models all C# type constructs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Type {
    // Primitive types
    Primitive(PrimitiveType),
    
    // Named types
    Named { name: Identifier, type_arguments: Vec&lt;Type&gt; },
    
    // Array types
    Array { element_type: Box&lt;Type&gt;, rank: usize },
    
    // Pointer types
    Pointer(Box&lt;Type&gt;),
    
    // Nullable types
    Nullable(Box&lt;Type&gt;),
    
    // Generic type parameters
    TypeParameter(Identifier),
    
    // Tuple types
    Tuple(Vec&lt;Type&gt;),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generic-support-1"><a class="header" href="#generic-support-1">Generic Support</a></h3>
<p>Full support for C# generics:</p>
<h4 id="typeparameter"><a class="header" href="#typeparameter">TypeParameter</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TypeParameter {
    pub attributes: Vec&lt;Attribute&gt;,
    pub variance: Option&lt;Variance&gt;,      // in, out
    pub identifier: Identifier,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="typeparameterconstraint"><a class="header" href="#typeparameterconstraint">TypeParameterConstraint</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TypeParameterConstraint {
    TypeConstraint { parameter: Identifier, constraint_type: Type },
    ConstructorConstraint(Identifier),    // new()
    ClassConstraint(Identifier),          // class
    StructConstraint(Identifier),         // struct
    UnmanagedConstraint(Identifier),      // unmanaged
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ast-metadata"><a class="header" href="#ast-metadata">AST Metadata</a></h2>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Comprehensive attribute support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Attribute {
    pub name: Identifier,
    pub arguments: Vec&lt;AttributeArgument&gt;,
}

pub enum AttributeArgument {
    Positional(Expression),
    Named { name: Identifier, value: Expression },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h3>
<p>All C# modifiers are represented:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Modifier {
    // Access modifiers
    Public, Private, Protected, Internal, ProtectedInternal, PrivateProtected,
    
    // Other modifiers
    Static, Abstract, Virtual, Override, Sealed, New,
    Async, Unsafe, Volatile, Readonly, Const,
    Partial, Extern,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navigation-and-relationships"><a class="header" href="#navigation-and-relationships">Navigation and Relationships</a></h2>
<p>The AST maintains clear parent-child relationships while providing navigation capabilities through traits:</p>
<ul>
<li><strong>Ownership</strong>: Parent nodes own their children</li>
<li><strong>Navigation</strong>: Traits provide methods to traverse and search the AST</li>
<li><strong>Context</strong>: Nodes can access their containing context when needed</li>
</ul>
<p>This structure provides a complete, navigable representation of C# code that supports both analysis and transformation scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>BSharp implements a comprehensive error handling system that provides detailed context information for debugging parse failures.</p>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<p>The parser uses <code>ErrorTree</code> from nom-supreme for structured error information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BResult&lt;I, O&gt; = nom::IResult&lt;I, O, ErrorTree&lt;I&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="errortree-structure"><a class="header" href="#errortree-structure">ErrorTree Structure</a></h3>
<p>The <code>ErrorTree</code> type provides:</p>
<ul>
<li><strong>Context Stack</strong>: Hierarchical parsing context via <code>.context()</code> calls</li>
<li><strong>Location</strong>: Span tracking for error positions</li>
<li><strong>Error Tree</strong>: Complete parse failure path</li>
<li><strong>Rich Diagnostics</strong>: Detailed error information for debugging</li>
</ul>
<h2 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h2>
<p>The parser implements several error recovery strategies:</p>
<h3 id="1-malformed-syntax-recovery"><a class="header" href="#1-malformed-syntax-recovery">1. Malformed Syntax Recovery</a></h3>
<p>When encountering malformed syntax, the parser attempts to skip to recovery points:</p>
<ul>
<li>Semicolons (<code>;</code>)</li>
<li>Closing braces (<code>}</code>)</li>
<li>End of input</li>
</ul>
<h3 id="1a-declaration-error-recovery-type-member-top-level"><a class="header" href="#1a-declaration-error-recovery-type-member-top-level">1.a Declaration Error Recovery (Type Member Top-Level)</a></h3>
<p>For type declarations (classes, structs, records, interfaces), malformed members are recovered using a lightweight, scope-aware helper:</p>
<ul>
<li>Helper: <code>skip_to_member_boundary_top_level()</code></li>
<li>Location: <code>src/parser/expressions/declarations/type_declaration_helpers.rs</code></li>
</ul>
<p>Contract:</p>
<ul>
<li>Only use from within a type body when a member parser fails.</li>
<li>Stops at the next safe boundary at top level of the current type:
<ul>
<li>Consumes a top-level <code>;</code> and returns the slice after it.</li>
<li>Or stops at a top-level <code>}</code> without consuming it (so the caller can close the current body cleanly).</li>
<li>Returns an empty slice at EOF.</li>
</ul>
</li>
<li>Depth-tracks <code>()</code>, <code>[]</code>, <code>{}</code>, and a heuristic <code>&lt;&gt;</code> to avoid stopping inside expressions, attribute arguments, or generic argument lists.</li>
<li>Ignores control characters inside strings, chars, and comments.</li>
</ul>
<p>Limitations:</p>
<ul>
<li>Angle-bracket tracking is heuristic and does not fully disambiguate generics from shift operators.</li>
<li>Verbatim/interpolated strings are not fully lexed here; this helper is intended for robust, not perfect, recovery.</li>
</ul>
<p>Usage example (simplified):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match member_parser(cur) {
    Ok((rest, member)) =&gt; { members.push(member); cur = rest; }
    Err(_) =&gt; {
        let next = skip_to_member_boundary_top_level(cur);
        if next.is_empty() || next == cur { break; }
        cur = next;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="1b-namespace-body-using-directives-before-members"><a class="header" href="#1b-namespace-body-using-directives-before-members">1.b Namespace Body: Using-Directives Before Members</a></h3>
<p>Inside a block-scoped namespace body, <code>using</code> directives are accepted before type and nested-namespace members.</p>
<ul>
<li>Implementation: <code>parse_namespace_declaration()</code> scans for <code>using</code> immediately after the opening <code>{</code> and collects all consecutive directives before parsing members.</li>
<li>This ensures inputs like the following are parsed deterministically without interleaving usings with members:</li>
</ul>
<pre><code class="language-csharp">namespace Outer {
    using System;
    namespace Inner {
        using System.Collections;
        class MyClass {}
    }
}
</code></pre>
<p>Contract and limitations:</p>
<ul>
<li>Only leading <code>using</code> directives at the current namespace body level are collected.</li>
<li>Interleaving <code>using</code> directives among members is not supported yet (matches common style and avoids ambiguous recovery).</li>
</ul>
<h3 id="1c-file-scoped-namespace"><a class="header" href="#1c-file-scoped-namespace">1.c File-Scoped Namespace</a></h3>
<p>When parsing a file-scoped namespace, the parser also skips preprocessor directives following the <code>namespace</code> line before parsing members, mirroring the block-scoped behavior.</p>
<h2 id="preprocessor-directives-and-trivia"><a class="header" href="#preprocessor-directives-and-trivia">Preprocessor Directives and Trivia</a></h2>
<p>Preprocessor directives (e.g., <code>#pragma</code>, <code>#line</code>) are treated as structured trivia, not AST declarations:</p>
<ul>
<li>Parser entrypoints (e.g., <code>parse_csharp_source()</code>) skip directive lines anywhere they can appear at the compilation-unit level.</li>
<li><code>parse_preprocessor_directive()</code> consumes the entire directive line including an optional trailing newline.</li>
<li>Current status: directives inside type and namespace bodies are planned to be skipped similarly; tests are tracked and temporarily ignored until this is integrated.</li>
</ul>
<p>Example:</p>
<pre><code class="language-csharp">#pragma warning disable CS0168
namespace N {
    // class and members...
}
</code></pre>
<p>The directive is skipped and not present as a namespace member.</p>
<h3 id="2-context-aware-errors"><a class="header" href="#2-context-aware-errors">2. Context-Aware Errors</a></h3>
<p>Errors include contextual information about the parsing context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context("method declaration", parse_method_body)(input)
<span class="boring">}</span></code></pre></pre>
<p>This provides clear error messages like "expected method body in method declaration context".</p>
<p><strong>Helper Location:</strong> <code>src/syntax/parser_helpers.rs</code></p>
<h3 id="3-graceful-degradation"><a class="header" href="#3-graceful-degradation">3. Graceful Degradation</a></h3>
<p>The parser continues parsing even after encountering errors, collecting multiple errors to provide comprehensive feedback.</p>
<h2 id="error-reporting"><a class="header" href="#error-reporting">Error Reporting</a></h2>
<p>Errors are reported with:</p>
<ul>
<li><strong>Line and column numbers</strong></li>
<li><strong>Surrounding context</strong></li>
<li><strong>Suggestions for fixes</strong></li>
<li><strong>Parser state information</strong></li>
</ul>
<h2 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h2>
<h3 id="syntax-errors"><a class="header" href="#syntax-errors">Syntax Errors</a></h3>
<ul>
<li>Missing semicolons</li>
<li>Unmatched braces</li>
<li>Invalid identifiers</li>
</ul>
<h3 id="type-errors"><a class="header" href="#type-errors">Type Errors</a></h3>
<ul>
<li>Unknown type references</li>
<li>Generic constraint violations</li>
<li>Invalid type parameter usage</li>
</ul>
<h3 id="declaration-errors"><a class="header" href="#declaration-errors">Declaration Errors</a></h3>
<ul>
<li>Conflicting modifiers</li>
<li>Missing required elements</li>
<li>Invalid access levels</li>
</ul>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h2>
<ol>
<li><strong>Use verbose error output</strong> to get detailed parser state</li>
<li><strong>Check recovery points</strong> when errors cascade</li>
<li><strong>Validate input syntax</strong> with simpler test cases first</li>
<li><strong>Use parser context</strong> to understand where parsing failed</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expression-parsing"><a class="header" href="#expression-parsing">Expression Parsing</a></h1>
<p>BSharp implements a complete expression parser that handles all C# expression types with proper operator precedence and associativity.</p>
<h2 id="expression-hierarchy-1"><a class="header" href="#expression-hierarchy-1">Expression Hierarchy</a></h2>
<p>The expression parser follows C#'s operator precedence rules:</p>
<ol>
<li><strong>Primary Expressions</strong> (<code>x</code>, <code>x.y</code>, <code>x[y]</code>, <code>x()</code>, etc.)</li>
<li><strong>Unary Expressions</strong> (<code>+x</code>, <code>-x</code>, <code>!x</code>, <code>~x</code>, <code>++x</code>, <code>--x</code>)</li>
<li><strong>Multiplicative</strong> (<code>*</code>, <code>/</code>, <code>%</code>)</li>
<li><strong>Additive</strong> (<code>+</code>, <code>-</code>)</li>
<li><strong>Shift</strong> (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>)</li>
<li><strong>Relational</strong> (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>is</code>, <code>as</code>)</li>
<li><strong>Equality</strong> (<code>==</code>, <code>!=</code>)</li>
<li><strong>Logical AND</strong> (<code>&amp;</code>)</li>
<li><strong>Logical XOR</strong> (<code>^</code>)</li>
<li><strong>Logical OR</strong> (<code>|</code>)</li>
<li><strong>Conditional AND</strong> (<code>&amp;&amp;</code>)</li>
<li><strong>Conditional OR</strong> (<code>||</code>)</li>
<li><strong>Null Coalescing</strong> (<code>??</code>)</li>
<li><strong>Conditional</strong> (<code>?:</code>)</li>
<li><strong>Assignment</strong> (<code>=</code>, <code>+=</code>, <code>-=</code>, etc.)</li>
</ol>
<h2 id="expression-types-1"><a class="header" href="#expression-types-1">Expression Types</a></h2>
<h3 id="primary-expressions"><a class="header" href="#primary-expressions">Primary Expressions</a></h3>
<h4 id="literals"><a class="header" href="#literals">Literals</a></h4>
<ul>
<li><strong>Numeric</strong>: <code>42</code>, <code>3.14</code>, <code>0x1A</code></li>
<li><strong>String</strong>: <code>"hello"</code>, <code>@"verbatim"</code>, <code>$"interpolated {value}"</code></li>
<li><strong>Character</strong>: <code>'a'</code>, <code>'\n'</code></li>
<li><strong>Boolean</strong>: <code>true</code>, <code>false</code></li>
<li><strong>Null</strong>: <code>null</code></li>
</ul>
<h4 id="identifiers-and-member-access"><a class="header" href="#identifiers-and-member-access">Identifiers and Member Access</a></h4>
<pre><code class="language-csharp">variable          // Simple identifier
obj.property      // Member access
obj.method()      // Method invocation
obj[index]        // Indexer access
</code></pre>
<h4 id="object-creation"><a class="header" href="#object-creation">Object Creation</a></h4>
<pre><code class="language-csharp">new MyClass()                    // Constructor
new MyClass { Prop = value }     // Object initializer
new[] { 1, 2, 3 }               // Array initializer
new { Name = "John", Age = 30 }  // Anonymous object
</code></pre>
<h3 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h3>
<p>The parser supports various lambda syntax forms:</p>
<pre><code class="language-csharp">x =&gt; x * 2                      // Single parameter
(x, y) =&gt; x + y                 // Multiple parameters
() =&gt; DoSomething()             // No parameters
(int x, string y) =&gt; Process(x, y)  // Typed parameters
x =&gt; { return x * 2; }          // Block body
async x =&gt; await ProcessAsync(x) // Async lambda
</code></pre>
<h3 id="query-expressions-linq"><a class="header" href="#query-expressions-linq">Query Expressions (LINQ)</a></h3>
<p>Complete LINQ query syntax support:</p>
<pre><code class="language-csharp">from item in collection
where item.IsValid
orderby item.Name
select item.Value
</code></pre>
<p>Supported clauses:</p>
<ul>
<li><code>from</code> - Data source</li>
<li><code>where</code> - Filtering</li>
<li><code>select</code> - Projection</li>
<li><code>orderby</code> - Sorting</li>
<li><code>group by</code> - Grouping</li>
<li><code>join</code> - Joining</li>
<li><code>let</code> - Variable introduction</li>
<li><code>into</code> - Query continuation</li>
</ul>
<h3 id="pattern-expressions"><a class="header" href="#pattern-expressions">Pattern Expressions</a></h3>
<p>Modern C# pattern matching:</p>
<pre><code class="language-csharp">obj is int value           // Type pattern
obj is not null           // Negation pattern
obj is &gt; 0 and &lt; 100     // Relational patterns
obj is var x             // Var pattern
</code></pre>
<h3 id="switch-expressions"><a class="header" href="#switch-expressions">Switch Expressions</a></h3>
<pre><code class="language-csharp">value switch
{
    1 =&gt; "one",
    2 =&gt; "two",
    _ =&gt; "other"
}
</code></pre>
<h2 id="operator-precedence-implementation"><a class="header" href="#operator-precedence-implementation">Operator Precedence Implementation</a></h2>
<p>The parser implements precedence using recursive descent with precedence climbing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    parse_assignment_expression(input)
}

fn parse_assignment_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    // Handle assignment operators with right associativity
}

fn parse_conditional_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    // Handle ternary conditional operator
}

// ... continuing down the precedence chain
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-in-expressions"><a class="header" href="#error-handling-in-expressions">Error Handling in Expressions</a></h2>
<p>The expression parser provides detailed error messages:</p>
<ul>
<li><strong>Operator precedence conflicts</strong></li>
<li><strong>Missing operands</strong></li>
<li><strong>Invalid syntax combinations</strong></li>
<li><strong>Type compatibility issues</strong></li>
</ul>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="null-conditional-operators"><a class="header" href="#null-conditional-operators">Null-Conditional Operators</a></h3>
<pre><code class="language-csharp">obj?.Property        // Null-conditional member access
obj?[index]         // Null-conditional element access
obj?.Method()       // Null-conditional invocation
</code></pre>
<h3 id="throw-expressions"><a class="header" href="#throw-expressions">Throw Expressions</a></h3>
<pre><code class="language-csharp">value ?? throw new ArgumentNullException()
</code></pre>
<h3 id="range-and-index-expressions"><a class="header" href="#range-and-index-expressions">Range and Index Expressions</a></h3>
<pre><code class="language-csharp">array[^1]           // Index from end
array[1..5]         // Range
array[..^1]         // Range to index from end
</code></pre>
<h3 id="with-expressions-records"><a class="header" href="#with-expressions-records">With Expressions (Records)</a></h3>
<pre><code class="language-csharp">person with { Name = "Updated" }
</code></pre>
<p>The expression parser is designed to be extensible, allowing for easy addition of new expression types as the C# language evolves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statement-parsing-1"><a class="header" href="#statement-parsing-1">Statement Parsing</a></h1>
<p>BSharp provides comprehensive parsing for all C# statement types, from simple expressions to complex control flow constructs.</p>
<h2 id="statement-categories"><a class="header" href="#statement-categories">Statement Categories</a></h2>
<h3 id="1-declaration-statements"><a class="header" href="#1-declaration-statements">1. Declaration Statements</a></h3>
<h4 id="local-variable-declarations"><a class="header" href="#local-variable-declarations">Local Variable Declarations</a></h4>
<pre><code class="language-csharp">int x = 5;
var name = "John";
const double PI = 3.14159;
</code></pre>
<h4 id="local-function-declarations"><a class="header" href="#local-function-declarations">Local Function Declarations</a></h4>
<pre><code class="language-csharp">void LocalFunction(int parameter)
{
    // function body
}

T GenericLocalFunction&lt;T&gt;(T value) where T : class
{
    return value;
}
</code></pre>
<h3 id="2-expression-statements"><a class="header" href="#2-expression-statements">2. Expression Statements</a></h3>
<p>Any expression followed by a semicolon:</p>
<pre><code class="language-csharp">x++;                    // Increment
Method();              // Method call
obj.Property = value;  // Assignment
</code></pre>
<h3 id="3-control-flow-statements"><a class="header" href="#3-control-flow-statements">3. Control Flow Statements</a></h3>
<h4 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional Statements</a></h4>
<p><strong>If Statements</strong></p>
<pre><code class="language-csharp">if (condition)
    statement;

if (condition)
{
    // block
}
else if (otherCondition)
{
    // else if block
}
else
{
    // else block
}
</code></pre>
<p><strong>Switch Statements</strong></p>
<pre><code class="language-csharp">switch (expression)
{
    case constant1:
        statements;
        break;
    case constant2 when condition:
        statements;
        goto case constant1;
    default:
        statements;
        break;
}
</code></pre>
<h4 id="loop-statements"><a class="header" href="#loop-statements">Loop Statements</a></h4>
<p><strong>For Loops</strong></p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10; i++)
{
    // loop body
}

for (;;)  // infinite loop
{
    // body
}
</code></pre>
<p><strong>Foreach Loops</strong></p>
<pre><code class="language-csharp">foreach (var item in collection)
{
    // process item
}

foreach ((string key, int value) in dictionary)
{
    // deconstruction in foreach
}
</code></pre>
<p><strong>While Loops</strong></p>
<pre><code class="language-csharp">while (condition)
{
    // loop body
}
</code></pre>
<p><strong>Do-While Loops</strong></p>
<pre><code class="language-csharp">do
{
    // loop body
} while (condition);
</code></pre>
<h4 id="jump-statements"><a class="header" href="#jump-statements">Jump Statements</a></h4>
<pre><code class="language-csharp">break;              // Break from loop/switch
continue;           // Continue to next iteration
return;             // Return from method
return value;       // Return with value
goto label;         // Jump to label
goto case 5;        // Jump to switch case
goto default;       // Jump to switch default
</code></pre>
<h3 id="4-exception-handling"><a class="header" href="#4-exception-handling">4. Exception Handling</a></h3>
<h4 id="try-catch-finally"><a class="header" href="#try-catch-finally">Try-Catch-Finally</a></h4>
<pre><code class="language-csharp">try
{
    // risky code
}
catch (SpecificException ex) when (ex.Code == 123)
{
    // specific exception handling
}
catch (Exception ex)
{
    // general exception handling
}
finally
{
    // cleanup code
}
</code></pre>
<h4 id="throw-statements"><a class="header" href="#throw-statements">Throw Statements</a></h4>
<pre><code class="language-csharp">throw;                           // Rethrow current exception
throw new InvalidOperationException();
throw new CustomException("message");
</code></pre>
<h3 id="5-resource-management"><a class="header" href="#5-resource-management">5. Resource Management</a></h3>
<h4 id="using-statements"><a class="header" href="#using-statements">Using Statements</a></h4>
<pre><code class="language-csharp">using (var resource = new DisposableResource())
{
    // use resource
}

using var resource = new DisposableResource();
// resource disposed at end of scope
</code></pre>
<h4 id="lock-statements"><a class="header" href="#lock-statements">Lock Statements</a></h4>
<pre><code class="language-csharp">lock (syncObject)
{
    // synchronized code
}
</code></pre>
<h4 id="fixed-statements"><a class="header" href="#fixed-statements">Fixed Statements</a></h4>
<pre><code class="language-csharp">unsafe
{
    fixed (byte* ptr = array)
    {
        // work with fixed pointer
    }
}
</code></pre>
<h3 id="6-special-statements"><a class="header" href="#6-special-statements">6. Special Statements</a></h3>
<h4 id="yield-statements"><a class="header" href="#yield-statements">Yield Statements</a></h4>
<pre><code class="language-csharp">yield return value;     // Return value in iterator
yield break;           // End iterator
</code></pre>
<h4 id="checkedunchecked-statements"><a class="header" href="#checkedunchecked-statements">Checked/Unchecked Statements</a></h4>
<pre><code class="language-csharp">checked
{
    // arithmetic overflow checking enabled
}

unchecked
{
    // arithmetic overflow checking disabled
}
</code></pre>
<h4 id="unsafe-statements"><a class="header" href="#unsafe-statements">Unsafe Statements</a></h4>
<pre><code class="language-csharp">unsafe
{
    // unsafe code block
}
</code></pre>
<h2 id="statement-parsing-implementation"><a class="header" href="#statement-parsing-implementation">Statement Parsing Implementation</a></h2>
<p>The statement parser uses a dispatch mechanism based on the first token:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_statement(input: &amp;str) -&gt; BResult&lt;&amp;str, Statement&gt; {
    alt((
        parse_block_statement,
        parse_if_statement,
        parse_while_statement,
        parse_for_statement,
        parse_foreach_statement,
        parse_do_while_statement,
        parse_switch_statement,
        parse_try_statement,
        parse_using_statement,
        parse_lock_statement,
        parse_return_statement,
        parse_throw_statement,
        parse_break_statement,
        parse_continue_statement,
        parse_goto_statement,
        parse_label_statement,
        parse_yield_statement,
        parse_local_declaration_statement,
        parse_local_function_statement,
        parse_expression_statement,
        parse_empty_statement,
    ))(input)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="block-statements"><a class="header" href="#block-statements">Block Statements</a></h2>
<p>Block statements group multiple statements:</p>
<pre><code class="language-csharp">{
    int x = 5;
    Console.WriteLine(x);
    if (x &gt; 0)
    {
        Console.WriteLine("Positive");
    }
}
</code></pre>
<h2 id="error-recovery-1"><a class="header" href="#error-recovery-1">Error Recovery</a></h2>
<p>The statement parser implements robust error recovery:</p>
<ol>
<li><strong>Statement-level recovery</strong>: Skip to next statement boundary (semicolon or brace)</li>
<li><strong>Block-level recovery</strong>: Skip to matching brace</li>
<li><strong>Context preservation</strong>: Maintain parsing context across errors</li>
</ol>
<h2 id="statement-attributes"><a class="header" href="#statement-attributes">Statement Attributes</a></h2>
<p>Statements can have attributes applied:</p>
<pre><code class="language-csharp">[Obsolete("Use NewMethod instead")]
void OldMethod() { }

[ConditionalAttribute("DEBUG")]
static void DebugMethod() { }
</code></pre>
<h2 id="top-level-statements"><a class="header" href="#top-level-statements">Top-Level Statements</a></h2>
<p>Support for C# 9+ top-level statements:</p>
<pre><code class="language-csharp">// Program.cs
using System;

Console.WriteLine("Hello World!");
return 0;
</code></pre>
<p>The statement parser is designed to handle the full complexity of C# control flow while providing clear error messages and robust error recovery.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaration-parsing-1"><a class="header" href="#declaration-parsing-1">Declaration Parsing</a></h1>
<p>BSharp implements comprehensive parsing for all C# declaration types, from simple variables to complex generic types with constraints.</p>
<h2 id="declaration-categories"><a class="header" href="#declaration-categories">Declaration Categories</a></h2>
<h3 id="1-namespace-declarations"><a class="header" href="#1-namespace-declarations">1. Namespace Declarations</a></h3>
<h4 id="traditional-namespace"><a class="header" href="#traditional-namespace">Traditional Namespace</a></h4>
<pre><code class="language-csharp">namespace MyCompany.MyProject
{
    // namespace members
}
</code></pre>
<h4 id="file-scoped-namespace-c-10"><a class="header" href="#file-scoped-namespace-c-10">File-Scoped Namespace (C# 10+)</a></h4>
<pre><code class="language-csharp">namespace MyCompany.MyProject;

// All following declarations belong to this namespace
</code></pre>
<h4 id="nested-namespaces"><a class="header" href="#nested-namespaces">Nested Namespaces</a></h4>
<pre><code class="language-csharp">namespace Outer
{
    namespace Inner
    {
        // nested namespace content
    }
}
</code></pre>
<h3 id="2-type-declarations"><a class="header" href="#2-type-declarations">2. Type Declarations</a></h3>
<h4 id="class-declarations"><a class="header" href="#class-declarations">Class Declarations</a></h4>
<pre><code class="language-csharp">public class MyClass : BaseClass, IInterface1, IInterface2
{
    // class members
}

public abstract class AbstractClass
{
    public abstract void AbstractMethod();
}

public sealed class SealedClass
{
    // cannot be inherited
}
</code></pre>
<h4 id="interface-declarations"><a class="header" href="#interface-declarations">Interface Declarations</a></h4>
<pre><code class="language-csharp">public interface IMyInterface : IBaseInterface
{
    void Method();
    int Property { get; set; }
    event Action SomeEvent;
}

public interface IGeneric&lt;T&gt; where T : class
{
    T GenericMethod&lt;U&gt;(U parameter) where U : struct;
}
</code></pre>
<h4 id="struct-declarations"><a class="header" href="#struct-declarations">Struct Declarations</a></h4>
<pre><code class="language-csharp">public struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}

public readonly struct ReadOnlyPoint
{
    public readonly int X;
    public readonly int Y;
    
    public ReadOnlyPoint(int x, int y)
    {
        X = x;
        Y = y;
    }
}
</code></pre>
<h4 id="record-declarations"><a class="header" href="#record-declarations">Record Declarations</a></h4>
<pre><code class="language-csharp">public record Person(string FirstName, string LastName);

public record class Employee(string FirstName, string LastName, string Department)
    : Person(FirstName, LastName);

public record struct Point(int X, int Y);
</code></pre>
<h4 id="enum-declarations"><a class="header" href="#enum-declarations">Enum Declarations</a></h4>
<pre><code class="language-csharp">public enum Color
{
    Red,
    Green,
    Blue
}

[Flags]
public enum FileAccess : byte
{
    None = 0,
    Read = 1,
    Write = 2,
    Execute = 4,
    All = Read | Write | Execute
}
</code></pre>
<h4 id="delegate-declarations"><a class="header" href="#delegate-declarations">Delegate Declarations</a></h4>
<pre><code class="language-csharp">public delegate void EventHandler(object sender, EventArgs e);
public delegate T GenericDelegate&lt;T, U&gt;(U parameter) where T : class;
</code></pre>
<h3 id="3-member-declarations"><a class="header" href="#3-member-declarations">3. Member Declarations</a></h3>
<h4 id="field-declarations"><a class="header" href="#field-declarations">Field Declarations</a></h4>
<pre><code class="language-csharp">private int field;
public readonly string ReadOnlyField;
public const double PI = 3.14159;
private static readonly List&lt;string&gt; StaticField = new();
</code></pre>
<h4 id="property-declarations"><a class="header" href="#property-declarations">Property Declarations</a></h4>
<pre><code class="language-csharp">// Auto-implemented properties
public string Name { get; set; }
public int Age { get; private set; }
public bool IsValid { get; init; }

// Properties with backing fields
private string _description;
public string Description
{
    get =&gt; _description;
    set =&gt; _description = value?.Trim();
}

// Expression-bodied properties
public string FullName =&gt; $"{FirstName} {LastName}";

// Indexer properties
public string this[int index]
{
    get =&gt; items[index];
    set =&gt; items[index] = value;
}
</code></pre>
<h4 id="method-declarations"><a class="header" href="#method-declarations">Method Declarations</a></h4>
<pre><code class="language-csharp">public void VoidMethod() { }
public int MethodWithReturnType() =&gt; 42;
public static T GenericMethod&lt;T&gt;(T parameter) where T : new() =&gt; new T();

// Async methods
public async Task&lt;string&gt; AsyncMethod()
{
    await Task.Delay(1000);
    return "result";
}

// Extension methods
public static class Extensions
{
    public static bool IsEmpty(this string str) =&gt; string.IsNullOrEmpty(str);
}
</code></pre>
<h4 id="constructor-declarations"><a class="header" href="#constructor-declarations">Constructor Declarations</a></h4>
<pre><code class="language-csharp">public class MyClass
{
    public MyClass() { }                    // Default constructor
    public MyClass(string name) : this()   // Constructor chaining
    {
        Name = name;
    }
    
    static MyClass()                        // Static constructor
    {
        // Static initialization
    }
}
</code></pre>
<h4 id="destructor-declarations"><a class="header" href="#destructor-declarations">Destructor Declarations</a></h4>
<pre><code class="language-csharp">public class Resource
{
    ~Resource()
    {
        // Cleanup code
    }
}
</code></pre>
<h4 id="event-declarations"><a class="header" href="#event-declarations">Event Declarations</a></h4>
<pre><code class="language-csharp">public event Action&lt;string&gt; SomethingHappened;

public event EventHandler&lt;CustomEventArgs&gt; CustomEvent
{
    add { customEvent += value; }
    remove { customEvent -= value; }
}
</code></pre>
<h4 id="operator-declarations"><a class="header" href="#operator-declarations">Operator Declarations</a></h4>
<pre><code class="language-csharp">public static Point operator +(Point a, Point b)
{
    return new Point(a.X + b.X, a.Y + b.Y);
}

public static implicit operator string(Point p)
{
    return $"({p.X}, {p.Y})";
}
</code></pre>
<h3 id="4-generic-constraints"><a class="header" href="#4-generic-constraints">4. Generic Constraints</a></h3>
<h4 id="type-parameter-constraints"><a class="header" href="#type-parameter-constraints">Type Parameter Constraints</a></h4>
<pre><code class="language-csharp">public class Container&lt;T&gt; where T : class, IDisposable, new()
{
    // T must be a reference type, implement IDisposable, and have a parameterless constructor
}

public void Method&lt;T, U&gt;()
    where T : class
    where U : struct, IComparable&lt;U&gt;
{
    // Multiple constraint clauses
}
</code></pre>
<h3 id="5-modifiers-and-attributes"><a class="header" href="#5-modifiers-and-attributes">5. Modifiers and Attributes</a></h3>
<h4 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h4>
<ul>
<li><code>public</code> - Accessible everywhere</li>
<li><code>private</code> - Accessible only within the same class</li>
<li><code>protected</code> - Accessible within class and derived classes</li>
<li><code>internal</code> - Accessible within the same assembly</li>
<li><code>protected internal</code> - Accessible within assembly or derived classes</li>
<li><code>private protected</code> - Accessible within derived classes in the same assembly</li>
</ul>
<h4 id="other-modifiers"><a class="header" href="#other-modifiers">Other Modifiers</a></h4>
<ul>
<li><code>static</code> - Belongs to the type rather than instance</li>
<li><code>abstract</code> - Must be overridden in derived classes</li>
<li><code>virtual</code> - Can be overridden in derived classes</li>
<li><code>override</code> - Overrides a virtual/abstract member</li>
<li><code>sealed</code> - Cannot be overridden further</li>
<li><code>readonly</code> - Can only be assigned during initialization</li>
<li><code>const</code> - Compile-time constant</li>
<li><code>async</code> - Asynchronous method</li>
<li><code>unsafe</code> - Contains unsafe code</li>
<li><code>extern</code> - Implemented externally</li>
</ul>
<h4 id="attributes-1"><a class="header" href="#attributes-1">Attributes</a></h4>
<pre><code class="language-csharp">[Obsolete("Use NewMethod instead")]
public void OldMethod() { }

[DllImport("kernel32.dll")]
public static extern bool SetConsoleTitle(string title);

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class CustomAttribute : Attribute
{
    public string Description { get; set; }
}
</code></pre>
<h3 id="6-using-directives"><a class="header" href="#6-using-directives">6. Using Directives</a></h3>
<pre><code class="language-csharp">using System;                           // Namespace using
using System.Collections.Generic;
using static System.Math;               // Static using
using Project = MyCompany.MyProject;    // Alias directive
global using System.Text;              // Global using (C# 10+)
</code></pre>
<h2 id="declaration-parsing-implementation"><a class="header" href="#declaration-parsing-implementation">Declaration Parsing Implementation</a></h2>
<p>The declaration parser uses a multi-stage approach:</p>
<ol>
<li><strong>Modifier Parsing</strong>: Parse access modifiers and other keywords</li>
<li><strong>Declaration Type Detection</strong>: Determine what kind of declaration</li>
<li><strong>Specific Parser Dispatch</strong>: Route to specialized parser</li>
<li><strong>Member Collection</strong>: Gather all declaration components</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_type_declaration(input: &amp;str) -&gt; BResult&lt;&amp;str, TypeDeclaration&gt; {
    let (input, attributes) = many0(parse_attribute)(input)?;
    let (input, modifiers) = parse_modifiers(input)?;
    let (input, declaration) = alt((
        parse_class_declaration,
        parse_interface_declaration,
        parse_struct_declaration,
        parse_enum_declaration,
        parse_delegate_declaration,
        parse_record_declaration,
    ))(input)?;
    
    Ok((input, TypeDeclaration {
        attributes,
        modifiers,
        declaration,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The declaration parser provides comprehensive error reporting:</p>
<ul>
<li><strong>Modifier conflicts</strong>: Detecting incompatible modifier combinations</li>
<li><strong>Constraint validation</strong>: Ensuring generic constraints are valid</li>
<li><strong>Accessibility consistency</strong>: Verifying access level consistency</li>
<li><strong>Syntax validation</strong>: Catching malformed declarations</li>
</ul>
<h3 id="recovery-for-malformed-members"><a class="header" href="#recovery-for-malformed-members">Recovery for Malformed Members</a></h3>
<p>When a member inside a type body fails to parse, the parser uses a scoped recovery strategy to skip to the next safe boundary without crossing the enclosing type's closing brace. See the dedicated section in Error Handling for details on <code>skip_to_member_boundary_top_level()</code> and its contract:</p>
<ul>
<li>docs: <code>docs/parser/error-handling.md</code> (Declaration Error Recovery subsection)</li>
</ul>
<h2 id="xml-documentation"><a class="header" href="#xml-documentation">XML Documentation</a></h2>
<p>The parser handles XML documentation comments:</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// Calculates the area of a rectangle.
/// &lt;/summary&gt;
/// &lt;param name="width"&gt;The width of the rectangle.&lt;/param&gt;
/// &lt;param name="height"&gt;The height of the rectangle.&lt;/param&gt;
/// &lt;returns&gt;The area of the rectangle.&lt;/returns&gt;
public double CalculateArea(double width, double height)
{
    return width * height;
}
</code></pre>
<p>The declaration parser is designed to handle the full complexity of C# type system while maintaining performance and providing detailed error diagnostics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system-1"><a class="header" href="#type-system-1">Type System</a></h1>
<p>BSharp implements a comprehensive type system that accurately represents all C# type constructs, from primitive types to complex generic types with constraints.</p>
<h2 id="type-categories"><a class="header" href="#type-categories">Type Categories</a></h2>
<h3 id="1-primitive-types"><a class="header" href="#1-primitive-types">1. Primitive Types</a></h3>
<h4 id="built-in-value-types"><a class="header" href="#built-in-value-types">Built-in Value Types</a></h4>
<pre><code class="language-csharp">bool        // Boolean type
byte        // 8-bit unsigned integer
sbyte       // 8-bit signed integer
short       // 16-bit signed integer
ushort      // 16-bit unsigned integer
int         // 32-bit signed integer
uint        // 32-bit unsigned integer
long        // 64-bit signed integer
ulong       // 64-bit unsigned integer
char        // 16-bit Unicode character
float       // 32-bit floating point
double      // 64-bit floating point
decimal     // 128-bit decimal
</code></pre>
<h4 id="special-types"><a class="header" href="#special-types">Special Types</a></h4>
<pre><code class="language-csharp">object      // Base type of all types
string      // Immutable string type
void        // Absence of type (method returns)
dynamic     // Dynamic type
var         // Implicitly typed variable
</code></pre>
<h3 id="2-reference-types"><a class="header" href="#2-reference-types">2. Reference Types</a></h3>
<h4 id="class-types"><a class="header" href="#class-types">Class Types</a></h4>
<pre><code class="language-csharp">MyClass                 // Simple class reference
System.Collections.List&lt;int&gt;  // Generic class
</code></pre>
<h4 id="interface-types"><a class="header" href="#interface-types">Interface Types</a></h4>
<pre><code class="language-csharp">IEnumerable&lt;T&gt;         // Generic interface
IDisposable            // Non-generic interface
</code></pre>
<h4 id="array-types"><a class="header" href="#array-types">Array Types</a></h4>
<pre><code class="language-csharp">int[]                  // Single-dimensional array
int[,]                 // Multi-dimensional array
int[][]                // Jagged array
int[,,]                // Three-dimensional array
</code></pre>
<h4 id="delegate-types"><a class="header" href="#delegate-types">Delegate Types</a></h4>
<pre><code class="language-csharp">Action                 // Parameterless action
Action&lt;int&gt;            // Action with parameter
Func&lt;int, string&gt;      // Function with return type
EventHandler&lt;T&gt;        // Event handler
</code></pre>
<h3 id="3-nullable-types"><a class="header" href="#3-nullable-types">3. Nullable Types</a></h3>
<h4 id="nullable-value-types"><a class="header" href="#nullable-value-types">Nullable Value Types</a></h4>
<pre><code class="language-csharp">int?                   // Nullable integer
DateTime?              // Nullable DateTime
bool?                  // Nullable boolean
</code></pre>
<h4 id="nullable-reference-types-c-8"><a class="header" href="#nullable-reference-types-c-8">Nullable Reference Types (C# 8+)</a></h4>
<pre><code class="language-csharp">string?                // Nullable string
List&lt;int&gt;?             // Nullable list
MyClass?               // Nullable custom class
</code></pre>
<h3 id="4-generic-types"><a class="header" href="#4-generic-types">4. Generic Types</a></h3>
<h4 id="type-parameters"><a class="header" href="#type-parameters">Type Parameters</a></h4>
<pre><code class="language-csharp">T                      // Simple type parameter
TKey, TValue           // Multiple type parameters
</code></pre>
<h4 id="constructed-generic-types"><a class="header" href="#constructed-generic-types">Constructed Generic Types</a></h4>
<pre><code class="language-csharp">List&lt;int&gt;              // Generic list of integers
Dictionary&lt;string, object&gt;  // Generic dictionary
</code></pre>
<h4 id="generic-constraints"><a class="header" href="#generic-constraints">Generic Constraints</a></h4>
<pre><code class="language-csharp">T where T : class                    // Reference type constraint
T where T : struct                   // Value type constraint
T where T : new()                    // Constructor constraint
T where T : BaseClass                // Base class constraint
T where T : IInterface               // Interface constraint
T where T : class, IDisposable, new() // Multiple constraints
</code></pre>
<h3 id="5-tuple-types"><a class="header" href="#5-tuple-types">5. Tuple Types</a></h3>
<h4 id="named-tuples"><a class="header" href="#named-tuples">Named Tuples</a></h4>
<pre><code class="language-csharp">(int x, int y)         // Named tuple elements
(string name, int age) // Different element types
</code></pre>
<h4 id="unnamed-tuples"><a class="header" href="#unnamed-tuples">Unnamed Tuples</a></h4>
<pre><code class="language-csharp">(int, string)          // Unnamed tuple elements
</code></pre>
<h4 id="nested-tuples"><a class="header" href="#nested-tuples">Nested Tuples</a></h4>
<pre><code class="language-csharp">(int, (string, bool))  // Nested tuple structure
</code></pre>
<h3 id="6-pointer-types-unsafe-context"><a class="header" href="#6-pointer-types-unsafe-context">6. Pointer Types (Unsafe Context)</a></h3>
<pre><code class="language-csharp">int*                   // Pointer to integer
char**                 // Pointer to pointer to char
void*                  // Void pointer
</code></pre>
<h3 id="7-function-pointer-types-c-9"><a class="header" href="#7-function-pointer-types-c-9">7. Function Pointer Types (C# 9+)</a></h3>
<pre><code class="language-csharp">delegate*&lt;int, string&gt;              // Function pointer
delegate* managed&lt;int, void&gt;        // Managed function pointer
delegate* unmanaged&lt;int, void&gt;      // Unmanaged function pointer
</code></pre>
<h2 id="type-syntax-parsing"><a class="header" href="#type-syntax-parsing">Type Syntax Parsing</a></h2>
<h3 id="basic-type-parsing"><a class="header" href="#basic-type-parsing">Basic Type Parsing</a></h3>
<p>The type parser handles various syntactic forms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_type(input: &amp;str) -&gt; BResult&lt;&amp;str, Type&gt; {
    alt((
        parse_tuple_type,
        parse_function_pointer_type,
        parse_named_type,
        parse_primitive_type,
    ))(input)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="array-type-parsing"><a class="header" href="#array-type-parsing">Array Type Parsing</a></h3>
<p>Array types have specific syntax rules:</p>
<pre><code class="language-csharp">int[]                  // T[]
int[,]                 // T[,]
int[,,]                // T[,,]
int[][]                // T[][] (jagged)
</code></pre>
<h3 id="generic-type-parsing"><a class="header" href="#generic-type-parsing">Generic Type Parsing</a></h3>
<p>Generic types require careful parsing of type arguments:</p>
<pre><code class="language-csharp">List&lt;int&gt;              // Simple generic
Dictionary&lt;string, List&lt;int&gt;&gt;  // Nested generics
</code></pre>
<h3 id="nullable-type-parsing"><a class="header" href="#nullable-type-parsing">Nullable Type Parsing</a></h3>
<p>Nullable types use special syntax:</p>
<pre><code class="language-csharp">int?                   // Nullable&lt;int&gt;
string?                // string with nullable annotation
</code></pre>
<h2 id="type-resolution"><a class="header" href="#type-resolution">Type Resolution</a></h2>
<h3 id="qualified-names"><a class="header" href="#qualified-names">Qualified Names</a></h3>
<p>Types can be fully qualified:</p>
<pre><code class="language-csharp">System.Collections.Generic.List&lt;int&gt;
MyNamespace.MyClass
</code></pre>
<h3 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h3>
<p>Using directives create type aliases:</p>
<pre><code class="language-csharp">using StringList = System.Collections.Generic.List&lt;string&gt;;
</code></pre>
<h3 id="global-type-references"><a class="header" href="#global-type-references">Global Type References</a></h3>
<p>Global namespace references:</p>
<pre><code class="language-csharp">global::System.String  // Fully qualified from global namespace
</code></pre>
<h2 id="type-constraints"><a class="header" href="#type-constraints">Type Constraints</a></h2>
<h3 id="constraint-types"><a class="header" href="#constraint-types">Constraint Types</a></h3>
<ol>
<li><strong>Reference Type</strong>: <code>where T : class</code></li>
<li><strong>Value Type</strong>: <code>where T : struct</code></li>
<li><strong>Constructor</strong>: <code>where T : new()</code></li>
<li><strong>Base Class</strong>: <code>where T : BaseClass</code></li>
<li><strong>Interface</strong>: <code>where T : IInterface</code></li>
<li><strong>Type Parameter</strong>: <code>where T : U</code></li>
</ol>
<h3 id="constraint-combinations"><a class="header" href="#constraint-combinations">Constraint Combinations</a></h3>
<p>Multiple constraints can be combined:</p>
<pre><code class="language-csharp">where T : class, IDisposable, new()
</code></pre>
<h3 id="constraint-validation"><a class="header" href="#constraint-validation">Constraint Validation</a></h3>
<p>The parser validates constraint combinations:</p>
<ul>
<li><code>class</code> and <code>struct</code> are mutually exclusive</li>
<li><code>new()</code> constraint must come last</li>
<li>Base class constraint must come before interface constraints</li>
</ul>
<h2 id="type-variance"><a class="header" href="#type-variance">Type Variance</a></h2>
<h3 id="covariance-and-contravariance"><a class="header" href="#covariance-and-contravariance">Covariance and Contravariance</a></h3>
<pre><code class="language-csharp">interface ICovariant&lt;out T&gt; { }     // Covariant
interface IContravariant&lt;in T&gt; { }  // Contravariant
interface IInvariant&lt;T&gt; { }         // Invariant
</code></pre>
<h2 id="advanced-type-features"><a class="header" href="#advanced-type-features">Advanced Type Features</a></h2>
<h3 id="record-types"><a class="header" href="#record-types">Record Types</a></h3>
<pre><code class="language-csharp">record Person(string Name, int Age);
record class Employee(string Name, int Age, string Department);
record struct Point(int X, int Y);
</code></pre>
<h3 id="pattern-types"><a class="header" href="#pattern-types">Pattern Types</a></h3>
<p>Types used in pattern matching:</p>
<pre><code class="language-csharp">obj is string str          // Type pattern
obj is not null           // Negation pattern
obj is &gt; 0 and &lt; 100     // Relational pattern
</code></pre>
<h2 id="type-system-implementation"><a class="header" href="#type-system-implementation">Type System Implementation</a></h2>
<p>The type system is implemented with a hierarchical structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Type {
    Primitive(PrimitiveType),
    Named {
        name: Identifier,
        type_arguments: Option&lt;Vec&lt;Type&gt;&gt;,
    },
    Array {
        element_type: Box&lt;Type&gt;,
        dimensions: u32,
    },
    Nullable(Box&lt;Type&gt;),
    Tuple(Vec&lt;(Option&lt;Identifier&gt;, Type)&gt;),
    Pointer(Box&lt;Type&gt;),
    FunctionPointer {
        parameters: Vec&lt;Type&gt;,
        return_type: Box&lt;Type&gt;,
    },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>The type parser provides detailed error messages for:</p>
<ul>
<li><strong>Invalid type syntax</strong></li>
<li><strong>Constraint violations</strong></li>
<li><strong>Generic parameter mismatches</strong></li>
<li><strong>Nullable context errors</strong></li>
<li><strong>Variance violations</strong></li>
</ul>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>While the parser doesn't perform type inference (that's the compiler's job), it correctly parses:</p>
<ul>
<li><code>var</code> declarations</li>
<li>Anonymous types</li>
<li>Implicitly typed arrays</li>
<li>Lambda parameter types</li>
</ul>
<p>The type system parser is designed to accurately represent the full complexity of C#'s type system while maintaining performance and providing clear error diagnostics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-navigation"><a class="header" href="#ast-navigation">AST Navigation</a></h1>
<p>The BSharp parser provides powerful navigation capabilities through a set of traits that allow traversing and searching the AST efficiently. This system enables complex code analysis scenarios.</p>
<h2 id="navigation-traits"><a class="header" href="#navigation-traits">Navigation Traits</a></h2>
<h3 id="astnavigate-trait"><a class="header" href="#astnavigate-trait">AstNavigate Trait</a></h3>
<p>The primary trait for finding specific statement types within AST nodes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AstNavigate {
    fn find_if_statements(&amp;self) -&gt; Vec&lt;&amp;Statement&gt;;
    fn find_for_loops(&amp;self) -&gt; Vec&lt;&amp;Statement&gt;;
    fn find_while_loops(&amp;self) -&gt; Vec&lt;&amp;Statement&gt;;
    fn find_switch_statements(&amp;self) -&gt; Vec&lt;&amp;Statement&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait is implemented for all major AST node types, providing a consistent interface for statement searching.</p>
<h3 id="finddeclarations-trait"><a class="header" href="#finddeclarations-trait">FindDeclarations Trait</a></h3>
<p>Specialized trait for finding declaration types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FindDeclarations {
    fn find_classes(&amp;self) -&gt; Vec&lt;&amp;ClassDeclaration&gt;;
    fn find_methods(&amp;self) -&gt; Vec&lt;&amp;MethodDeclaration&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait focuses on structural elements like classes and methods, which are commonly needed for code analysis.</p>
<h2 id="implementation-hierarchy"><a class="header" href="#implementation-hierarchy">Implementation Hierarchy</a></h2>
<h3 id="compilationunit-navigation"><a class="header" href="#compilationunit-navigation">CompilationUnit Navigation</a></h3>
<p>The root-level implementation provides top-down traversal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AstNavigate for CompilationUnit {
    fn find_if_statements(&amp;self) -&gt; Vec&lt;&amp;Statement&gt; {
        let mut results = Vec::new();
        for class in self.find_classes() {
            results.extend(class.find_if_statements());
        }
        results
    }
    // Similar implementations for other statement types
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation:</p>
<ul>
<li>Traverses all top-level declarations</li>
<li>Delegates to class-level navigation</li>
<li>Aggregates results from all classes</li>
</ul>
<h3 id="class-level-navigation"><a class="header" href="#class-level-navigation">Class-Level Navigation</a></h3>
<p>Class navigation focuses on methods and their contents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AstNavigate for ClassDeclaration {
    fn find_if_statements(&amp;self) -&gt; Vec&lt;&amp;Statement&gt; {
        let mut results = Vec::new();
        for method in self.find_methods() {
            results.extend(method.find_if_statements());
        }
        results
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Key features:</p>
<ul>
<li>Iterates through all class body declarations</li>
<li>Filters for method declarations</li>
<li>Delegates statement searching to methods</li>
</ul>
<h3 id="method-level-navigation"><a class="header" href="#method-level-navigation">Method-Level Navigation</a></h3>
<p>Methods provide direct access to their statement body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AstNavigate for MethodDeclaration {
    fn find_if_statements(&amp;self) -&gt; Vec&lt;&amp;Statement&gt; {
        if let Some(body) = &amp;self.body {
            body.find_if_statements()
        } else {
            Vec::new()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Handles both:</p>
<ul>
<li>Methods with bodies (concrete methods)</li>
<li>Methods without bodies (abstract/interface methods)</li>
</ul>
<h3 id="statement-level-navigation"><a class="header" href="#statement-level-navigation">Statement-Level Navigation</a></h3>
<p>The most complex navigation occurs at the statement level:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AstNavigate for Statement {
    fn find_if_statements(&amp;self) -&gt; Vec&lt;&amp;Statement&gt; {
        let mut results = Vec::new();
        collect_if_statements(self, &amp;mut results);
        results
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Uses recursive helper functions to traverse nested statement structures.</p>
<h2 id="recursive-collection-algorithms"><a class="header" href="#recursive-collection-algorithms">Recursive Collection Algorithms</a></h2>
<h3 id="if-statement-collection"><a class="header" href="#if-statement-collection">If Statement Collection</a></h3>
<p>Specialized algorithm for finding if statements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_if_statements&lt;'a&gt;(stmt: &amp;'a Statement, results: &amp;mut Vec&lt;&amp;'a Statement&gt;) {
    match stmt {
        Statement::If(if_stmt) =&gt; {
            results.push(stmt);                              // Add this if statement
            collect_if_statements(&amp;if_stmt.consequence, results);  // Search consequence
            if let Some(alt) = &amp;if_stmt.alternative {
                collect_if_statements(alt, results);         // Search alternative
            }
        }
        Statement::Block(statements) =&gt; {
            for s in statements {
                collect_if_statements(s, results);           // Search each statement in block
            }
        }
        // Handle other statement types that can contain nested statements
        Statement::For(for_stmt) =&gt; collect_if_statements(&amp;for_stmt.body, results),
        Statement::While(while_stmt) =&gt; collect_if_statements(&amp;while_stmt.body, results),
        // ... other cases
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This algorithm:</p>
<ul>
<li>Identifies target statements and adds them to results</li>
<li>Recursively searches nested statement structures</li>
<li>Handles all statement types that can contain other statements</li>
</ul>
<h3 id="loop-collection"><a class="header" href="#loop-collection">Loop Collection</a></h3>
<p>Similar algorithms exist for different loop types:</p>
<h4 id="for-loop-collection"><a class="header" href="#for-loop-collection">For Loop Collection</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_for_loops&lt;'a&gt;(stmt: &amp;'a Statement, results: &amp;mut Vec&lt;&amp;'a Statement&gt;) {
    match stmt {
        Statement::For(for_stmt) =&gt; {
            results.push(stmt);
            collect_for_loops(&amp;for_stmt.body, results);
        }
        // ... search other statement types for nested for loops
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="while-loop-collection"><a class="header" href="#while-loop-collection">While Loop Collection</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_while_loops&lt;'a&gt;(stmt: &amp;'a Statement, results: &amp;mut Vec&lt;&amp;'a Statement&gt;) {
    match stmt {
        Statement::While(_) | Statement::DoWhile(_) =&gt; {
            results.push(stmt);
            match stmt {
                Statement::While(while_stmt) =&gt; collect_while_loops(&amp;while_stmt.body, results),
                Statement::DoWhile(do_while_stmt) =&gt; collect_while_loops(&amp;do_while_stmt.body, results),
                _ =&gt; unreachable!(),
            }
        }
        // ... search other statement types
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="declaration-finding"><a class="header" href="#declaration-finding">Declaration Finding</a></h2>
<h3 id="class-discovery"><a class="header" href="#class-discovery">Class Discovery</a></h3>
<p>Finding classes across namespace and top-level boundaries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FindDeclarations for CompilationUnit {
    fn find_classes(&amp;self) -&gt; Vec&lt;&amp;ClassDeclaration&gt; {
        let mut classes = Vec::new();
        for member in &amp;self.declarations {
            match member {
                TopLevelDeclaration::Namespace(ns) =&gt; {
                    for ns_member in &amp;ns.declarations {
                        if let NamespaceBodyDeclaration::Class(class) = ns_member {
                            classes.push(class);
                        }
                    }
                }
                TopLevelDeclaration::Class(class) =&gt; {
                    classes.push(class);
                }
                _ =&gt; {}
            }
        }
        classes
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Handles:</p>
<ul>
<li>Classes declared at the top level</li>
<li>Classes declared within namespaces</li>
<li>Nested class scenarios</li>
</ul>
<h3 id="method-discovery"><a class="header" href="#method-discovery">Method Discovery</a></h3>
<p>Finding methods within class bodies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FindDeclarations for ClassDeclaration {
    fn find_methods(&amp;self) -&gt; Vec&lt;&amp;MethodDeclaration&gt; {
        let mut methods = Vec::new();
        for member in &amp;self.body_declarations {
            if let ClassBodyDeclaration::Method(method) = member {
                methods.push(method);
            }
        }
        methods
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Features:</p>
<ul>
<li>Iterates through all class body declarations</li>
<li>Filters for method declarations</li>
<li>Returns references to avoid cloning</li>
</ul>
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="basic-statement-search"><a class="header" href="#basic-statement-search">Basic Statement Search</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all if statements in a compilation unit
let if_statements = compilation_unit.find_if_statements();
for if_stmt in if_statements {
    // Analyze each if statement
}
<span class="boring">}</span></code></pre></pre>
<h3 id="complex-analysis"><a class="header" href="#complex-analysis">Complex Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find methods with complex control flow
let methods = compilation_unit.find_methods();
for method in methods {
    let if_count = method.find_if_statements().len();
    let loop_count = method.find_for_loops().len() + method.find_while_loops().len();
    let switch_count = method.find_switch_statements().len();
    
    if if_count + loop_count + switch_count &gt; 10 {
        println!("Complex method: {:?}", method.identifier);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="nested-structure-analysis"><a class="header" href="#nested-structure-analysis">Nested Structure Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Analyze nesting depth of control structures
fn analyze_nesting_depth(stmt: &amp;Statement) -&gt; usize {
    match stmt {
        Statement::If(if_stmt) =&gt; {
            let consequence_depth = analyze_nesting_depth(&amp;if_stmt.consequence);
            let alternative_depth = if_stmt.alternative
                .as_ref()
                .map(|alt| analyze_nesting_depth(alt))
                .unwrap_or(0);
            1 + std::cmp::max(consequence_depth, alternative_depth)
        }
        Statement::Block(statements) =&gt; {
            statements.iter()
                .map(analyze_nesting_depth)
                .max()
                .unwrap_or(0)
        }
        // ... handle other statement types
        _ =&gt; 0,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="memory-efficiency"><a class="header" href="#memory-efficiency">Memory Efficiency</a></h3>
<ul>
<li>Uses references (<code>&amp;</code>) instead of cloning nodes</li>
<li>Minimal allocation during traversal</li>
<li>Lazy evaluation where possible</li>
</ul>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<ul>
<li>Linear traversal: O(n) where n is the number of AST nodes</li>
<li>No redundant visits to nodes</li>
<li>Early termination for targeted searches</li>
</ul>
<h3 id="extensibility"><a class="header" href="#extensibility">Extensibility</a></h3>
<p>The navigation system is designed for extension:</p>
<ul>
<li>Add new search methods to existing traits</li>
<li>Implement traits for new AST node types</li>
<li>Create specialized navigation traits for specific analysis needs</li>
</ul>
<p>This navigation system provides the foundation for sophisticated code analysis while maintaining performance and usability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comment-parsing"><a class="header" href="#comment-parsing">Comment Parsing</a></h1>
<p>BSharp implements comprehensive comment parsing for both regular comments and XML documentation comments, preserving them as part of the AST for documentation generation and analysis tools.</p>
<h2 id="comment-types"><a class="header" href="#comment-types">Comment Types</a></h2>
<h3 id="1-single-line-comments"><a class="header" href="#1-single-line-comments">1. Single-Line Comments</a></h3>
<p>Standard C++ style comments:</p>
<pre><code class="language-csharp">// This is a single-line comment
int x = 5; // End-of-line comment
</code></pre>
<h3 id="2-multi-line-comments"><a class="header" href="#2-multi-line-comments">2. Multi-Line Comments</a></h3>
<p>Traditional C-style block comments:</p>
<pre><code class="language-csharp">/*
 * This is a multi-line comment
 * that spans several lines
 */
int y = 10; /* Inline block comment */
</code></pre>
<h3 id="3-xml-documentation-comments"><a class="header" href="#3-xml-documentation-comments">3. XML Documentation Comments</a></h3>
<h4 id="single-line-xml-comments"><a class="header" href="#single-line-xml-comments">Single-Line XML Comments</a></h4>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// This method calculates the sum of two integers.
/// &lt;/summary&gt;
/// &lt;param name="a"&gt;The first integer.&lt;/param&gt;
/// &lt;param name="b"&gt;The second integer.&lt;/param&gt;
/// &lt;returns&gt;The sum of a and b.&lt;/returns&gt;
public int Add(int a, int b)
{
    return a + b;
}
</code></pre>
<h4 id="multi-line-xml-comments"><a class="header" href="#multi-line-xml-comments">Multi-Line XML Comments</a></h4>
<pre><code class="language-csharp">/**
 * &lt;summary&gt;
 * This is a multi-line XML documentation comment.
 * It provides detailed information about the method.
 * &lt;/summary&gt;
 * &lt;param name="value"&gt;The input value to process.&lt;/param&gt;
 * &lt;returns&gt;The processed result.&lt;/returns&gt;
 */
public string ProcessValue(string value) { }
</code></pre>
<h2 id="xml-documentation-structure"><a class="header" href="#xml-documentation-structure">XML Documentation Structure</a></h2>
<h3 id="standard-xml-tags"><a class="header" href="#standard-xml-tags">Standard XML Tags</a></h3>
<h4 id="summary-and-description"><a class="header" href="#summary-and-description">Summary and Description</a></h4>
<pre><code class="language-xml">&lt;summary&gt;
Brief description of the member.
&lt;/summary&gt;

&lt;remarks&gt;
Detailed remarks and additional information.
&lt;/remarks&gt;
</code></pre>
<h4 id="parameters-and-returns"><a class="header" href="#parameters-and-returns">Parameters and Returns</a></h4>
<pre><code class="language-xml">&lt;param name="parameterName"&gt;Description of the parameter.&lt;/param&gt;
&lt;returns&gt;Description of the return value.&lt;/returns&gt;
</code></pre>
<h4 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h4>
<pre><code class="language-xml">&lt;exception cref="ArgumentNullException"&gt;
Thrown when the parameter is null.
&lt;/exception&gt;
</code></pre>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<pre><code class="language-xml">&lt;example&gt;
This example shows how to use the method:
&lt;code&gt;
var result = MyMethod("input");
Console.WriteLine(result);
&lt;/code&gt;
&lt;/example&gt;
</code></pre>
<h4 id="see-references"><a class="header" href="#see-references">See References</a></h4>
<pre><code class="language-xml">&lt;see cref="RelatedMethod"/&gt;
&lt;seealso cref="AnotherClass"/&gt;
</code></pre>
<h4 id="generic-type-parameters"><a class="header" href="#generic-type-parameters">Generic Type Parameters</a></h4>
<pre><code class="language-xml">&lt;typeparam name="T"&gt;The type parameter.&lt;/typeparam&gt;
&lt;typeparamref name="T"/&gt;
</code></pre>
<h3 id="custom-xml-tags"><a class="header" href="#custom-xml-tags">Custom XML Tags</a></h3>
<p>The parser supports custom XML tags:</p>
<pre><code class="language-xml">&lt;custom attribute="value"&gt;
Custom content with &lt;nested&gt;elements&lt;/nested&gt;.
&lt;/custom&gt;
</code></pre>
<h2 id="xml-documentation-parsing"><a class="header" href="#xml-documentation-parsing">XML Documentation Parsing</a></h2>
<h3 id="xml-element-structure"><a class="header" href="#xml-element-structure">XML Element Structure</a></h3>
<p>The parser represents XML elements with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct XmlElement {
    pub name: Identifier,
    pub attributes: Vec&lt;XmlAttribute&gt;,
    pub children: Vec&lt;XmlNode&gt;,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct XmlAttribute {
    pub name: Identifier,
    pub value: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum XmlNode {
    Element(XmlElement),
    Text(String),
    CData(String),
    Comment(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="xml-documentation-comment"><a class="header" href="#xml-documentation-comment">XML Documentation Comment</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct XmlDocumentationComment {
    pub elements: Vec&lt;XmlNode&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parsing-xml-attributes"><a class="header" href="#parsing-xml-attributes">Parsing XML Attributes</a></h3>
<p>The parser handles XML attributes with various syntaxes:</p>
<pre><code class="language-xml">&lt;param name="value"&gt;Description&lt;/param&gt;
&lt;see cref="MyClass.MyMethod(int, string)"/&gt;
&lt;exception cref="System.ArgumentException"&gt;Error description&lt;/exception&gt;
</code></pre>
<h3 id="xml-content-parsing"><a class="header" href="#xml-content-parsing">XML Content Parsing</a></h3>
<p>The parser processes mixed content:</p>
<pre><code class="language-xml">&lt;summary&gt;
This method processes &lt;paramref name="input"/&gt; and returns
&lt;see cref="ProcessResult"/&gt; containing the result.
&lt;/summary&gt;
</code></pre>
<h2 id="comment-association"><a class="header" href="#comment-association">Comment Association</a></h2>
<h3 id="declaration-comments"><a class="header" href="#declaration-comments">Declaration Comments</a></h3>
<p>Comments are associated with their following declarations:</p>
<pre><code class="language-csharp">/// &lt;summary&gt;Class documentation&lt;/summary&gt;
public class MyClass
{
    /// &lt;summary&gt;Method documentation&lt;/summary&gt;
    public void MyMethod() { }
}
</code></pre>
<h3 id="member-comments"><a class="header" href="#member-comments">Member Comments</a></h3>
<p>Each declaration can have associated documentation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct MethodDeclaration {
    pub documentation: Option&lt;XmlDocumentationComment&gt;,
    // ... other fields
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-xml-features"><a class="header" href="#advanced-xml-features">Advanced XML Features</a></h2>
<h3 id="cdata-sections"><a class="header" href="#cdata-sections">CDATA Sections</a></h3>
<p>The parser handles CDATA sections for literal content:</p>
<pre><code class="language-xml">&lt;example&gt;
&lt;![CDATA[
if (x &lt; y &amp;&amp; y &gt; z)
{
    Console.WriteLine("Complex condition");
}
]]&gt;
&lt;/example&gt;
</code></pre>
<h3 id="nested-xml-elements"><a class="header" href="#nested-xml-elements">Nested XML Elements</a></h3>
<p>Complex nested structures are supported:</p>
<pre><code class="language-xml">&lt;summary&gt;
This method handles &lt;see cref="List{T}"/&gt; where T is
&lt;typeparamref name="T"/&gt; and implements &lt;see cref="IComparable{T}"/&gt;.
&lt;/summary&gt;
</code></pre>
<h3 id="xml-namespaces"><a class="header" href="#xml-namespaces">XML Namespaces</a></h3>
<p>The parser can handle XML namespaces in documentation:</p>
<pre><code class="language-xml">&lt;doc:summary xmlns:doc="http://schemas.microsoft.com/developer/documentation"&gt;
Namespaced documentation content.
&lt;/doc:summary&gt;
</code></pre>
<h2 id="comment-preservation"><a class="header" href="#comment-preservation">Comment Preservation</a></h2>
<h3 id="comment-tokens"><a class="header" href="#comment-tokens">Comment Tokens</a></h3>
<p>Comments are preserved as tokens in the AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CommentToken {
    SingleLine(String),
    MultiLine(String),
    XmlDocumentation(XmlDocumentationComment),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="position-information"><a class="header" href="#position-information">Position Information</a></h3>
<p>Comments maintain position information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PositionedComment {
    pub comment: CommentToken,
    pub line: usize,
    pub column: usize,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="xml-validation"><a class="header" href="#xml-validation">XML Validation</a></h3>
<p>The parser validates XML structure:</p>
<ul>
<li><strong>Well-formed XML</strong>: Proper opening and closing tags</li>
<li><strong>Attribute syntax</strong>: Valid attribute name-value pairs</li>
<li><strong>Nesting rules</strong>: Correct element nesting</li>
<li><strong>Character escaping</strong>: Proper XML character escaping</li>
</ul>
<h3 id="error-recovery-2"><a class="header" href="#error-recovery-2">Error Recovery</a></h3>
<p>When XML is malformed, the parser attempts recovery:</p>
<ul>
<li><strong>Skip malformed elements</strong>: Continue parsing after errors</li>
<li><strong>Preserve content</strong>: Keep as much content as possible</li>
<li><strong>Error reporting</strong>: Provide detailed error locations</li>
</ul>
<h2 id="integration-with-analysis"><a class="header" href="#integration-with-analysis">Integration with Analysis</a></h2>
<h3 id="documentation-analysis"><a class="header" href="#documentation-analysis">Documentation Analysis</a></h3>
<p>Comments are available for analysis tools:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl XmlDocumentationComment {
    pub fn find_elements_by_name(&amp;self, name: &amp;str) -&gt; Vec&lt;&amp;XmlElement&gt; {
        // Find all elements with the given tag name
    }
    
    pub fn get_summary(&amp;self) -&gt; Option&lt;String&gt; {
        // Extract summary text
    }
    
    pub fn get_parameters(&amp;self) -&gt; Vec&lt;(String, String)&gt; {
        // Extract parameter documentation
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="documentation-generation"><a class="header" href="#documentation-generation">Documentation Generation</a></h3>
<p>The parsed XML documentation can be used for:</p>
<ul>
<li><strong>API documentation generation</strong></li>
<li><strong>IntelliSense information</strong></li>
<li><strong>Code analysis and quality checks</strong></li>
<li><strong>Documentation coverage reports</strong></li>
</ul>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="lazy-parsing"><a class="header" href="#lazy-parsing">Lazy Parsing</a></h3>
<p>XML documentation can be parsed lazily when needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub enum DocumentationState {
    Unparsed(String),
    Parsed(XmlDocumentationComment),
    Invalid(String, ParseError),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-optimization"><a class="header" href="#memory-optimization">Memory Optimization</a></h3>
<p>The parser optimizes memory usage by:</p>
<ul>
<li><strong>String interning</strong>: Reusing common XML tag names</li>
<li><strong>Structured storage</strong>: Efficient representation of XML structure</li>
<li><strong>On-demand parsing</strong>: Parse XML only when accessed</li>
</ul>
<p>The comment parsing system ensures that all documentation and comments are preserved and available for analysis, while maintaining the performance characteristics needed for large codebases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preprocessor-directives"><a class="header" href="#preprocessor-directives">Preprocessor Directives</a></h1>
<p>This parser treats preprocessor directives as trivia that can appear at safe boundaries (file start, between members inside namespaces and type bodies). We currently parse only a small subset explicitly and skip the rest.</p>
<h2 id="what-is-parsed-today"><a class="header" href="#what-is-parsed-today">What is parsed today</a></h2>
<ul>
<li><code>#pragma</code> lines are parsed into <code>PreprocessorDirective::Pragma { pragma: String }</code>.</li>
<li><code>#line</code> lines are parsed into <code>PreprocessorDirective::Line { line: String }</code>.</li>
<li>Any other line starting with <code>#</code> is recognized and consumed as
<code>PreprocessorDirective::Unknown { text: String }</code> (the remainder of the line after <code>#</code>).</li>
</ul>
<p>All directive parsers consume the optional trailing newline so the main parser can continue cleanly at the next token.</p>
<h2 id="where-directives-are-skipped"><a class="header" href="#where-directives-are-skipped">Where directives are skipped</a></h2>
<p>Directives are treated as trivia and skipped at these locations:</p>
<p>This skipping is centralized via <code>parser/helpers/directives.rs: skip_preprocessor_directives()</code>.</p>
<pre><code>
### 2. Symbol Definition

#### #define and #undef

```csharp
#define FEATURE_ENABLED
#define VERSION_2_0

#undef OLD_FEATURE
</code></pre>
<h3 id="3-diagnostic-directives"><a class="header" href="#3-diagnostic-directives">3. Diagnostic Directives</a></h3>
<h4 id="warning"><a class="header" href="#warning">#warning</a></h4>
<pre><code class="language-csharp">#warning This code is deprecated and will be removed in the next version
</code></pre>
<h4 id="error"><a class="header" href="#error">#error</a></h4>
<pre><code class="language-csharp">#if UNSUPPORTED_PLATFORM
#error This platform is not supported
#endif
</code></pre>
<h3 id="4-line-directives"><a class="header" href="#4-line-directives">4. Line Directives</a></h3>
<h4 id="line"><a class="header" href="#line">#line</a></h4>
<pre><code class="language-csharp">#line 100 "OriginalFile.cs"
// Following code appears to come from line 100 of OriginalFile.cs

#line default
// Reset to actual file and line numbers

#line hidden
// Hide following lines from debugger
</code></pre>
<h3 id="5-region-directives"><a class="header" href="#5-region-directives">5. Region Directives</a></h3>
<h4 id="region-and-endregion"><a class="header" href="#region-and-endregion">#region and #endregion</a></h4>
<pre><code class="language-csharp">#region Private Methods
private void HelperMethod()
{
    // Implementation
}

private void AnotherHelper()
{
    // Implementation
}
#endregion
</code></pre>
<h3 id="6-pragma-directives"><a class="header" href="#6-pragma-directives">6. Pragma Directives</a></h3>
<h4 id="pragma-warning"><a class="header" href="#pragma-warning">#pragma warning</a></h4>
<pre><code class="language-csharp">#pragma warning disable CS0618
// Use of obsolete members
ObsoleteMethod();
#pragma warning restore CS0618

#pragma warning disable CS0162, CS0168
// Disable multiple warnings
#pragma warning restore CS0162, CS0168
</code></pre>
<h4 id="pragma-checksum"><a class="header" href="#pragma-checksum">#pragma checksum</a></h4>
<pre><code class="language-csharp">#pragma checksum "file.cs" "{406EA660-64CF-4C82-B6F0-42D48172A799}" "checksum_bytes"
</code></pre>
<h3 id="7-nullable-context-directives"><a class="header" href="#7-nullable-context-directives">7. Nullable Context Directives</a></h3>
<h4 id="nullable"><a class="header" href="#nullable">#nullable</a></h4>
<pre><code class="language-csharp">#nullable enable
string? nullable = null;  // Nullable reference types enabled

#nullable disable
string notNullable = null;  // Warning disabled

#nullable restore
// Restore previous nullable context
</code></pre>
<h2 id="preprocessor-expression-evaluation"><a class="header" href="#preprocessor-expression-evaluation">Preprocessor Expression Evaluation</a></h2>
<h3 id="symbols-and-operators"><a class="header" href="#symbols-and-operators">Symbols and Operators</a></h3>
<h4 id="boolean-operators"><a class="header" href="#boolean-operators">Boolean Operators</a></h4>
<pre><code class="language-csharp">#if DEBUG &amp;&amp; !RELEASE           // AND and NOT
#if WINDOWS || LINUX || MACOS   // OR
#if (A &amp;&amp; B) || (C &amp;&amp; D)        // Grouping with parentheses
</code></pre>
<h4 id="equality-operators"><a class="header" href="#equality-operators">Equality Operators</a></h4>
<pre><code class="language-csharp">#if VERSION == "2.0"            // String equality
#if BUILD_NUMBER &gt;= 1000        // Numeric comparison (limited support)
</code></pre>
<h3 id="symbol-resolution"><a class="header" href="#symbol-resolution">Symbol Resolution</a></h3>
<p>Symbols can be defined:</p>
<ol>
<li><strong>Source code</strong>: <code>#define SYMBOL</code></li>
<li><strong>Compiler flags</strong>: <code>/define:SYMBOL</code></li>
<li><strong>Project settings</strong>: <code>&lt;DefineConstants&gt;</code></li>
<li><strong>Environment</strong>: Predefined symbols</li>
</ol>
<h3 id="predefined-symbols"><a class="header" href="#predefined-symbols">Predefined Symbols</a></h3>
<p>Common predefined symbols:</p>
<pre><code class="language-csharp">#if NET5_0_OR_GREATER          // Framework version
#if WINDOWS                    // Platform
#if DEBUG                      // Configuration
#if X64                        // Architecture
</code></pre>
<h2 id="preprocessor-ast-representation"><a class="header" href="#preprocessor-ast-representation">Preprocessor AST Representation</a></h2>
<h3 id="preprocessor-directive-node"><a class="header" href="#preprocessor-directive-node">Preprocessor Directive Node</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum PreprocessorDirective {
    If {
        condition: PreprocessorExpression,
        then_block: Vec&lt;PreprocessorDirective&gt;,
        elif_blocks: Vec&lt;(PreprocessorExpression, Vec&lt;PreprocessorDirective&gt;)&gt;,
        else_block: Option&lt;Vec&lt;PreprocessorDirective&gt;&gt;,
    },
    Define(String),
    Undef(String),
    Warning(String),
    Error(String),
    Line {
        line_number: Option&lt;u32&gt;,
        file_name: Option&lt;String&gt;,
        hidden: bool,
    },
    Region {
        name: String,
        content: Vec&lt;PreprocessorDirective&gt;,
    },
    Pragma {
        directive: String,
        arguments: Vec&lt;String&gt;,
    },
    Nullable(NullableDirective),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preprocessor-expression"><a class="header" href="#preprocessor-expression">Preprocessor Expression</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum PreprocessorExpression {
    Symbol(String),
    Not(Box&lt;PreprocessorExpression&gt;),
    And(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    Or(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    Equal(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    NotEqual(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    Parenthesized(Box&lt;PreprocessorExpression&gt;),
    Literal(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conditional-compilation-processing"><a class="header" href="#conditional-compilation-processing">Conditional Compilation Processing</a></h2>
<h3 id="block-structure"><a class="header" href="#block-structure">Block Structure</a></h3>
<p>Conditional blocks create a tree structure:</p>
<pre><code class="language-csharp">#if CONDITION_A
    // Block A
    #if NESTED_CONDITION
        // Nested block
    #endif
#elif CONDITION_B
    // Block B
#else
    // Default block
#endif
</code></pre>
<h3 id="active-code-determination"><a class="header" href="#active-code-determination">Active Code Determination</a></h3>
<p>The preprocessor determines which code blocks are active:</p>
<ol>
<li><strong>Evaluate conditions</strong>: Process #if expressions</li>
<li><strong>Symbol lookup</strong>: Resolve defined symbols</li>
<li><strong>Block selection</strong>: Choose active code paths</li>
<li><strong>Nested processing</strong>: Handle nested conditionals</li>
</ol>
<h2 id="integration-with-main-parser"><a class="header" href="#integration-with-main-parser">Integration with Main Parser</a></h2>
<h3 id="two-phase-parsing"><a class="header" href="#two-phase-parsing">Two-Phase Parsing</a></h3>
<ol>
<li><strong>Preprocessor Phase</strong>: Process directives and determine active code</li>
<li><strong>Main Parse Phase</strong>: Parse the active code sections</li>
</ol>
<h3 id="conditional-code-exclusion"><a class="header" href="#conditional-code-exclusion">Conditional Code Exclusion</a></h3>
<p>Inactive code blocks are:</p>
<ul>
<li><strong>Excluded from parsing</strong>: Not processed by main parser</li>
<li><strong>Preserved in AST</strong>: Available for analysis tools</li>
<li><strong>Marked as inactive</strong>: Flagged for tooling</li>
</ul>
<h3 id="directive-preservation"><a class="header" href="#directive-preservation">Directive Preservation</a></h3>
<p>All directives are preserved for:</p>
<ul>
<li><strong>Code formatting tools</strong></li>
<li><strong>Refactoring utilities</strong></li>
<li><strong>Documentation generation</strong></li>
<li><strong>Build system integration</strong></li>
</ul>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="directive-validation"><a class="header" href="#directive-validation">Directive Validation</a></h3>
<p>The parser validates:</p>
<ul>
<li><strong>Balanced conditionals</strong>: Every #if has matching #endif</li>
<li><strong>Valid expressions</strong>: Preprocessor expressions are syntactically correct</li>
<li><strong>Symbol definitions</strong>: #define follows naming rules</li>
<li><strong>Pragma syntax</strong>: Pragma directives have valid format</li>
</ul>
<h3 id="error-recovery-3"><a class="header" href="#error-recovery-3">Error Recovery</a></h3>
<p>When encountering malformed directives:</p>
<ul>
<li><strong>Skip invalid directives</strong>: Continue parsing</li>
<li><strong>Report detailed errors</strong>: Show directive location and issue</li>
<li><strong>Maintain structure</strong>: Keep conditional block structure intact</li>
</ul>
<h2 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h2>
<h3 id="nested-regions"><a class="header" href="#nested-regions">Nested Regions</a></h3>
<pre><code class="language-csharp">#region Outer Region
    #region Inner Region
        // Nested region content
    #endregion
#endregion
</code></pre>
<h3 id="complex-pragma-directives"><a class="header" href="#complex-pragma-directives">Complex Pragma Directives</a></h3>
<pre><code class="language-csharp">#pragma warning disable IDE0051 // Remove unused private members
#pragma warning restore IDE0051

#pragma nullable enable warnings
#pragma nullable disable annotations
</code></pre>
<h3 id="source-mapping"><a class="header" href="#source-mapping">Source Mapping</a></h3>
<p>Line directives affect source mapping:</p>
<pre><code class="language-csharp">#line 1 "Generated.cs"
// This appears to come from Generated.cs line 1
var generated = true;
#line default
// Back to actual file location
</code></pre>
<h2 id="usage-in-analysis"><a class="header" href="#usage-in-analysis">Usage in Analysis</a></h2>
<h3 id="conditional-code-analysis"><a class="header" href="#conditional-code-analysis">Conditional Code Analysis</a></h3>
<p>Analysis tools can:</p>
<ul>
<li><strong>Detect dead code</strong>: Find code that's never compiled</li>
<li><strong>Track feature flags</strong>: Analyze conditional compilation usage</li>
<li><strong>Generate reports</strong>: Show compilation configurations</li>
</ul>
<h3 id="symbol-tracking"><a class="header" href="#symbol-tracking">Symbol Tracking</a></h3>
<p>Track symbol definitions and usage:</p>
<ul>
<li><strong>Definition locations</strong>: Where symbols are defined</li>
<li><strong>Usage contexts</strong>: Where symbols are referenced</li>
<li><strong>Scope analysis</strong>: Symbol visibility across files</li>
</ul>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<h3 id="preprocessing-optimization"><a class="header" href="#preprocessing-optimization">Preprocessing Optimization</a></h3>
<ul>
<li><strong>Symbol caching</strong>: Cache symbol resolution results</li>
<li><strong>Lazy evaluation</strong>: Process conditionals only when needed</li>
<li><strong>Memory efficiency</strong>: Minimize directive storage overhead</li>
</ul>
<h3 id="integration-efficiency"><a class="header" href="#integration-efficiency">Integration Efficiency</a></h3>
<ul>
<li><strong>Single-pass processing</strong>: Process directives during parsing</li>
<li><strong>Minimal backtracking</strong>: Avoid reparsing conditional blocks</li>
<li><strong>Incremental updates</strong>: Support for incremental parsing with directive changes</li>
</ul>
<p>The preprocessor directive system ensures that all C# preprocessing features are supported while maintaining the ability to analyze and manipulate code across different compilation configurations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-framework-overview"><a class="header" href="#analysis-framework-overview">Analysis Framework Overview</a></h1>
<p>The BSharp analysis framework provides a comprehensive suite of tools for analyzing C# code at various levels of detail. As part of the BSharp compiler project, it is built on top of the robust parser infrastructure and offers insights into code structure, quality, dependencies, and maintainability. These analysis capabilities support both the compilation process and standalone code analysis tools.</p>
<h2 id="analysis-architecture"><a class="header" href="#analysis-architecture">Analysis Architecture</a></h2>
<p>The analysis framework is organized into specialized modules:</p>
<pre><code>src/analysis/
├── control_flow/     # Control flow analysis
├── dependencies/     # Dependency tracking and analysis
├── metrics/          # Code metrics collection
├── naming/           # Naming convention analysis
├── navigation/       # Advanced AST navigation
├── quality/          # Code quality assessment
└── types/           # Type system analysis
</code></pre>
<h2 id="analysis-capabilities"><a class="header" href="#analysis-capabilities">Analysis Capabilities</a></h2>
<h3 id="control-flow-analysis"><a class="header" href="#control-flow-analysis">Control Flow Analysis</a></h3>
<ul>
<li><strong>Path Analysis</strong>: Identify all possible execution paths through methods</li>
<li><strong>Reachability</strong>: Detect unreachable code sections</li>
<li><strong>Complexity Metrics</strong>: Calculate cyclomatic complexity and other flow-based metrics</li>
<li><strong>Dead Code Detection</strong>: Find code that can never be executed</li>
</ul>
<h3 id="dependency-analysis"><a class="header" href="#dependency-analysis">Dependency Analysis</a></h3>
<ul>
<li><strong>Type Dependencies</strong>: Track relationships between types</li>
<li><strong>Assembly Dependencies</strong>: Analyze external assembly usage</li>
<li><strong>Circular Dependencies</strong>: Detect problematic dependency cycles</li>
<li><strong>Coupling Metrics</strong>: Measure afferent and efferent coupling</li>
</ul>
<h3 id="code-metrics"><a class="header" href="#code-metrics">Code Metrics</a></h3>
<p>Comprehensive metrics collection across multiple dimensions:</p>
<h4 id="complexity-metrics"><a class="header" href="#complexity-metrics">Complexity Metrics</a></h4>
<ul>
<li>Cyclomatic Complexity</li>
<li>Cognitive Complexity</li>
<li>Nesting Depth</li>
<li>Method Length</li>
</ul>
<h4 id="size-metrics"><a class="header" href="#size-metrics">Size Metrics</a></h4>
<ul>
<li>Lines of Code (LOC)</li>
<li>Source Lines of Code (SLOC)</li>
<li>Comment Lines</li>
<li>Method Count per Class</li>
</ul>
<h4 id="maintainability-metrics"><a class="header" href="#maintainability-metrics">Maintainability Metrics</a></h4>
<ul>
<li>Maintainability Index</li>
<li>Technical Debt Indicators</li>
<li>Code Duplication Detection</li>
<li>Halstead Metrics</li>
</ul>
<h3 id="quality-analysis"><a class="header" href="#quality-analysis">Quality Analysis</a></h3>
<ul>
<li><strong>Code Smells</strong>: Detect common anti-patterns</li>
<li><strong>Best Practices</strong>: Validate adherence to coding standards</li>
<li><strong>Performance Issues</strong>: Identify potential performance problems</li>
<li><strong>Security Concerns</strong>: Basic security-related code analysis</li>
</ul>
<h3 id="type-analysis"><a class="header" href="#type-analysis">Type Analysis</a></h3>
<ul>
<li><strong>Type Usage</strong>: Track how types are used throughout the codebase</li>
<li><strong>Generic Analysis</strong>: Analyze generic type usage patterns</li>
<li><strong>Inheritance Hierarchies</strong>: Map class and interface hierarchies</li>
<li><strong>Interface Compliance</strong>: Validate interface implementations</li>
</ul>
<h2 id="analysis-workflow"><a class="header" href="#analysis-workflow">Analysis Workflow</a></h2>
<h3 id="1-ast-preparation"><a class="header" href="#1-ast-preparation">1. AST Preparation</a></h3>
<p>All analysis begins with a parsed AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parser = Parser::new();
let compilation_unit = parser.parse(source_code)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-analysis-selection"><a class="header" href="#2-analysis-selection">2. Analysis Selection</a></h3>
<p>Choose specific analyzers based on requirements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Individual analyzers
let metrics_analyzer = MetricsAnalyzer::new();
let dependency_analyzer = DependencyAnalyzer::new();

// Composite analysis
let quality_analyzer = QualityAnalyzer::new()
    .with_metrics()
    .with_dependencies()
    .with_control_flow();
<span class="boring">}</span></code></pre></pre>
<h3 id="3-analysis-execution"><a class="header" href="#3-analysis-execution">3. Analysis Execution</a></h3>
<p>Run analysis on the AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let metrics = metrics_analyzer.analyze(&amp;compilation_unit);
let dependencies = dependency_analyzer.analyze(&amp;compilation_unit);
let quality_report = quality_analyzer.analyze(&amp;compilation_unit);
<span class="boring">}</span></code></pre></pre>
<h3 id="4-results-processing"><a class="header" href="#4-results-processing">4. Results Processing</a></h3>
<p>Analysis results are structured for easy consumption:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Metrics results
println!("Cyclomatic Complexity: {}", metrics.cyclomatic_complexity);
println!("Lines of Code: {}", metrics.lines_of_code);

// Quality assessment
for issue in quality_report.issues {
    println!("Issue: {} at line {}", issue.message, issue.line_number);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="analysis-traits-and-interfaces"><a class="header" href="#analysis-traits-and-interfaces">Analysis Traits and Interfaces</a></h2>
<h3 id="core-analysis-trait"><a class="header" href="#core-analysis-trait">Core Analysis Trait</a></h3>
<p>All analyzers implement a common interface:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Analyzer&lt;T&gt; {
    type Output;
    
    fn analyze(&amp;self, input: &amp;T) -&gt; Self::Output;
    fn name(&amp;self) -&gt; &amp;'static str;
    fn version(&amp;self) -&gt; &amp;'static str;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="specialized-analysis-traits"><a class="header" href="#specialized-analysis-traits">Specialized Analysis Traits</a></h3>
<p>Domain-specific traits for different analysis types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MetricsAnalyzer {
    fn calculate_complexity(&amp;self, method: &amp;MethodDeclaration) -&gt; ComplexityMetrics;
    fn calculate_size_metrics(&amp;self, class: &amp;ClassDeclaration) -&gt; SizeMetrics;
    fn calculate_maintainability(&amp;self, compilation_unit: &amp;CompilationUnit) -&gt; MaintainabilityMetrics;
}

pub trait QualityAnalyzer {
    fn detect_code_smells(&amp;self, ast: &amp;CompilationUnit) -&gt; Vec&lt;CodeSmell&gt;;
    fn validate_naming_conventions(&amp;self, ast: &amp;CompilationUnit) -&gt; Vec&lt;NamingViolation&gt;;
    fn check_best_practices(&amp;self, ast: &amp;CompilationUnit) -&gt; Vec&lt;BestPracticeViolation&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-and-customization"><a class="header" href="#configuration-and-customization">Configuration and Customization</a></h2>
<h3 id="analysis-configuration"><a class="header" href="#analysis-configuration">Analysis Configuration</a></h3>
<p>Analyzers can be configured for different scenarios:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = AnalysisConfig {
    max_cyclomatic_complexity: 10,
    max_method_length: 50,
    enforce_naming_conventions: true,
    detect_code_smells: true,
    // ... other configuration options
};

let analyzer = MetricsAnalyzer::with_config(config);
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-rules"><a class="header" href="#custom-rules">Custom Rules</a></h3>
<p>Extend analysis with custom rules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let custom_analyzer = QualityAnalyzer::new()
    .add_rule(CustomRule::new("no-goto-statements"))
    .add_rule(CustomRule::new("max-parameters", 5))
    .add_rule(CustomRule::new("prefer-composition"));
<span class="boring">}</span></code></pre></pre>
<h3 id="reporting-options"><a class="header" href="#reporting-options">Reporting Options</a></h3>
<p>Flexible reporting formats:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// JSON output
let json_report = analyzer.analyze(&amp;ast).to_json();

// XML output
let xml_report = analyzer.analyze(&amp;ast).to_xml();

// Custom format
let custom_report = analyzer.analyze(&amp;ast).format_with(custom_formatter);
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-points"><a class="header" href="#integration-points">Integration Points</a></h2>
<h3 id="cli-integration"><a class="header" href="#cli-integration">CLI Integration</a></h3>
<p>Analysis capabilities are exposed through the CLI:</p>
<pre><code class="language-bash"># Basic metrics
bsharp analyze metrics input.cs

# Quality analysis
bsharp analyze quality input.cs --config quality-config.json

# Dependency analysis
bsharp analyze dependencies input.cs --output dependencies.json
</code></pre>
<h3 id="programmatic-usage"><a class="header" href="#programmatic-usage">Programmatic Usage</a></h3>
<p>Direct integration in other tools:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::{MetricsAnalyzer, QualityAnalyzer};

fn analyze_project(files: Vec&lt;&amp;str&gt;) -&gt; AnalysisResults {
    let mut results = AnalysisResults::new();
    
    for file in files {
        let ast = parse_file(file)?;
        let metrics = MetricsAnalyzer::new().analyze(&amp;ast);
        let quality = QualityAnalyzer::new().analyze(&amp;ast);
        
        results.add_file_analysis(file, metrics, quality);
    }
    
    results
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="analysis-performance"><a class="header" href="#analysis-performance">Analysis Performance</a></h3>
<ul>
<li><strong>Incremental Analysis</strong>: Support for analyzing only changed parts</li>
<li><strong>Parallel Processing</strong>: Multi-threaded analysis for large codebases</li>
<li><strong>Memory Efficiency</strong>: Minimal memory overhead during analysis</li>
<li><strong>Caching</strong>: Results caching for repeated analysis</li>
</ul>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<p>The framework scales from single files to large enterprise codebases:</p>
<ul>
<li>Single file analysis: Sub-second performance</li>
<li>Medium projects (100+ files): Seconds to minutes</li>
<li>Large codebases (1000+ files): Minutes with parallel processing</li>
</ul>
<p>This analysis framework provides the foundation for building sophisticated code quality tools, IDE integrations, and automated code review systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-pipeline"><a class="header" href="#analysis-pipeline">Analysis Pipeline</a></h1>
<p>This document describes the analysis pipeline architecture, artifacts, rulesets, configuration toggles, and determinism guarantees in the B# analyzer.</p>
<h2 id="phases"><a class="header" href="#phases">Phases</a></h2>
<p>The pipeline runs in deterministic phases (see <code>src/analysis/framework/pipeline.rs</code>):</p>
<ul>
<li><strong>Index</strong>
<ul>
<li>Runs early passes like <code>IndexingPass</code> to populate core artifacts (<code>SymbolIndex</code>, <code>NameIndex</code>, <code>FqnMap</code>).</li>
</ul>
</li>
<li><strong>Local Rules</strong>
<ul>
<li>Single AST traversal via <code>AstWalker</code> that executes local rules and metrics collection.</li>
<li>Metrics are collected by <code>MetricsVisitor</code> into <code>AstAnalysis</code>.</li>
</ul>
</li>
<li><strong>Global</strong>
<ul>
<li>Passes that aggregate information across the file (or project) after initial indexing.</li>
</ul>
</li>
<li><strong>Semantic</strong>
<ul>
<li>Rules and passes that require previously built artifacts (e.g., control flow, dependencies).</li>
</ul>
</li>
<li><strong>Reporting</strong>
<ul>
<li>Finalization phase that can synthesize report artifacts.</li>
</ul>
</li>
</ul>
<p>Each phase is explicitly selected in <code>AnalyzerPipeline::run_for_file()</code> using <code>Phase</code> discriminants. Pass and ruleset registration is driven by <code>AnalyzerRegistry</code>.</p>
<h2 id="artifacts"><a class="header" href="#artifacts">Artifacts</a></h2>
<p>Artifacts are stored in the per-file <code>AnalysisSession.artifacts</code> and summarized into an <code>AnalysisReport</code>:</p>
<ul>
<li><strong>Symbols</strong> (<code>src/analysis/artifacts/symbols.rs</code>)
<ul>
<li><code>SymbolIndex</code> (by id and name), <code>NameIndex</code> (name frequencies), <code>FqnMap</code> (local name → FQNs).</li>
</ul>
</li>
<li><strong>Control Flow</strong> (<code>src/analysis/artifacts/cfg.rs</code>)
<ul>
<li><code>ControlFlowIndex</code> keyed per method; summarized to <code>CfgSummary</code> with total methods and smell counts.</li>
</ul>
</li>
<li><strong>Dependencies</strong> (<code>src/analysis/artifacts/dependencies.rs</code>)
<ul>
<li>Graph keyed by symbols; summarized to node/edge counts.</li>
</ul>
</li>
<li><strong>Metrics</strong> (<code>src/analysis/artifacts/metrics.rs</code> → <code>AstAnalysis</code>)
<ul>
<li>Basic metrics gathered during the local traversal.</li>
</ul>
</li>
</ul>
<p>Artifacts are optional in the final report; missing artifacts simply result in <code>None</code> summaries.</p>
<h2 id="rulesets-and-passes"><a class="header" href="#rulesets-and-passes">Rulesets and Passes</a></h2>
<p>Rules implement the <code>Rule</code> trait and are grouped into logical rulesets. Passes implement <code>AnalyzerPass</code> and declare a <code>Phase</code>:</p>
<ul>
<li>Rulesets are separated into Local vs. Semantic groups and executed during the respective phases.</li>
<li>Passes can be toggled individually by id.</li>
<li>The registry is created with <code>AnalyzerRegistry::from_config(&amp;AnalysisConfig)</code> to honor config toggles.</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p><code>AnalysisConfig</code> (<code>src/analysis/context.rs</code>) controls thresholds and toggles:</p>
<ul>
<li><strong>Control flow thresholds</strong>
<ul>
<li><code>cf_high_complexity_threshold</code> (default 10)</li>
<li><code>cf_deep_nesting_threshold</code> (default 4)</li>
</ul>
</li>
<li><strong>Toggles</strong>
<ul>
<li><code>enable_rulesets: HashMap&lt;String, bool&gt;</code></li>
<li><code>enable_passes: HashMap&lt;String, bool&gt;</code></li>
<li><code>rule_severities: HashMap&lt;String, DiagnosticSeverity&gt;</code></li>
</ul>
</li>
<li><strong>Workspace filters</strong>
<ul>
<li><code>workspace.follow_refs: bool</code></li>
<li><code>workspace.include: Vec&lt;String&gt;</code> (glob patterns)</li>
<li><code>workspace.exclude: Vec&lt;String&gt;</code> (glob patterns)</li>
</ul>
</li>
</ul>
<p>CLI maps flags to these fields in <code>src/cli/commands/analyze.rs</code> and supports TOML/JSON config files.</p>
<h2 id="workspace-analysis-and-determinism"><a class="header" href="#workspace-analysis-and-determinism">Workspace Analysis and Determinism</a></h2>
<p><code>AnalyzerPipeline::run_workspace()</code> and <code>run_workspace_with_config()</code>:</p>
<ul>
<li>Discover files deterministically by sorting absolute paths and deduping.</li>
<li>Analyze each file independently, then merge artifacts into a single <code>AnalysisReport</code>.</li>
<li>Diagnostics are sorted by file, line, column, then diagnostic code for stable output.</li>
<li>Workspace loader warnings/errors are merged into <code>workspace_warnings</code> (sorted, deduped).</li>
<li>When the <code>parallel_analysis</code> feature is enabled, files are analyzed in parallel but merged deterministically in path order.</li>
</ul>
<h2 id="report-schema"><a class="header" href="#report-schema">Report Schema</a></h2>
<p><code>AnalysisReport</code> (<code>src/analysis/report/mod.rs</code>) includes:</p>
<ul>
<li><code>schema_version: u32</code> (currently 1)</li>
<li><code>diagnostics: DiagnosticCollection</code></li>
<li><code>metrics: Option&lt;AstAnalysis&gt;</code></li>
<li><code>cfg: Option&lt;CfgSummary&gt;</code></li>
<li><code>deps: Option&lt;DependencySummary&gt;</code></li>
<li><code>workspace_warnings: Vec&lt;String&gt;</code></li>
<li><code>workspace_errors: Vec&lt;String&gt;</code> (reserved for future use)</li>
</ul>
<p>The JSON shape is intentionally stable; tests use snapshots with path normalization to ensure cross-platform consistency.</p>
<h2 id="testing-guidance"><a class="header" href="#testing-guidance">Testing Guidance</a></h2>
<ul>
<li>Prefer deterministic fixtures under <code>tests/fixtures/</code>.</li>
<li>Normalize absolute paths in snapshots (see <code>tests/integration/workspace_analysis_snapshot.rs</code>).</li>
<li>For workspace filtering, use <code>run_workspace_with_config()</code> with <code>include</code>/<code>exclude</code> globs and snapshot the resulting report.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-traversal-guide"><a class="header" href="#analysis-traversal-guide">Analysis Traversal Guide</a></h1>
<p>This guide explains how to traverse BSharp AST statements and expressions in analysis passes.</p>
<ul>
<li>Source files:
<ul>
<li><code>src/analysis/visitors.rs</code></li>
<li><code>src/analysis/passes/*</code></li>
</ul>
</li>
</ul>
<h2 id="statement-traversal"><a class="header" href="#statement-traversal">Statement traversal</a></h2>
<p>Use <code>walk_statements()</code> to visit every <code>Statement</code> node in depth-first order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::visitors::walk_statements;
use bsharp::syntax::nodes::statements::statement::Statement;

fn count_returns(stmt: &amp;Statement) -&gt; usize {
    let mut count = 0;
    walk_statements(stmt, &amp;mut |s| {
        if matches!(s, Statement::Return(_)) { count += 1; }
    });
    count
}
<span class="boring">}</span></code></pre></pre>
<p><code>walk_statements()</code> currently descends into:</p>
<ul>
<li>If (then and else), For, ForEach, While, DoWhile</li>
<li>Using (optional body)</li>
<li>Switch (all sections' statements)</li>
<li>Try (try block, each catch block, finally block)</li>
<li>Block (all nested statements)</li>
</ul>
<p>Add additional variants as needed when the language surface expands.</p>
<h2 id="expression-traversal"><a class="header" href="#expression-traversal">Expression traversal</a></h2>
<p>Use <code>walk_expressions()</code> to visit every <code>Expression</code> node in depth-first order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::visitors::walk_expressions;
use bsharp::syntax::nodes::expressions::expression::Expression;

fn has_await(expr: &amp;Expression) -&gt; bool {
    let mut found = false;
    walk_expressions(expr, &amp;mut |e| {
        if matches!(e, Expression::Await(_)) { found = true; }
    });
    found
}
<span class="boring">}</span></code></pre></pre>
<p><code>walk_expressions()</code> descends into common expression shapes:</p>
<ul>
<li>Composite: Tuple, AnonymousObject, Collection, New (arguments, initializer)</li>
<li>Indexing / Index</li>
<li>Conditional (condition, then, else)</li>
<li>MemberAccess, NullConditional, Invocation</li>
<li>Assignment (left, right)</li>
<li>Unary/PostfixUnary, Binary</li>
<li>Lambda (expression body) and switch-like constructs (SwitchExpression)</li>
<li>Patterns in <code>is</code> and query expressions</li>
</ul>
<p>Like statement traversal, extend the walker conservatively when new expression kinds are added.</p>
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting it together</a></h2>
<p>When analyzing methods, you typically:</p>
<ul>
<li>Parse the compilation unit and build the analysis session.</li>
<li>For each method body (a <code>Statement::Block</code>), compute metrics by walking statements and expressions.</li>
</ul>
<p>Example (from <code>ControlFlowPass</code> pattern):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::artifacts::cfg::{ControlFlowIndex, MethodControlFlowStats};
use bsharp::syntax::nodes::statements::statement::Statement;

fn stats_for_method(body: Option&lt;&amp;Statement&gt;) -&gt; MethodControlFlowStats {
    let complexity = match body { Some(s) =&gt; 1 + decision_points(s), None =&gt; 1 };
    let max_nesting = calc_max_nesting(body, 0);
    let exit_points = count_exit_points(body);
    let statement_count = count_statements(body);
    MethodControlFlowStats { complexity, max_nesting, exit_points, statement_count }
}
<span class="boring">}</span></code></pre></pre>
<p>See <code>src/analysis/passes/control_flow.rs</code> for concrete implementations of <code>decision_points</code>, <code>calc_max_nesting</code>, and exit/statement counters that leverage the structure of <code>Statement</code>.</p>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ul>
<li>Keep walkers side-effect free; accumulate results in closures.</li>
<li>Prefer small, focused passes that use the walkers rather than embedding traversal in each pass.</li>
<li>If a construct is not being traversed, add it to the walker first to avoid duplicated traversal logic.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-analysis-1"><a class="header" href="#control-flow-analysis-1">Control Flow Analysis</a></h1>
<p>The control flow analysis system analyzes method control flow to calculate complexity metrics, detect control flow smells, and identify potential issues.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>Location:</strong> <code>src/analysis/passes/control_flow.rs</code>, <code>src/analysis/artifacts/cfg.rs</code></p>
<p>Control flow analysis provides:</p>
<ul>
<li>Cyclomatic complexity calculation</li>
<li>Maximum nesting depth tracking</li>
<li>Exit point counting</li>
<li>Statement counting</li>
<li>Control flow smell detection</li>
</ul>
<hr />
<h2 id="control-flow-metrics"><a class="header" href="#control-flow-metrics">Control Flow Metrics</a></h2>
<h3 id="cyclomatic-complexity"><a class="header" href="#cyclomatic-complexity">Cyclomatic Complexity</a></h3>
<p><strong>Definition:</strong> Number of linearly independent paths through a method</p>
<p><strong>Calculation:</strong> <code>CC = 1 + number of decision points</code></p>
<p><strong>Decision Points:</strong></p>
<ul>
<li><code>if</code> statements</li>
<li><code>case</code> labels in <code>switch</code></li>
<li>Loop statements (<code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>)</li>
<li><code>catch</code> clauses</li>
<li>Logical operators (<code>&amp;&amp;</code>, <code>||</code>) in conditions</li>
<li>Ternary operators (<code>?:</code>)</li>
<li>Null-coalescing operators (<code>??</code>)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {  // CC = 1 (base)
    if (order == null) {                 // +1 = 2
        throw new ArgumentNullException();
    }
    
    if (order.IsValid) {                 // +1 = 3
        if (order.Amount &gt; 1000) {       // +1 = 4
            ApplyDiscount(order);
        }
        SaveOrder(order);
    }
}
// Total CC = 4
</code></pre>
<h3 id="maximum-nesting-depth"><a class="header" href="#maximum-nesting-depth">Maximum Nesting Depth</a></h3>
<p><strong>Definition:</strong> Deepest level of nested control structures</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Example() {
    if (condition1) {              // Depth 1
        while (condition2) {       // Depth 2
            if (condition3) {      // Depth 3
                DoSomething();
            }
        }
    }
}
// Max Nesting Depth = 3
</code></pre>
<h3 id="exit-points"><a class="header" href="#exit-points">Exit Points</a></h3>
<p><strong>Definition:</strong> Number of points where method can return</p>
<p><strong>Counted:</strong></p>
<ul>
<li><code>return</code> statements</li>
<li><code>throw</code> statements</li>
<li>End of void method</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public int Calculate(int x) {
    if (x &lt; 0) {
        return -1;        // Exit point 1
    }
    if (x == 0) {
        return 0;         // Exit point 2
    }
    return x * 2;         // Exit point 3
}
// Total Exit Points = 3
</code></pre>
<h3 id="statement-count"><a class="header" href="#statement-count">Statement Count</a></h3>
<p><strong>Definition:</strong> Total number of statements in method body</p>
<p>Includes all statement types:</p>
<ul>
<li>Expression statements</li>
<li>Declaration statements</li>
<li>Control flow statements</li>
<li>Jump statements</li>
</ul>
<hr />
<h2 id="control-flow-artifacts"><a class="header" href="#control-flow-artifacts">Control Flow Artifacts</a></h2>
<h3 id="methodcontrolflowstats"><a class="header" href="#methodcontrolflowstats">MethodControlFlowStats</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MethodControlFlowStats {
    pub complexity: usize,
    pub max_nesting: usize,
    pub exit_points: usize,
    pub statement_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="controlflowindex"><a class="header" href="#controlflowindex">ControlFlowIndex</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ControlFlowIndex {
    // Method identifier -&gt; stats
    methods: HashMap&lt;String, MethodControlFlowStats&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cfgsummary"><a class="header" href="#cfgsummary">CfgSummary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CfgSummary {
    pub total_methods: usize,
    pub high_complexity_count: usize,
    pub deep_nesting_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="control-flow-smells"><a class="header" href="#control-flow-smells">Control Flow Smells</a></h2>
<h3 id="high-complexity"><a class="header" href="#high-complexity">High Complexity</a></h3>
<p><strong>Threshold:</strong> Configurable (default: 10)</p>
<p><strong>Detection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if stats.complexity &gt; config.cf_high_complexity_threshold {
    session.diagnostics.add(
        DiagnosticCode::HighComplexity,
        format!("Method complexity {} exceeds threshold {}", 
               stats.complexity, threshold)
    );
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[CF002]: High cyclomatic complexity
  --&gt; src/OrderProcessor.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ complexity = 15 (threshold: 10)
   |
   = help: Consider breaking this method into smaller methods
</code></pre>
<h3 id="deep-nesting"><a class="header" href="#deep-nesting">Deep Nesting</a></h3>
<p><strong>Threshold:</strong> Configurable (default: 4)</p>
<p><strong>Detection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if stats.max_nesting &gt; config.cf_deep_nesting_threshold {
    session.diagnostics.add(
        DiagnosticCode::DeepNesting,
        format!("Maximum nesting depth {} exceeds threshold {}", 
               stats.max_nesting, threshold)
    );
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[CF003]: Deep nesting detected
  --&gt; src/Validator.cs:15:9
   |
15 |         if (condition1) {
   |         ^^ nesting depth = 5 (threshold: 4)
   |
   = help: Consider extracting nested logic into separate methods
</code></pre>
<hr />
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="analysis-pass"><a class="header" href="#analysis-pass">Analysis Pass</a></h3>
<p><strong>Location:</strong> <code>src/analysis/passes/control_flow.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ControlFlowPass;

impl AnalyzerPass for ControlFlowPass {
    fn id(&amp;self) -&gt; &amp;'static str { "control_flow" }
    fn phase(&amp;self) -&gt; Phase { Phase::Semantic }
    
    fn run(&amp;self, cu: &amp;CompilationUnit, session: &amp;mut AnalysisSession) {
        let mut index = ControlFlowIndex::new();
        
        // Analyze all methods in compilation unit
        for decl in &amp;cu.declarations {
            analyze_declaration(decl, &amp;mut index, session);
        }
        
        session.artifacts.cfg = Some(index);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="method-analysis"><a class="header" href="#method-analysis">Method Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_method(
    method: &amp;MethodDeclaration,
    index: &amp;mut ControlFlowIndex,
    session: &amp;mut AnalysisSession
) {
    let stats = calculate_stats(method.body.as_ref());
    
    // Check thresholds
    if stats.complexity &gt; session.config.cf_high_complexity_threshold {
        session.diagnostics.add(/* high complexity diagnostic */);
    }
    
    if stats.max_nesting &gt; session.config.cf_deep_nesting_threshold {
        session.diagnostics.add(/* deep nesting diagnostic */);
    }
    
    // Store in index
    index.add_method(&amp;method.identifier.name, stats);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stats-calculation"><a class="header" href="#stats-calculation">Stats Calculation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_stats(body: Option&lt;&amp;Statement&gt;) -&gt; MethodControlFlowStats {
    let complexity = match body {
        Some(stmt) =&gt; 1 + count_decision_points(stmt),
        None =&gt; 1,
    };
    
    let max_nesting = calculate_max_nesting(body, 0);
    let exit_points = count_exit_points(body);
    let statement_count = count_statements(body);
    
    MethodControlFlowStats {
        complexity,
        max_nesting,
        exit_points,
        statement_count,
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="thresholds"><a class="header" href="#thresholds">Thresholds</a></h3>
<pre><code class="language-toml">[analysis.control_flow]
cf_high_complexity_threshold = 10
cf_deep_nesting_threshold = 4
</code></pre>
<h3 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h3>
<pre><code class="language-bash"># Analyze with custom thresholds
bsharp analyze MyProject.csproj --config .bsharp.toml

# Enable control flow pass
bsharp analyze MyProject.csproj --enable-pass control_flow
</code></pre>
<hr />
<h2 id="integration-with-pipeline"><a class="header" href="#integration-with-pipeline">Integration with Pipeline</a></h2>
<h3 id="phase-semantic"><a class="header" href="#phase-semantic">Phase: Semantic</a></h3>
<p>Control flow analysis runs in the <strong>Semantic</strong> phase after symbol indexing:</p>
<pre><code>Phase::Index    -&gt; Build SymbolIndex
Phase::Local    -&gt; Collect metrics
Phase::Semantic -&gt; Control flow analysis
</code></pre>
<h3 id="artifacts-1"><a class="header" href="#artifacts-1">Artifacts</a></h3>
<p>Results stored in <code>AnalysisSession</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>session.artifacts.cfg = Some(ControlFlowIndex { ... });
<span class="boring">}</span></code></pre></pre>
<p>Summarized in <code>AnalysisReport</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>report.cfg = Some(CfgSummary {
    total_methods: 87,
    high_complexity_count: 5,
    deep_nesting_count: 3,
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - Pipeline integration</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Related metrics</li>
<li><a href="analysis/./quality.html">Code Quality</a> - Quality rules</li>
<li><a href="analysis/./traversal-guide.html">Traversal Guide</a> - AST traversal</li>
</ul>
<hr />
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/analysis/passes/control_flow.rs</code></li>
<li><strong>Artifacts:</strong> <code>src/analysis/artifacts/cfg.rs</code></li>
<li><strong>Tests:</strong> <code>tests/analysis/types/basic_tests.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-analysis-1"><a class="header" href="#dependency-analysis-1">Dependency Analysis</a></h1>
<p>The dependency analysis system tracks relationships between types, methods, and other symbols in C# code to identify coupling, circular dependencies, and architectural issues.</p>
<hr />
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><strong>Location:</strong> <code>src/analysis/artifacts/dependencies.rs</code></p>
<p>The dependency analysis builds a directed graph of symbol relationships, where:</p>
<ul>
<li><strong>Nodes</strong> represent symbols (classes, interfaces, methods, etc.)</li>
<li><strong>Edges</strong> represent dependencies (inheritance, method calls, field types, etc.)</li>
</ul>
<hr />
<h2 id="dependency-types"><a class="header" href="#dependency-types">Dependency Types</a></h2>
<h3 id="type-dependencies"><a class="header" href="#type-dependencies">Type Dependencies</a></h3>
<p><strong>Inheritance:</strong></p>
<pre><code class="language-csharp">public class Derived : Base { }  // Derived depends on Base
</code></pre>
<p><strong>Interface Implementation:</strong></p>
<pre><code class="language-csharp">public class MyClass : IInterface { }  // MyClass depends on IInterface
</code></pre>
<p><strong>Field Types:</strong></p>
<pre><code class="language-csharp">public class Container {
    private Helper helper;  // Container depends on Helper
}
</code></pre>
<p><strong>Method Parameters and Return Types:</strong></p>
<pre><code class="language-csharp">public Response Process(Request req) { }  // Process depends on Request and Response
</code></pre>
<h3 id="member-dependencies"><a class="header" href="#member-dependencies">Member Dependencies</a></h3>
<p><strong>Method Calls:</strong></p>
<pre><code class="language-csharp">public void Caller() {
    Helper.DoSomething();  // Caller depends on Helper.DoSomething
}
</code></pre>
<p><strong>Property Access:</strong></p>
<pre><code class="language-csharp">var value = obj.Property;  // Depends on Property
</code></pre>
<p><strong>Constructor Calls:</strong></p>
<pre><code class="language-csharp">var instance = new MyClass();  // Depends on MyClass constructor
</code></pre>
<hr />
<h2 id="dependency-graph-structure"><a class="header" href="#dependency-graph-structure">Dependency Graph Structure</a></h2>
<h3 id="dependencygraph"><a class="header" href="#dependencygraph">DependencyGraph</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DependencyGraph {
    // Symbol ID -&gt; list of symbols it depends on
    dependencies: HashMap&lt;SymbolId, Vec&lt;SymbolId&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p><strong>Adding Dependencies:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.add_dependency(from_symbol, to_symbol);
<span class="boring">}</span></code></pre></pre>
<p><strong>Querying Dependencies:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Direct dependencies
let deps = graph.get_dependencies(symbol_id);

// Transitive dependencies
let all_deps = graph.get_transitive_dependencies(symbol_id);

// Reverse dependencies (who depends on this symbol)
let dependents = graph.get_dependents(symbol_id);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="circular-dependency-detection"><a class="header" href="#circular-dependency-detection">Circular Dependency Detection</a></h2>
<h3 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h3>
<p>The analysis uses depth-first search to detect cycles in the dependency graph:</p>
<ol>
<li>Start from each symbol</li>
<li>Traverse dependencies depth-first</li>
<li>Track visited nodes in current path</li>
<li>If we revisit a node in current path, cycle detected</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-csharp">public class A {
    private B b;  // A depends on B
}

public class B {
    private C c;  // B depends on C
}

public class C {
    private A a;  // C depends on A -&gt; CYCLE: A -&gt; B -&gt; C -&gt; A
}
</code></pre>
<p><strong>Detection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cycles = graph.find_cycles();
for cycle in cycles {
    // Report diagnostic for circular dependency
    session.diagnostics.add(
        DiagnosticCode::CircularDependency,
        format!("Circular dependency detected: {:?}", cycle)
    );
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="coupling-metrics"><a class="header" href="#coupling-metrics">Coupling Metrics</a></h2>
<h3 id="afferent-coupling-ca"><a class="header" href="#afferent-coupling-ca">Afferent Coupling (Ca)</a></h3>
<p><strong>Definition:</strong> Number of types that depend on this type (incoming dependencies)</p>
<p><strong>Interpretation:</strong></p>
<ul>
<li>High Ca = Many types depend on this type (responsibility)</li>
<li>Type is stable and hard to change</li>
</ul>
<h3 id="efferent-coupling-ce"><a class="header" href="#efferent-coupling-ce">Efferent Coupling (Ce)</a></h3>
<p><strong>Definition:</strong> Number of types this type depends on (outgoing dependencies)</p>
<p><strong>Interpretation:</strong></p>
<ul>
<li>High Ce = This type depends on many others</li>
<li>Type is unstable and sensitive to changes</li>
</ul>
<h3 id="instability-i"><a class="header" href="#instability-i">Instability (I)</a></h3>
<p><strong>Formula:</strong> <code>I = Ce / (Ca + Ce)</code></p>
<p><strong>Range:</strong> 0.0 to 1.0</p>
<ul>
<li><strong>0.0</strong> = Maximally stable (only incoming dependencies)</li>
<li><strong>1.0</strong> = Maximally unstable (only outgoing dependencies)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ca = graph.afferent_coupling(symbol_id);
let ce = graph.efferent_coupling(symbol_id);
let instability = ce as f64 / (ca + ce) as f64;

if instability &gt; 0.8 {
    // Highly unstable type - consider refactoring
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="dependency-summary"><a class="header" href="#dependency-summary">Dependency Summary</a></h2>
<h3 id="dependencysummary"><a class="header" href="#dependencysummary">DependencySummary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DependencySummary {
    pub total_nodes: usize,
    pub total_edges: usize,
    pub circular_dependencies: usize,
    pub max_depth: usize,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Generated by:</strong> <code>DependencyGraph::summarize()</code></p>
<p><strong>Included in:</strong> <code>AnalysisReport</code></p>
<hr />
<h2 id="usage-in-analysis-pipeline"><a class="header" href="#usage-in-analysis-pipeline">Usage in Analysis Pipeline</a></h2>
<h3 id="phase-global"><a class="header" href="#phase-global">Phase: Global</a></h3>
<p>Dependency analysis runs in the <strong>Global</strong> phase after symbol indexing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In AnalyzerPipeline
Phase::Index   -&gt; Build SymbolIndex
Phase::Global  -&gt; Build DependencyGraph
Phase::Semantic -&gt; Use dependencies for semantic analysis
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-passes"><a class="header" href="#integration-with-passes">Integration with Passes</a></h3>
<p><strong>DependencyPass</strong> (if implemented):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AnalyzerPass for DependencyPass {
    fn id(&amp;self) -&gt; &amp;'static str { "dependencies" }
    fn phase(&amp;self) -&gt; Phase { Phase::Global }
    
    fn run(&amp;self, cu: &amp;CompilationUnit, session: &amp;mut AnalysisSession) {
        let graph = build_dependency_graph(cu, &amp;session.artifacts.symbols);
        session.artifacts.dependencies = Some(graph);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="building-dependency-graph"><a class="header" href="#building-dependency-graph">Building Dependency Graph</a></h2>
<h3 id="from-compilationunit"><a class="header" href="#from-compilationunit">From CompilationUnit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn build_dependency_graph(
    cu: &amp;CompilationUnit,
    symbols: &amp;SymbolIndex
) -&gt; DependencyGraph {
    let mut graph = DependencyGraph::new();
    
    // Visit all declarations
    for decl in &amp;cu.declarations {
        match decl {
            TopLevelDeclaration::Class(class) =&gt; {
                analyze_class_dependencies(class, symbols, &amp;mut graph);
            }
            // ... other declaration types
        }
    }
    
    graph
}
<span class="boring">}</span></code></pre></pre>
<h3 id="from-class-declaration"><a class="header" href="#from-class-declaration">From Class Declaration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_class_dependencies(
    class: &amp;ClassDeclaration,
    symbols: &amp;SymbolIndex,
    graph: &amp;mut DependencyGraph
) {
    let class_symbol = symbols.lookup(&amp;class.identifier.name);
    
    // Base types
    for base_type in &amp;class.base_types {
        if let Some(base_symbol) = resolve_type(base_type, symbols) {
            graph.add_dependency(class_symbol, base_symbol);
        }
    }
    
    // Members
    for member in &amp;class.body_declarations {
        analyze_member_dependencies(member, class_symbol, symbols, graph);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="dependency-visualization"><a class="header" href="#dependency-visualization">Dependency Visualization</a></h2>
<h3 id="dependency-matrix"><a class="header" href="#dependency-matrix">Dependency Matrix</a></h3>
<p>Generate a matrix showing which types depend on which:</p>
<pre><code>        A  B  C  D
    A   -  X  -  X
    B   -  -  X  -
    C   X  -  -  -
    D   -  -  -  -
</code></pre>
<ul>
<li>Row A, Column B = X means A depends on B</li>
</ul>
<h3 id="dependency-tree"><a class="header" href="#dependency-tree">Dependency Tree</a></h3>
<pre><code>MyApp
├── Services
│   ├── UserService
│   │   ├── IUserRepository
│   │   └── IEmailService
│   └── OrderService
│       ├── IOrderRepository
│       └── IPaymentService
└── Models
    ├── User
    └── Order
</code></pre>
<hr />
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<h3 id="circular-dependency-warning"><a class="header" href="#circular-dependency-warning">Circular Dependency Warning</a></h3>
<pre><code>warning[DEP001]: Circular dependency detected
  --&gt; src/ClassA.cs:3:5
   |
 3 |     private ClassB b;
   |             ^^^^^^ ClassA depends on ClassB
   |
   = note: Dependency cycle: ClassA -&gt; ClassB -&gt; ClassC -&gt; ClassA
</code></pre>
<h3 id="high-coupling-warning"><a class="header" href="#high-coupling-warning">High Coupling Warning</a></h3>
<pre><code>warning[DEP002]: High efferent coupling detected
  --&gt; src/GodClass.cs:1:14
   |
 1 | public class GodClass {
   |              ^^^^^^^^ depends on 25 other types
   |
   = help: Consider breaking this class into smaller, focused classes
</code></pre>
<h3 id="unstable-dependency-warning"><a class="header" href="#unstable-dependency-warning">Unstable Dependency Warning</a></h3>
<pre><code>warning[DEP003]: Stable type depends on unstable type
  --&gt; src/StableClass.cs:5:5
   |
 5 |     private UnstableClass helper;
   |             ^^^^^^^^^^^^^ instability = 0.95
   |
   = note: Stable types (instability &lt; 0.2) should not depend on unstable types (instability &gt; 0.8)
</code></pre>
<hr />
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="thresholds-1"><a class="header" href="#thresholds-1">Thresholds</a></h3>
<pre><code class="language-toml">[analysis.dependencies]
max_efferent_coupling = 20
max_afferent_coupling = 10
max_instability = 0.8
warn_circular_dependencies = true
</code></pre>
<h3 id="cli-usage-1"><a class="header" href="#cli-usage-1">CLI Usage</a></h3>
<pre><code class="language-bash"># Analyze dependencies
bsharp analyze MyProject.csproj --enable-pass dependencies

# Generate dependency report
bsharp analyze MyProject.sln --out deps.json --format pretty-json
</code></pre>
<hr />
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h3>
<ol>
<li>
<p><strong>Package-Level Dependencies</strong></p>
<ul>
<li>Track dependencies between namespaces/assemblies</li>
<li>Identify layering violations</li>
</ul>
</li>
<li>
<p><strong>Dependency Metrics Dashboard</strong></p>
<ul>
<li>Visual dependency graphs</li>
<li>Coupling heatmaps</li>
<li>Trend analysis over time</li>
</ul>
</li>
<li>
<p><strong>Architectural Rules</strong></p>
<ul>
<li>Define allowed/forbidden dependencies</li>
<li>Enforce layered architecture</li>
<li>Prevent specific coupling patterns</li>
</ul>
</li>
<li>
<p><strong>Dependency Injection Analysis</strong></p>
<ul>
<li>Track DI container registrations</li>
<li>Verify dependency lifetimes</li>
<li>Detect missing registrations</li>
</ul>
</li>
</ol>
<hr />
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p><strong>Current State:</strong></p>
<ul>
<li>Basic dependency graph structure defined</li>
<li>Integration with analysis pipeline planned</li>
<li>Circular dependency detection algorithm ready</li>
</ul>
<p><strong>TODO:</strong></p>
<ul>
<li>Implement full dependency extraction from AST</li>
<li>Add coupling metrics calculation</li>
<li>Create dependency visualization tools</li>
<li>Add comprehensive tests</li>
</ul>
<hr />
<h2 id="related-documentation-1"><a class="header" href="#related-documentation-1">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - How dependency analysis fits in the pipeline</li>
<li><a href="analysis/./control-flow.html">Control Flow Analysis</a> - Related analysis type</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Coupling metrics</li>
<li><a href="analysis/../development/architecture.html">Architecture Decisions</a> - Design rationale</li>
</ul>
<hr />
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/analysis/artifacts/dependencies.rs</code></li>
<li><strong>Tests:</strong> <code>tests/analysis/dependencies/</code> (planned)</li>
<li><strong>Related Passes:</strong> <code>src/analysis/passes/</code> (when implemented)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h1>
<p>The BSharp metrics system collects comprehensive code metrics during analysis to assess code complexity, size, and maintainability.</p>
<hr />
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p><strong>Location:</strong> <code>src/analysis/metrics/</code></p>
<p>The metrics system provides:</p>
<ul>
<li><strong>Basic Metrics</strong> - Lines of code, statement counts, declaration counts</li>
<li><strong>Complexity Metrics</strong> - Cyclomatic complexity, cognitive complexity, nesting depth</li>
<li><strong>Maintainability Metrics</strong> - Maintainability index, Halstead metrics</li>
</ul>
<hr />
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<pre><code>src/analysis/metrics/
├── mod.rs                  # Module exports
├── core.rs                 # Core traits (AstAnalyze, MetricCollector)
├── basic.rs                # Basic metrics implementation
├── complexity.rs           # Complexity metrics
├── maintainability.rs      # Maintainability metrics
├── visitor.rs              # MetricsVisitor for pipeline
└── implementations/        # Trait implementations for AST nodes
    ├── compilation_unit.rs
    ├── class_declaration.rs
    ├── method_declaration.rs
    ├── statement.rs
    ├── expression.rs
    └── ...
</code></pre>
<h3 id="core-traits"><a class="header" href="#core-traits">Core Traits</a></h3>
<p><strong>AstAnalyze:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AstAnalyze {
    fn analyze(&amp;self) -&gt; AstAnalysis;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>MetricCollector:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MetricCollector {
    fn collect_metrics(&amp;self, analysis: &amp;mut AstAnalysis);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="metric-types"><a class="header" href="#metric-types">Metric Types</a></h2>
<h3 id="1-basic-metrics"><a class="header" href="#1-basic-metrics">1. Basic Metrics</a></h3>
<p><strong>AstAnalysis Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AstAnalysis {
    // Size metrics
    pub total_lines: usize,
    pub code_lines: usize,
    pub comment_lines: usize,
    pub blank_lines: usize,
    
    // Declaration counts
    pub namespace_count: usize,
    pub class_count: usize,
    pub interface_count: usize,
    pub struct_count: usize,
    pub enum_count: usize,
    pub method_count: usize,
    pub property_count: usize,
    pub field_count: usize,
    
    // Statement counts
    pub statement_count: usize,
    pub expression_count: usize,
    
    // Complexity (aggregated)
    pub total_complexity: usize,
    pub max_complexity: usize,
    pub max_nesting_depth: usize,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Collection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AstAnalyze for CompilationUnit {
    fn analyze(&amp;self) -&gt; AstAnalysis {
        let mut analysis = AstAnalysis::default();
        
        // Count declarations
        for decl in &amp;self.declarations {
            match decl {
                TopLevelDeclaration::Class(_) =&gt; analysis.class_count += 1,
                TopLevelDeclaration::Interface(_) =&gt; analysis.interface_count += 1,
                // ... other types
            }
        }
        
        analysis
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-complexity-metrics"><a class="header" href="#2-complexity-metrics">2. Complexity Metrics</a></h3>
<h4 id="cyclomatic-complexity-1"><a class="header" href="#cyclomatic-complexity-1">Cyclomatic Complexity</a></h4>
<p><strong>Definition:</strong> Number of linearly independent paths through code</p>
<p><strong>Formula:</strong> <code>CC = E - N + 2P</code></p>
<ul>
<li>E = edges in control flow graph</li>
<li>N = nodes in control flow graph</li>
<li>P = connected components (usually 1)</li>
</ul>
<p><strong>Simplified:</strong> <code>CC = 1 + number of decision points</code></p>
<p><strong>Decision Points:</strong></p>
<ul>
<li><code>if</code>, <code>else if</code></li>
<li><code>case</code> in <code>switch</code></li>
<li><code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code></li>
<li><code>&amp;&amp;</code>, <code>||</code> in conditions</li>
<li><code>catch</code> clauses</li>
<li><code>?:</code> ternary operator</li>
<li><code>??</code> null-coalescing operator</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {  // CC = 1 (base)
    if (order == null) {                 // +1 = 2
        throw new ArgumentNullException();
    }
    
    if (order.IsValid) {                 // +1 = 3
        if (order.Amount &gt; 1000) {       // +1 = 4
            ApplyDiscount(order);
        }
        SaveOrder(order);
    } else {                             // else doesn't add
        LogError(order);
    }
}
// Total CC = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cyclomatic_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 1;  // Base complexity
    
    if let Some(body) = &amp;method.body {
        complexity += count_decision_points(body);
    }
    
    complexity
}

fn count_decision_points(stmt: &amp;Statement) -&gt; usize {
    let mut count = 0;
    
    walk_statements(stmt, &amp;mut |s| {
        match s {
            Statement::If(_) =&gt; count += 1,
            Statement::For(_) =&gt; count += 1,
            Statement::ForEach(_) =&gt; count += 1,
            Statement::While(_) =&gt; count += 1,
            Statement::DoWhile(_) =&gt; count += 1,
            Statement::Switch(sw) =&gt; {
                // Each case is a decision point
                count += sw.sections.len();
            }
            Statement::Try(try_stmt) =&gt; {
                // Each catch is a decision point
                count += try_stmt.catch_clauses.len();
            }
            _ =&gt; {}
        }
    });
    
    // Also count logical operators in expressions
    // count += count_logical_operators(stmt);
    
    count
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-10:</strong> Simple, low risk</li>
<li><strong>11-20:</strong> Moderate complexity, moderate risk</li>
<li><strong>21-50:</strong> Complex, high risk</li>
<li><strong>50+:</strong> Very complex, very high risk - refactor recommended</li>
</ul>
<h4 id="cognitive-complexity"><a class="header" href="#cognitive-complexity">Cognitive Complexity</a></h4>
<p><strong>Definition:</strong> Measure of how difficult code is to understand</p>
<p><strong>Increments:</strong></p>
<ul>
<li><strong>+1</strong> for each: <code>if</code>, <code>else if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>, <code>catch</code>, <code>?:</code>, <code>??</code></li>
<li><strong>+1</strong> for each level of nesting (nested control structures)</li>
<li><strong>+1</strong> for each <code>break</code> or <code>continue</code> that jumps out of nested structure</li>
<li><strong>+1</strong> for each recursive call</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Process(List&lt;int&gt; items) {
    if (items != null) {                 // +1 (if)
        foreach (var item in items) {    // +1 (loop) +1 (nesting) = +2
            if (item &gt; 0) {              // +1 (if) +2 (nesting) = +3
                Process(item);           // +1 (recursion) +3 (nesting) = +4
            }
        }
    }
}
// Total Cognitive Complexity = 1 + 2 + 3 + 4 = 10
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cognitive_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 0;
    
    if let Some(body) = &amp;method.body {
        complexity = calculate_cognitive_complexity(body, 0);
    }
    
    complexity
}

fn calculate_cognitive_complexity(stmt: &amp;Statement, nesting_level: usize) -&gt; usize {
    let mut complexity = 0;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            complexity += 1 + nesting_level;  // if + nesting penalty
            complexity += calculate_cognitive_complexity(&amp;if_stmt.consequence, nesting_level + 1);
            if let Some(alt) = &amp;if_stmt.alternative {
                complexity += calculate_cognitive_complexity(alt, nesting_level + 1);
            }
        }
        Statement::For(for_stmt) =&gt; {
            complexity += 1 + nesting_level;
            if let Some(body) = &amp;for_stmt.body {
                complexity += calculate_cognitive_complexity(body, nesting_level + 1);
            }
        }
        // ... other statement types
        _ =&gt; {}
    }
    
    complexity
}
<span class="boring">}</span></code></pre></pre>
<h4 id="nesting-depth"><a class="header" href="#nesting-depth">Nesting Depth</a></h4>
<p><strong>Definition:</strong> Maximum depth of nested control structures</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Example() {
    if (condition1) {              // Depth 1
        while (condition2) {       // Depth 2
            if (condition3) {      // Depth 3
                for (int i = 0; i &lt; 10; i++) {  // Depth 4
                    // Code here
                }
            }
        }
    }
}
// Max Nesting Depth = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn max_nesting_depth(method: &amp;MethodDeclaration) -&gt; usize {
    method.body.as_ref()
        .map(|body| calculate_max_nesting(body, 0))
        .unwrap_or(0)
}

fn calculate_max_nesting(stmt: &amp;Statement, current_depth: usize) -&gt; usize {
    let mut max_depth = current_depth;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            let then_depth = calculate_max_nesting(&amp;if_stmt.consequence, current_depth + 1);
            max_depth = max_depth.max(then_depth);
            
            if let Some(alt) = &amp;if_stmt.alternative {
                let else_depth = calculate_max_nesting(alt, current_depth + 1);
                max_depth = max_depth.max(else_depth);
            }
        }
        Statement::Block(stmts) =&gt; {
            for s in stmts {
                let depth = calculate_max_nesting(s, current_depth);
                max_depth = max_depth.max(depth);
            }
        }
        // ... other nesting statements
        _ =&gt; {}
    }
    
    max_depth
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-3:</strong> Acceptable</li>
<li><strong>4-5:</strong> Consider refactoring</li>
<li><strong>6+:</strong> Refactor recommended</li>
</ul>
<h3 id="3-maintainability-metrics"><a class="header" href="#3-maintainability-metrics">3. Maintainability Metrics</a></h3>
<h4 id="maintainability-index"><a class="header" href="#maintainability-index">Maintainability Index</a></h4>
<p><strong>Definition:</strong> Composite metric indicating code maintainability</p>
<p><strong>Formula (Microsoft version):</strong></p>
<pre><code>MI = MAX(0, (171 - 5.2 * ln(HV) - 0.23 * CC - 16.2 * ln(LOC)) * 100 / 171)
</code></pre>
<p>Where:</p>
<ul>
<li><strong>HV</strong> = Halstead Volume</li>
<li><strong>CC</strong> = Cyclomatic Complexity</li>
<li><strong>LOC</strong> = Lines of Code</li>
</ul>
<p><strong>Scale:</strong></p>
<ul>
<li><strong>85-100:</strong> Good maintainability (green)</li>
<li><strong>65-84:</strong> Moderate maintainability (yellow)</li>
<li><strong>0-64:</strong> Difficult to maintain (red)</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust">pub fn maintainability_index(
    halstead_volume: f64,
    cyclomatic_complexity: usize,
    lines_of_code: usize
) -&gt; f64 {
    let hv_term = 5.2 * halstead_volume.ln();
    let cc_term = 0.23 * (cyclomatic_complexity as f64);
    let loc_term = 16.2 * (lines_of_code as f64).ln();
    
    let mi = 171.0 - hv_term - cc_term - loc_term;
    let normalized = (mi * 100.0 / 171.0).max(0.0);
    
    normalized
}</code></pre></pre>
<h4 id="halstead-metrics"><a class="header" href="#halstead-metrics">Halstead Metrics</a></h4>
<p><strong>Operators and Operands:</strong></p>
<ul>
<li><strong>n1</strong> = number of distinct operators</li>
<li><strong>n2</strong> = number of distinct operands</li>
<li><strong>N1</strong> = total number of operators</li>
<li><strong>N2</strong> = total number of operands</li>
</ul>
<p><strong>Derived Metrics:</strong></p>
<ul>
<li><strong>Program Vocabulary:</strong> <code>n = n1 + n2</code></li>
<li><strong>Program Length:</strong> <code>N = N1 + N2</code></li>
<li><strong>Calculated Length:</strong> <code>N' = n1 * log2(n1) + n2 * log2(n2)</code></li>
<li><strong>Volume:</strong> <code>V = N * log2(n)</code></li>
<li><strong>Difficulty:</strong> <code>D = (n1 / 2) * (N2 / n2)</code></li>
<li><strong>Effort:</strong> <code>E = D * V</code></li>
<li><strong>Time to Program:</strong> <code>T = E / 18</code> seconds</li>
<li><strong>Bugs Delivered:</strong> <code>B = V / 3000</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">int sum = a + b + c;
</code></pre>
<p>Operators: <code>int</code>, <code>=</code>, <code>+</code>, <code>+</code> (N1 = 4, n1 = 2)
Operands: <code>sum</code>, <code>a</code>, <code>b</code>, <code>c</code> (N2 = 4, n2 = 4)</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HalsteadMetrics {
    pub distinct_operators: usize,    // n1
    pub distinct_operands: usize,     // n2
    pub total_operators: usize,       // N1
    pub total_operands: usize,        // N2
    pub vocabulary: usize,            // n
    pub length: usize,                // N
    pub volume: f64,                  // V
    pub difficulty: f64,              // D
    pub effort: f64,                  // E
    pub time_to_program: f64,         // T
    pub bugs_delivered: f64,          // B
}

impl HalsteadMetrics {
    pub fn calculate(operators: &amp;HashSet&lt;String&gt;, operands: &amp;HashSet&lt;String&gt;,
                     op_count: usize, operand_count: usize) -&gt; Self {
        let n1 = operators.len();
        let n2 = operands.len();
        let n = n1 + n2;
        let N = op_count + operand_count;
        
        let volume = (N as f64) * (n as f64).log2();
        let difficulty = (n1 as f64 / 2.0) * (operand_count as f64 / n2 as f64);
        let effort = difficulty * volume;
        let time = effort / 18.0;
        let bugs = volume / 3000.0;
        
        HalsteadMetrics {
            distinct_operators: n1,
            distinct_operands: n2,
            total_operators: op_count,
            total_operands: operand_count,
            vocabulary: n,
            length: N,
            volume,
            difficulty,
            effort,
            time_to_program: time,
            bugs_delivered: bugs,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="metrics-collection-pipeline"><a class="header" href="#metrics-collection-pipeline">Metrics Collection Pipeline</a></h2>
<h3 id="metricsvisitor"><a class="header" href="#metricsvisitor">MetricsVisitor</a></h3>
<p><strong>Integration with Analysis Pipeline:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MetricsVisitor {
    metrics: AstAnalysis,
}

impl Visit for MetricsVisitor {
    fn enter(&amp;mut self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {
        match node {
            NodeRef::ClassDeclaration(class) =&gt; {
                self.metrics.class_count += 1;
            }
            NodeRef::MethodDeclaration(method) =&gt; {
                self.metrics.method_count += 1;
                
                // Calculate method complexity
                let complexity = cyclomatic_complexity(method);
                self.metrics.total_complexity += complexity;
                self.metrics.max_complexity = self.metrics.max_complexity.max(complexity);
                
                // Calculate nesting depth
                let nesting = max_nesting_depth(method);
                self.metrics.max_nesting_depth = self.metrics.max_nesting_depth.max(nesting);
            }
            // ... other node types
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Usage in Pipeline:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In AnalyzerPipeline::run_local_rules()
let mut walker = AstWalker::new();
walker = walker.with_visitor(Box::new(MetricsVisitor::new()));
walker.run(cu, session);

// Metrics stored in session.artifacts.metrics
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="cli-usage-2"><a class="header" href="#cli-usage-2">CLI Usage</a></h2>
<h3 id="analyze-metrics"><a class="header" href="#analyze-metrics">Analyze Metrics</a></h3>
<pre><code class="language-bash"># Analyze single file
bsharp analyze MyFile.cs

# Analyze project
bsharp analyze MyProject.csproj --out metrics.json

# Analyze solution
bsharp analyze MySolution.sln --out metrics.json --format pretty-json
</code></pre>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code class="language-json">{
  "schema_version": 1,
  "metrics": {
    "total_lines": 1250,
    "code_lines": 980,
    "comment_lines": 150,
    "blank_lines": 120,
    "class_count": 15,
    "method_count": 87,
    "total_complexity": 245,
    "max_complexity": 18,
    "max_nesting_depth": 5
  }
}
</code></pre>
<hr />
<h2 id="thresholds-and-warnings"><a class="header" href="#thresholds-and-warnings">Thresholds and Warnings</a></h2>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<pre><code class="language-toml">[analysis.metrics]
max_cyclomatic_complexity = 10
max_cognitive_complexity = 15
max_nesting_depth = 4
max_method_length = 50
min_maintainability_index = 65
</code></pre>
<h3 id="diagnostics-1"><a class="header" href="#diagnostics-1">Diagnostics</a></h3>
<p><strong>High Complexity Warning:</strong></p>
<pre><code>warning[MET001]: Method has high cyclomatic complexity
  --&gt; src/OrderProcessor.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ complexity = 18 (threshold: 10)
   |
   = help: Consider breaking this method into smaller methods
</code></pre>
<p><strong>Deep Nesting Warning:</strong></p>
<pre><code>warning[MET002]: Deep nesting detected
  --&gt; src/Validator.cs:15:9
   |
15 |         if (condition1) {
   |         ^^ nesting depth = 5 (threshold: 4)
   |
   = help: Consider extracting nested logic into separate methods
</code></pre>
<hr />
<h2 id="programmatic-usage-1"><a class="header" href="#programmatic-usage-1">Programmatic Usage</a></h2>
<h3 id="analyzing-a-method"><a class="header" href="#analyzing-a-method">Analyzing a Method</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::metrics::{cyclomatic_complexity, cognitive_complexity, max_nesting_depth};

let method = parse_method("public void MyMethod() { ... }");

let cc = cyclomatic_complexity(&amp;method);
let cog = cognitive_complexity(&amp;method);
let nesting = max_nesting_depth(&amp;method);

println!("Cyclomatic Complexity: {}", cc);
println!("Cognitive Complexity: {}", cog);
println!("Max Nesting Depth: {}", nesting);
<span class="boring">}</span></code></pre></pre>
<h3 id="analyzing-a-compilation-unit"><a class="header" href="#analyzing-a-compilation-unit">Analyzing a Compilation Unit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::metrics::AstAnalyze;

let parser = Parser::new();
let cu = parser.parse(source_code)?;

let metrics = cu.analyze();

println!("Classes: {}", metrics.class_count);
println!("Methods: {}", metrics.method_count);
println!("Total Complexity: {}", metrics.total_complexity);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation-2"><a class="header" href="#related-documentation-2">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - How metrics fit in the pipeline</li>
<li><a href="analysis/./control-flow.html">Control Flow Analysis</a> - Related complexity analysis</li>
<li><a href="analysis/./quality.html">Code Quality</a> - Quality assessment using metrics</li>
<li><a href="analysis/../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/analysis/metrics/</code></li>
<li><strong>Visitor:</strong> <code>src/analysis/metrics/visitor.rs</code></li>
<li><strong>Tests:</strong> <code>tests/analysis/metrics/</code> (planned)</li>
<li><strong>Standards:</strong> ISO/IEC 25023 (Software Quality Metrics)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-analysis-1"><a class="header" href="#type-analysis-1">Type Analysis</a></h1>
<p>The type analysis system provides insights into type usage, inheritance hierarchies, and type-related patterns in C# code.</p>
<hr />
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p><strong>Location:</strong> <code>src/analysis/types/</code></p>
<p>Type analysis tracks:</p>
<ul>
<li>Type definitions and their relationships</li>
<li>Inheritance hierarchies</li>
<li>Interface implementations</li>
<li>Generic type usage</li>
<li>Type references and dependencies</li>
</ul>
<hr />
<h2 id="type-information"><a class="header" href="#type-information">Type Information</a></h2>
<h3 id="type-categories-1"><a class="header" href="#type-categories-1">Type Categories</a></h3>
<p><strong>Value Types:</strong></p>
<ul>
<li>Primitives (<code>int</code>, <code>bool</code>, <code>double</code>, etc.)</li>
<li>Structs</li>
<li>Enums</li>
</ul>
<p><strong>Reference Types:</strong></p>
<ul>
<li>Classes</li>
<li>Interfaces</li>
<li>Delegates</li>
<li>Arrays</li>
</ul>
<p><strong>Special Types:</strong></p>
<ul>
<li>Generic type parameters</li>
<li>Nullable types</li>
<li>Tuple types</li>
<li>Anonymous types</li>
</ul>
<hr />
<h2 id="inheritance-analysis"><a class="header" href="#inheritance-analysis">Inheritance Analysis</a></h2>
<h3 id="class-hierarchies"><a class="header" href="#class-hierarchies">Class Hierarchies</a></h3>
<p><strong>Tracking Inheritance:</strong></p>
<pre><code class="language-csharp">public class Animal { }
public class Mammal : Animal { }
public class Dog : Mammal { }
</code></pre>
<p><strong>Hierarchy Representation:</strong></p>
<pre><code>Animal
└── Mammal
    └── Dog
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InheritanceHierarchy {
    // Type -&gt; Base Type
    base_types: HashMap&lt;TypeId, TypeId&gt;,
    // Type -&gt; Derived Types
    derived_types: HashMap&lt;TypeId, Vec&lt;TypeId&gt;&gt;,
}

impl InheritanceHierarchy {
    pub fn get_base_type(&amp;self, type_id: TypeId) -&gt; Option&lt;TypeId&gt;;
    pub fn get_derived_types(&amp;self, type_id: TypeId) -&gt; &amp;[TypeId];
    pub fn get_all_ancestors(&amp;self, type_id: TypeId) -&gt; Vec&lt;TypeId&gt;;
    pub fn get_all_descendants(&amp;self, type_id: TypeId) -&gt; Vec&lt;TypeId&gt;;
    pub fn inheritance_depth(&amp;self, type_id: TypeId) -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="interface-implementation"><a class="header" href="#interface-implementation">Interface Implementation</a></h3>
<p><strong>Tracking Implementations:</strong></p>
<pre><code class="language-csharp">public interface IRepository { }
public interface IUserRepository : IRepository { }
public class UserRepository : IUserRepository { }
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InterfaceImplementations {
    // Type -&gt; Interfaces it implements
    implementations: HashMap&lt;TypeId, Vec&lt;TypeId&gt;&gt;,
    // Interface -&gt; Types that implement it
    implementers: HashMap&lt;TypeId, Vec&lt;TypeId&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="generic-type-analysis"><a class="header" href="#generic-type-analysis">Generic Type Analysis</a></h2>
<h3 id="type-parameters-1"><a class="header" href="#type-parameters-1">Type Parameters</a></h3>
<p><strong>Tracking Generic Definitions:</strong></p>
<pre><code class="language-csharp">public class Container&lt;T&gt; where T : class { }
public class Repository&lt;TEntity, TKey&gt; where TEntity : class { }
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GenericTypeInfo {
    pub type_parameters: Vec&lt;TypeParameter&gt;,
    pub constraints: Vec&lt;TypeConstraint&gt;,
}

pub struct TypeParameter {
    pub name: String,
    pub variance: Option&lt;Variance&gt;,  // in, out
}

pub struct TypeConstraint {
    pub parameter: String,
    pub kind: ConstraintKind,
}

pub enum ConstraintKind {
    Class,              // where T : class
    Struct,             // where T : struct
    New,                // where T : new()
    BaseType(TypeId),   // where T : BaseClass
    Interface(TypeId),  // where T : IInterface
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generic-type-usage"><a class="header" href="#generic-type-usage">Generic Type Usage</a></h3>
<p><strong>Tracking Instantiations:</strong></p>
<pre><code class="language-csharp">var list = new List&lt;int&gt;();
var dict = new Dictionary&lt;string, User&gt;();
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GenericInstantiation {
    pub generic_type: TypeId,
    pub type_arguments: Vec&lt;TypeId&gt;,
}

pub fn find_generic_instantiations(cu: &amp;CompilationUnit) -&gt; Vec&lt;GenericInstantiation&gt;;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="type-usage-patterns"><a class="header" href="#type-usage-patterns">Type Usage Patterns</a></h2>
<h3 id="frequency-analysis"><a class="header" href="#frequency-analysis">Frequency Analysis</a></h3>
<p><strong>Most Used Types:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TypeUsageStats {
    pub type_references: HashMap&lt;TypeId, usize&gt;,
}

impl TypeUsageStats {
    pub fn most_used_types(&amp;self, limit: usize) -&gt; Vec&lt;(TypeId, usize)&gt;;
    pub fn usage_count(&amp;self, type_id: TypeId) -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-categories-distribution"><a class="header" href="#type-categories-distribution">Type Categories Distribution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TypeDistribution {
    pub class_count: usize,
    pub interface_count: usize,
    pub struct_count: usize,
    pub enum_count: usize,
    pub delegate_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="type-metrics"><a class="header" href="#type-metrics">Type Metrics</a></h2>
<h3 id="depth-of-inheritance-tree-dit"><a class="header" href="#depth-of-inheritance-tree-dit">Depth of Inheritance Tree (DIT)</a></h3>
<p><strong>Definition:</strong> Maximum depth from type to root of hierarchy</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">class A { }              // DIT = 0 (or 1 from Object)
class B : A { }          // DIT = 1 (or 2 from Object)
class C : B { }          // DIT = 2 (or 3 from Object)
</code></pre>
<p><strong>Interpretation:</strong></p>
<ul>
<li><strong>Low DIT (0-2):</strong> Simple hierarchy, easy to understand</li>
<li><strong>Medium DIT (3-4):</strong> Moderate complexity</li>
<li><strong>High DIT (5+):</strong> Complex hierarchy, may indicate over-engineering</li>
</ul>
<h3 id="number-of-children-noc"><a class="header" href="#number-of-children-noc">Number of Children (NOC)</a></h3>
<p><strong>Definition:</strong> Number of immediate subclasses</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">class Animal { }
class Dog : Animal { }
class Cat : Animal { }
class Bird : Animal { }
// Animal has NOC = 3
</code></pre>
<p><strong>Interpretation:</strong></p>
<ul>
<li><strong>High NOC:</strong> Type is heavily reused (good abstraction or god class)</li>
<li><strong>Low NOC:</strong> Specialized type or leaf in hierarchy</li>
</ul>
<h3 id="lack-of-cohesion-of-methods-lcom"><a class="header" href="#lack-of-cohesion-of-methods-lcom">Lack of Cohesion of Methods (LCOM)</a></h3>
<p><strong>Definition:</strong> Measure of how well methods in a class are related</p>
<p><strong>Simplified Calculation:</strong></p>
<ul>
<li>Count pairs of methods that don't share instance variables</li>
<li>High LCOM suggests class should be split</li>
</ul>
<hr />
<h2 id="type-compatibility-analysis"><a class="header" href="#type-compatibility-analysis">Type Compatibility Analysis</a></h2>
<h3 id="assignability"><a class="header" href="#assignability">Assignability</a></h3>
<p><strong>Checking Compatibility:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_assignable_to(from: &amp;Type, to: &amp;Type, context: &amp;TypeContext) -&gt; bool {
    // Check if 'from' type can be assigned to 'to' type
    // Considers inheritance, interface implementation, variance, etc.
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Derived type assignable to base type</li>
<li>Type assignable to implemented interface</li>
<li>Covariant/contravariant generic types</li>
<li>Nullable value types</li>
<li>Implicit conversions</li>
</ul>
<h3 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h3>
<p><strong>Tracking Conversions:</strong></p>
<pre><code class="language-csharp">int x = 42;
long y = x;              // Implicit conversion
string s = x.ToString(); // Explicit conversion
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ConversionKind {
    Implicit,
    Explicit,
    UserDefined,
}

pub struct TypeConversion {
    pub from: TypeId,
    pub to: TypeId,
    pub kind: ConversionKind,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="nullable-reference-types-analysis"><a class="header" href="#nullable-reference-types-analysis">Nullable Reference Types Analysis</a></h2>
<h3 id="nullability-tracking"><a class="header" href="#nullability-tracking">Nullability Tracking</a></h3>
<p><strong>C# 8+ Nullable Annotations:</strong></p>
<pre><code class="language-csharp">string? nullable = null;      // Nullable reference
string nonNull = "value";     // Non-nullable reference
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NullabilityInfo {
    pub is_nullable: bool,
    pub nullability_context: NullabilityContext,
}

pub enum NullabilityContext {
    Enabled,
    Disabled,
    Warnings,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="null-safety-diagnostics"><a class="header" href="#null-safety-diagnostics">Null Safety Diagnostics</a></h3>
<p><strong>Potential Null Reference:</strong></p>
<pre><code>warning[TYPE001]: Possible null reference
  --&gt; src/UserService.cs:15:9
   |
15 |     user.Name = "John";
   |     ^^^^ 'user' may be null here
   |
   = help: Add null check or use null-conditional operator
</code></pre>
<hr />
<h2 id="type-analysis-in-pipeline"><a class="header" href="#type-analysis-in-pipeline">Type Analysis in Pipeline</a></h2>
<h3 id="integration"><a class="header" href="#integration">Integration</a></h3>
<p><strong>Phase:</strong> Semantic (after symbol indexing)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AnalyzerPass for TypeAnalysisPass {
    fn id(&amp;self) -&gt; &amp;'static str { "type_analysis" }
    fn phase(&amp;self) -&gt; Phase { Phase::Semantic }
    
    fn run(&amp;self, cu: &amp;CompilationUnit, session: &amp;mut AnalysisSession) {
        let type_info = analyze_types(cu, &amp;session.artifacts.symbols);
        session.artifacts.type_info = Some(type_info);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="programmatic-usage-2"><a class="header" href="#programmatic-usage-2">Programmatic Usage</a></h2>
<h3 id="analyzing-type-hierarchy"><a class="header" href="#analyzing-type-hierarchy">Analyzing Type Hierarchy</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::types::InheritanceHierarchy;

let hierarchy = InheritanceHierarchy::build(cu);

// Get base type
if let Some(base) = hierarchy.get_base_type(type_id) {
    println!("Base type: {:?}", base);
}

// Get all derived types
let derived = hierarchy.get_derived_types(type_id);
println!("Derived types: {:?}", derived);

// Calculate inheritance depth
let depth = hierarchy.inheritance_depth(type_id);
println!("Inheritance depth: {}", depth);
<span class="boring">}</span></code></pre></pre>
<h3 id="finding-generic-instantiations"><a class="header" href="#finding-generic-instantiations">Finding Generic Instantiations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::types::find_generic_instantiations;

let instantiations = find_generic_instantiations(cu);

for inst in instantiations {
    println!("Generic type: {:?}", inst.generic_type);
    println!("Type arguments: {:?}", inst.type_arguments);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="future-enhancements-1"><a class="header" href="#future-enhancements-1">Future Enhancements</a></h2>
<h3 id="planned-features-1"><a class="header" href="#planned-features-1">Planned Features</a></h3>
<ol>
<li>
<p><strong>Type Inference Tracking</strong></p>
<ul>
<li>Track <code>var</code> usage and inferred types</li>
<li>Analyze type inference patterns</li>
</ul>
</li>
<li>
<p><strong>Variance Analysis</strong></p>
<ul>
<li>Detect variance violations</li>
<li>Suggest covariant/contravariant annotations</li>
</ul>
</li>
<li>
<p><strong>Type Safety Metrics</strong></p>
<ul>
<li>Measure use of <code>dynamic</code></li>
<li>Track unsafe casts</li>
<li>Nullable reference type coverage</li>
</ul>
</li>
<li>
<p><strong>Design Pattern Detection</strong></p>
<ul>
<li>Identify common patterns (Factory, Strategy, etc.)</li>
<li>Detect anti-patterns</li>
</ul>
</li>
</ol>
<hr />
<h2 id="implementation-status-1"><a class="header" href="#implementation-status-1">Implementation Status</a></h2>
<p><strong>Current State:</strong></p>
<ul>
<li>Basic type tracking infrastructure in place</li>
<li>Type analysis module integrated with analysis framework</li>
<li>Foundation for inheritance and generic analysis established</li>
</ul>
<p><strong>In Progress:</strong></p>
<ul>
<li>Full inheritance hierarchy analysis</li>
<li>Generic type instantiation tracking</li>
<li>Type usage statistics collection</li>
<li>Comprehensive test coverage</li>
</ul>
<p><strong>Planned:</strong></p>
<ul>
<li>Variance analysis</li>
<li>Type safety metrics</li>
<li>Design pattern detection based on type relationships</li>
</ul>
<hr />
<h2 id="related-documentation-3"><a class="header" href="#related-documentation-3">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - Pipeline integration</li>
<li><a href="analysis/./dependencies.html">Dependency Analysis</a> - Type dependencies</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Type-related metrics</li>
<li><a href="analysis/../parser/ast-structure.html">AST Structure</a> - Type representations</li>
</ul>
<hr />
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/analysis/types/</code></li>
<li><strong>Tests:</strong> <code>tests/analysis/types/</code></li>
<li><strong>Type System:</strong> <code>src/syntax/nodes/types/</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-quality-analysis"><a class="header" href="#code-quality-analysis">Code Quality Analysis</a></h1>
<p>The code quality analysis system detects code smells, anti-patterns, and violations of best practices in C# code.</p>
<hr />
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p><strong>Location:</strong> <code>src/analysis/quality/</code></p>
<p>Quality analysis provides:</p>
<ul>
<li>Code smell detection</li>
<li>Best practice validation</li>
<li>Design pattern recognition</li>
<li>Maintainability assessment</li>
<li>Technical debt identification</li>
</ul>
<hr />
<h2 id="code-smells"><a class="header" href="#code-smells">Code Smells</a></h2>
<h3 id="method-level-smells"><a class="header" href="#method-level-smells">Method-Level Smells</a></h3>
<h4 id="long-method"><a class="header" href="#long-method">Long Method</a></h4>
<p><strong>Description:</strong> Method with too many lines of code</p>
<p><strong>Threshold:</strong> &gt; 50 lines (configurable)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {
    // 150 lines of code...
}
</code></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[QUAL001]: Long method detected
  --&gt; src/OrderService.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ method has 150 lines (threshold: 50)
   |
   = help: Consider breaking this method into smaller, focused methods
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Extract method</li>
<li>Decompose into smaller methods</li>
<li>Apply Single Responsibility Principle</li>
</ul>
<h4 id="long-parameter-list"><a class="header" href="#long-parameter-list">Long Parameter List</a></h4>
<p><strong>Description:</strong> Method with too many parameters</p>
<p><strong>Threshold:</strong> &gt; 5 parameters (configurable)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void CreateUser(string firstName, string lastName, string email, 
                      string phone, string address, string city, string zip) {
    // ...
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Introduce parameter object</li>
<li>Use builder pattern</li>
<li>Group related parameters into DTOs</li>
</ul>
<h4 id="complex-conditional"><a class="header" href="#complex-conditional">Complex Conditional</a></h4>
<p><strong>Description:</strong> Deeply nested or complex conditional logic</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">if (user != null &amp;&amp; user.IsActive &amp;&amp; (user.Role == "Admin" || user.Role == "Manager") 
    &amp;&amp; user.Department != null &amp;&amp; user.Department.Budget &gt; 10000) {
    // ...
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Extract condition to well-named method</li>
<li>Use guard clauses</li>
<li>Simplify boolean logic</li>
</ul>
<h3 id="class-level-smells"><a class="header" href="#class-level-smells">Class-Level Smells</a></h3>
<h4 id="large-class-god-class"><a class="header" href="#large-class-god-class">Large Class (God Class)</a></h4>
<p><strong>Description:</strong> Class with too many responsibilities</p>
<p><strong>Indicators:</strong></p>
<ul>
<li>Too many methods (&gt; 20)</li>
<li>Too many fields (&gt; 10)</li>
<li>High cyclomatic complexity</li>
<li>Low cohesion</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class UserManager {
    // 50 methods handling user CRUD, authentication, authorization,
    // email sending, logging, caching, validation, etc.
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Split into multiple classes</li>
<li>Apply Single Responsibility Principle</li>
<li>Extract related functionality</li>
</ul>
<h4 id="feature-envy"><a class="header" href="#feature-envy">Feature Envy</a></h4>
<p><strong>Description:</strong> Method uses more features of another class than its own</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class OrderProcessor {
    public decimal CalculateTotal(Order order) {
        decimal total = 0;
        foreach (var item in order.Items) {
            total += item.Price * item.Quantity;
        }
        total -= order.Discount;
        total += order.Tax;
        return total;
    }
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Move method to <code>Order</code> class</li>
<li>Method should be where the data is</li>
</ul>
<h4 id="data-class"><a class="header" href="#data-class">Data Class</a></h4>
<p><strong>Description:</strong> Class with only fields and getters/setters, no behavior</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class User {
    public string Name { get; set; }
    public string Email { get; set; }
    public int Age { get; set; }
    // No methods, just data
}
</code></pre>
<p><strong>Note:</strong> Sometimes acceptable for DTOs, but domain objects should have behavior</p>
<h3 id="code-organization-smells"><a class="header" href="#code-organization-smells">Code Organization Smells</a></h3>
<h4 id="duplicate-code"><a class="header" href="#duplicate-code">Duplicate Code</a></h4>
<p><strong>Description:</strong> Identical or very similar code in multiple places</p>
<p><strong>Detection:</strong></p>
<ul>
<li>Token-based comparison</li>
<li>AST structure comparison</li>
<li>Minimum clone size threshold</li>
</ul>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Extract method</li>
<li>Extract class</li>
<li>Use inheritance or composition</li>
</ul>
<h4 id="dead-code"><a class="header" href="#dead-code">Dead Code</a></h4>
<p><strong>Description:</strong> Code that is never executed</p>
<p><strong>Examples:</strong></p>
<ul>
<li>Unreachable statements after <code>return</code></li>
<li>Unused private methods</li>
<li>Unused fields</li>
<li>Conditions that are always true/false</li>
</ul>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[QUAL010]: Unreachable code detected
  --&gt; src/Calculator.cs:15:9
   |
14 |     return result;
15 |     Console.WriteLine("Done");  // Never executed
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
</code></pre>
<h4 id="magic-numbers"><a class="header" href="#magic-numbers">Magic Numbers</a></h4>
<p><strong>Description:</strong> Unexplained numeric literals in code</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">if (order.Total &gt; 1000) {  // What does 1000 mean?
    ApplyDiscount(order, 0.1);  // What does 0.1 mean?
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<pre><code class="language-csharp">const decimal BULK_ORDER_THRESHOLD = 1000m;
const decimal BULK_ORDER_DISCOUNT = 0.1m;

if (order.Total &gt; BULK_ORDER_THRESHOLD) {
    ApplyDiscount(order, BULK_ORDER_DISCOUNT);
}
</code></pre>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h3>
<p><strong>Rules:</strong></p>
<ul>
<li>Classes: PascalCase</li>
<li>Methods: PascalCase</li>
<li>Properties: PascalCase</li>
<li>Fields: camelCase with <code>_</code> prefix for private</li>
<li>Constants: UPPER_CASE or PascalCase</li>
<li>Interfaces: PascalCase with <code>I</code> prefix</li>
</ul>
<p><strong>Violations:</strong></p>
<pre><code>warning[QUAL020]: Naming convention violation
  --&gt; src/UserService.cs:5:17
   |
 5 |     private int UserCount;
   |                 ^^^^^^^^^ private field should use camelCase with _ prefix
   |
   = help: Rename to '_userCount'
</code></pre>
<h3 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h3>
<p><strong>Anti-patterns:</strong></p>
<p><strong>Empty Catch Block:</strong></p>
<pre><code class="language-csharp">try {
    RiskyOperation();
} catch (Exception) {
    // Silent failure - BAD!
}
</code></pre>
<p><strong>Catching Generic Exception:</strong></p>
<pre><code class="language-csharp">try {
    SpecificOperation();
} catch (Exception ex) {  // Too broad
    // ...
}
</code></pre>
<p><strong>Best Practices:</strong></p>
<ul>
<li>Catch specific exceptions</li>
<li>Log exceptions</li>
<li>Don't swallow exceptions</li>
<li>Use <code>finally</code> for cleanup</li>
</ul>
<h3 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h3>
<p><strong>Using Statement:</strong></p>
<pre><code class="language-csharp">// Good
using (var file = File.OpenRead("data.txt")) {
    // Use file
}

// Better (C# 8+)
using var file = File.OpenRead("data.txt");
// Disposed at end of scope
</code></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[QUAL030]: IDisposable not properly disposed
  --&gt; src/FileProcessor.cs:10:9
   |
10 |     var file = File.OpenRead("data.txt");
   |         ^^^^ should be wrapped in using statement
</code></pre>
<hr />
<h2 id="design-patterns-and-anti-patterns"><a class="header" href="#design-patterns-and-anti-patterns">Design Patterns and Anti-Patterns</a></h2>
<h3 id="detected-patterns"><a class="header" href="#detected-patterns">Detected Patterns</a></h3>
<h4 id="singleton-pattern"><a class="header" href="#singleton-pattern">Singleton Pattern</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>Private constructor</li>
<li>Static instance field</li>
<li>Public static accessor</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class Logger {
    private static Logger _instance;
    private Logger() { }
    
    public static Logger Instance {
        get {
            if (_instance == null) {
                _instance = new Logger();
            }
            return _instance;
        }
    }
}
</code></pre>
<h4 id="factory-pattern"><a class="header" href="#factory-pattern">Factory Pattern</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>Method returning interface or base class</li>
<li>Creates different concrete types based on parameters</li>
</ul>
<h3 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-Patterns</a></h3>
<h4 id="god-object"><a class="header" href="#god-object">God Object</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>High number of methods and fields</li>
<li>Low cohesion</li>
<li>High coupling</li>
</ul>
<h4 id="spaghetti-code"><a class="header" href="#spaghetti-code">Spaghetti Code</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>High cyclomatic complexity</li>
<li>Deep nesting</li>
<li>Lack of structure</li>
</ul>
<h4 id="lava-flow"><a class="header" href="#lava-flow">Lava Flow</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>Dead code</li>
<li>Commented-out code</li>
<li>Unused variables/methods</li>
</ul>
<hr />
<h2 id="quality-metrics"><a class="header" href="#quality-metrics">Quality Metrics</a></h2>
<h3 id="code-quality-score"><a class="header" href="#code-quality-score">Code Quality Score</a></h3>
<p><strong>Composite Score (0-100):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QualityScore {
    pub overall: f64,
    pub maintainability: f64,
    pub complexity: f64,
    pub duplication: f64,
    pub test_coverage: f64,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Calculation:</strong></p>
<pre><code>Overall = (Maintainability * 0.3) + 
          (Complexity * 0.3) + 
          (Duplication * 0.2) + 
          (TestCoverage * 0.2)
</code></pre>
<h3 id="technical-debt"><a class="header" href="#technical-debt">Technical Debt</a></h3>
<p><strong>Estimation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TechnicalDebt {
    pub total_issues: usize,
    pub estimated_hours: f64,
    pub debt_ratio: f64,  // debt / total development time
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Calculation:</strong></p>
<ul>
<li>Each code smell assigned time cost</li>
<li>Sum all issues</li>
<li>Compare to total codebase size</li>
</ul>
<hr />
<h2 id="quality-rules"><a class="header" href="#quality-rules">Quality Rules</a></h2>
<h3 id="rule-system"><a class="header" href="#rule-system">Rule System</a></h3>
<p><strong>Rule Definition:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait QualityRule {
    fn id(&amp;self) -&gt; &amp;'static str;
    fn name(&amp;self) -&gt; &amp;'static str;
    fn description(&amp;self) -&gt; &amp;'static str;
    fn check(&amp;self, node: &amp;NodeRef, session: &amp;mut AnalysisSession);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Example Rule:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LongMethodRule {
    max_lines: usize,
}

impl QualityRule for LongMethodRule {
    fn id(&amp;self) -&gt; &amp;'static str { "long_method" }
    fn name(&amp;self) -&gt; &amp;'static str { "Long Method" }
    
    fn check(&amp;self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {
        if let NodeRef::MethodDeclaration(method) = node {
            let line_count = count_lines(method);
            if line_count &gt; self.max_lines {
                session.diagnostics.add(
                    DiagnosticCode::LongMethod,
                    format!("Method has {} lines (threshold: {})", 
                           line_count, self.max_lines)
                );
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rule-categories"><a class="header" href="#rule-categories">Rule Categories</a></h3>
<p><strong>Maintainability Rules:</strong></p>
<ul>
<li>Long method</li>
<li>Long parameter list</li>
<li>Large class</li>
<li>Complex method</li>
</ul>
<p><strong>Reliability Rules:</strong></p>
<ul>
<li>Empty catch blocks</li>
<li>Null reference risks</li>
<li>Resource leaks</li>
<li>Unhandled exceptions</li>
</ul>
<p><strong>Security Rules:</strong></p>
<ul>
<li>SQL injection risks</li>
<li>XSS vulnerabilities</li>
<li>Hardcoded credentials</li>
<li>Insecure random</li>
</ul>
<p><strong>Performance Rules:</strong></p>
<ul>
<li>Inefficient loops</li>
<li>Unnecessary allocations</li>
<li>String concatenation in loops</li>
<li>Boxing/unboxing</li>
</ul>
<hr />
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<h3 id="quality-thresholds"><a class="header" href="#quality-thresholds">Quality Thresholds</a></h3>
<pre><code class="language-toml">[analysis.quality]
max_method_lines = 50
max_parameters = 5
max_class_methods = 20
max_cyclomatic_complexity = 10
max_nesting_depth = 4

[analysis.quality.rules]
long_method = "warning"
long_parameter_list = "warning"
god_class = "error"
empty_catch = "error"
magic_numbers = "info"
</code></pre>
<h3 id="severity-levels"><a class="header" href="#severity-levels">Severity Levels</a></h3>
<ul>
<li><strong>Error:</strong> Must be fixed</li>
<li><strong>Warning:</strong> Should be fixed</li>
<li><strong>Info:</strong> Consider fixing</li>
<li><strong>Hint:</strong> Suggestion for improvement</li>
</ul>
<hr />
<h2 id="cli-usage-3"><a class="header" href="#cli-usage-3">CLI Usage</a></h2>
<h3 id="quality-analysis-1"><a class="header" href="#quality-analysis-1">Quality Analysis</a></h3>
<pre><code class="language-bash"># Analyze code quality
bsharp analyze MyProject.csproj --enable-ruleset quality

# Generate quality report
bsharp analyze MySolution.sln --out quality-report.json

# Filter by severity
bsharp analyze MyFile.cs --severity error,warning
</code></pre>
<h3 id="example-output-1"><a class="header" href="#example-output-1">Example Output</a></h3>
<pre><code class="language-json">{
  "quality_score": {
    "overall": 72.5,
    "maintainability": 68.0,
    "complexity": 75.0,
    "duplication": 80.0
  },
  "technical_debt": {
    "total_issues": 45,
    "estimated_hours": 12.5,
    "debt_ratio": 0.08
  },
  "diagnostics": [
    {
      "code": "QUAL001",
      "severity": "warning",
      "message": "Long method detected",
      "file": "src/OrderService.cs",
      "line": 42,
      "column": 17
    }
  ]
}
</code></pre>
<hr />
<h2 id="integration-with-pipeline-1"><a class="header" href="#integration-with-pipeline-1">Integration with Pipeline</a></h2>
<h3 id="quality-ruleset"><a class="header" href="#quality-ruleset">Quality Ruleset</a></h3>
<p><strong>Registration:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In AnalyzerRegistry
registry.add_ruleset(QualityRuleset {
    id: "quality",
    rules: vec![
        Box::new(LongMethodRule::new()),
        Box::new(LongParameterListRule::new()),
        Box::new(GodClassRule::new()),
        Box::new(EmptyCatchRule::new()),
        // ... more rules
    ],
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Execution:</strong></p>
<ul>
<li>Rules run during Local or Semantic phase</li>
<li>Visitor pattern for AST traversal</li>
<li>Diagnostics collected in session</li>
</ul>
<hr />
<h2 id="programmatic-usage-3"><a class="header" href="#programmatic-usage-3">Programmatic Usage</a></h2>
<h3 id="running-quality-analysis"><a class="header" href="#running-quality-analysis">Running Quality Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::quality::QualityAnalyzer;

let parser = Parser::new();
let cu = parser.parse(source_code)?;

let analyzer = QualityAnalyzer::new();
let report = analyzer.analyze(&amp;cu);

println!("Quality Score: {}", report.quality_score.overall);
println!("Issues Found: {}", report.diagnostics.len());
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-rules-1"><a class="header" href="#custom-rules-1">Custom Rules</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::quality::QualityRule;

struct CustomRule;

impl QualityRule for CustomRule {
    fn id(&amp;self) -&gt; &amp;'static str { "custom_rule" }
    fn name(&amp;self) -&gt; &amp;'static str { "Custom Rule" }
    
    fn check(&amp;self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {
        // Custom logic
    }
}

// Register custom rule
analyzer.add_rule(Box::new(CustomRule));
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="future-enhancements-2"><a class="header" href="#future-enhancements-2">Future Enhancements</a></h2>
<h3 id="planned-features-2"><a class="header" href="#planned-features-2">Planned Features</a></h3>
<ol>
<li>
<p><strong>Machine Learning-Based Detection</strong></p>
<ul>
<li>Learn from codebase patterns</li>
<li>Detect project-specific smells</li>
</ul>
</li>
<li>
<p><strong>Refactoring Suggestions</strong></p>
<ul>
<li>Automated refactoring proposals</li>
<li>Preview refactoring impact</li>
</ul>
</li>
<li>
<p><strong>Quality Trends</strong></p>
<ul>
<li>Track quality over time</li>
<li>Identify degradation</li>
<li>Measure improvement</li>
</ul>
</li>
<li>
<p><strong>Team Metrics</strong></p>
<ul>
<li>Per-developer quality metrics</li>
<li>Code review insights</li>
<li>Best practice adoption</li>
</ul>
</li>
</ol>
<hr />
<h2 id="related-documentation-4"><a class="header" href="#related-documentation-4">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - Pipeline integration</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Quality metrics</li>
<li><a href="analysis/./control-flow.html">Control Flow Analysis</a> - Complexity analysis</li>
<li><a href="analysis/../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/analysis/quality/</code></li>
<li><strong>Rules:</strong> <code>src/analysis/rules/</code></li>
<li><strong>Tests:</strong> <code>tests/analysis/quality/</code> (planned)</li>
<li><strong>Standards:</strong> Clean Code (Robert C. Martin), Refactoring (Martin Fowler)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h1>
<p>The BSharp CLI provides command-line tools for parsing, analyzing, visualizing, and compiling C# code.</p>
<hr />
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="from-source"><a class="header" href="#from-source">From Source</a></h3>
<pre><code class="language-bash">git clone https://github.com/your-repo/bsharp.git
cd bsharp
cargo build --release
</code></pre>
<p>The binary will be available at <code>target/release/bsharp</code>.</p>
<h3 id="add-to-path"><a class="header" href="#add-to-path">Add to PATH</a></h3>
<pre><code class="language-bash"># Linux/macOS
export PATH="$PATH:/path/to/bsharp/target/release"

# Windows
# Add to System Environment Variables
</code></pre>
<hr />
<h2 id="command-structure"><a class="header" href="#command-structure">Command Structure</a></h2>
<pre><code class="language-bash">bsharp &lt;COMMAND&gt; [OPTIONS] &lt;INPUT&gt;
</code></pre>
<h3 id="global-options"><a class="header" href="#global-options">Global Options</a></h3>
<pre><code class="language-bash">--help, -h      Show help information
--version, -V   Show version information
</code></pre>
<hr />
<h2 id="available-commands"><a class="header" href="#available-commands">Available Commands</a></h2>
<h3 id="parse"><a class="header" href="#parse">parse</a></h3>
<p>Parse C# source code and output JSON representation of the AST.</p>
<pre><code class="language-bash">bsharp parse &lt;INPUT&gt; [--output &lt;FILE&gt;]
</code></pre>
<p><strong>See:</strong> <a href="cli/./parse.html">Parse Command</a></p>
<h3 id="tree"><a class="header" href="#tree">tree</a></h3>
<p>Generate SVG visualization of the Abstract Syntax Tree.</p>
<pre><code class="language-bash">bsharp tree &lt;INPUT&gt; [--output &lt;FILE&gt;]
</code></pre>
<p><strong>See:</strong> <a href="cli/./tree.html">Tree Visualization</a></p>
<h3 id="compile"><a class="header" href="#compile">compile</a></h3>
<p>Compile C# source code to native binary.</p>
<pre><code class="language-bash">bsharp compile &lt;INPUT&gt;
</code></pre>
<p><strong>See:</strong> <a href="cli/./compile.html">Compilation</a></p>
<h3 id="analyze"><a class="header" href="#analyze">analyze</a></h3>
<p>Analyze C# code and generate comprehensive analysis report.</p>
<pre><code class="language-bash">bsharp analyze &lt;INPUT&gt; [OPTIONS]
</code></pre>
<p><strong>See:</strong> <a href="cli/./analyze.html">Analysis Command</a> (to be created)</p>
<hr />
<h2 id="common-usage-patterns"><a class="header" href="#common-usage-patterns">Common Usage Patterns</a></h2>
<h3 id="quick-parse-check"><a class="header" href="#quick-parse-check">Quick Parse Check</a></h3>
<pre><code class="language-bash"># Check if file parses successfully
bsharp parse MyFile.cs
</code></pre>
<h3 id="generate-ast-for-inspection"><a class="header" href="#generate-ast-for-inspection">Generate AST for Inspection</a></h3>
<pre><code class="language-bash"># Pretty-printed JSON
bsharp parse MyFile.cs --output ast.json
</code></pre>
<h3 id="visualize-code-structure"><a class="header" href="#visualize-code-structure">Visualize Code Structure</a></h3>
<pre><code class="language-bash"># Generate SVG diagram
bsharp tree MyClass.cs --output diagram.svg
</code></pre>
<h3 id="analyze-project-quality"><a class="header" href="#analyze-project-quality">Analyze Project Quality</a></h3>
<pre><code class="language-bash"># Full analysis with report
bsharp analyze MyProject.csproj --out report.json --format pretty-json
</code></pre>
<h3 id="analyze-solution"><a class="header" href="#analyze-solution">Analyze Solution</a></h3>
<pre><code class="language-bash"># Analyze entire solution
bsharp analyze MySolution.sln --follow-refs true
</code></pre>
<hr />
<h2 id="input-types"><a class="header" href="#input-types">Input Types</a></h2>
<h3 id="single-file"><a class="header" href="#single-file">Single File</a></h3>
<pre><code class="language-bash">bsharp parse Program.cs
</code></pre>
<h3 id="project-file-csproj"><a class="header" href="#project-file-csproj">Project File (.csproj)</a></h3>
<pre><code class="language-bash">bsharp analyze MyProject.csproj
</code></pre>
<h3 id="solution-file-sln"><a class="header" href="#solution-file-sln">Solution File (.sln)</a></h3>
<pre><code class="language-bash">bsharp analyze MySolution.sln
</code></pre>
<h3 id="directory"><a class="header" href="#directory">Directory</a></h3>
<pre><code class="language-bash">bsharp analyze ./src
</code></pre>
<hr />
<h2 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h2>
<h3 id="json-compact"><a class="header" href="#json-compact">JSON (Compact)</a></h3>
<pre><code class="language-bash">bsharp analyze MyFile.cs --format json
</code></pre>
<p><strong>Output:</strong> Single-line JSON, optimized for machine consumption</p>
<h3 id="pretty-json"><a class="header" href="#pretty-json">Pretty JSON</a></h3>
<pre><code class="language-bash">bsharp analyze MyFile.cs --format pretty-json
</code></pre>
<p><strong>Output:</strong> Indented JSON, human-readable</p>
<h3 id="svg-tree-command"><a class="header" href="#svg-tree-command">SVG (Tree Command)</a></h3>
<pre><code class="language-bash">bsharp tree MyFile.cs --output diagram.svg
</code></pre>
<p><strong>Output:</strong> Scalable Vector Graphics visualization</p>
<hr />
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<h3 id="parse-errors"><a class="header" href="#parse-errors">Parse Errors</a></h3>
<pre><code class="language-bash">$ bsharp parse InvalidSyntax.cs
Error: Parse failed at line 5, column 12
Expected ';' but found 'class'

public class MyClass
            ^
</code></pre>
<h3 id="file-not-found"><a class="header" href="#file-not-found">File Not Found</a></h3>
<pre><code class="language-bash">$ bsharp parse NonExistent.cs
Error: File not found: NonExistent.cs
</code></pre>
<h3 id="invalid-project"><a class="header" href="#invalid-project">Invalid Project</a></h3>
<pre><code class="language-bash">$ bsharp analyze Invalid.csproj
Error: Failed to parse project file: Invalid XML
</code></pre>
<hr />
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<h3 id="rust_log"><a class="header" href="#rust_log">RUST_LOG</a></h3>
<p>Control logging verbosity:</p>
<pre><code class="language-bash"># Show all logs
RUST_LOG=debug bsharp parse MyFile.cs

# Show only warnings and errors
RUST_LOG=warn bsharp analyze MyProject.csproj

# Show specific module logs
RUST_LOG=bsharp::parser=debug bsharp parse MyFile.cs
</code></pre>
<h3 id="rust_backtrace"><a class="header" href="#rust_backtrace">RUST_BACKTRACE</a></h3>
<p>Enable stack traces on panic:</p>
<pre><code class="language-bash">RUST_BACKTRACE=1 bsharp parse MyFile.cs
</code></pre>
<hr />
<h2 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h2>
<h3 id="large-files"><a class="header" href="#large-files">Large Files</a></h3>
<p>For large files (&gt; 10,000 lines), parsing may take several seconds:</p>
<pre><code class="language-bash"># Monitor progress with debug logging
RUST_LOG=info bsharp parse LargeFile.cs
</code></pre>
<h3 id="large-solutions"><a class="header" href="#large-solutions">Large Solutions</a></h3>
<p>For solutions with many projects, use parallel analysis:</p>
<pre><code class="language-bash"># Requires parallel_analysis feature
cargo build --release --features parallel_analysis
bsharp analyze LargeSolution.sln
</code></pre>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p>Memory usage scales with AST size. For very large codebases:</p>
<pre><code class="language-bash"># Analyze incrementally by project
for proj in **/*.csproj; do
    bsharp analyze "$proj" --out "$(basename $proj .csproj).json"
done
</code></pre>
<hr />
<h2 id="integration-with-other-tools"><a class="header" href="#integration-with-other-tools">Integration with Other Tools</a></h2>
<h3 id="cicd-pipeline"><a class="header" href="#cicd-pipeline">CI/CD Pipeline</a></h3>
<pre><code class="language-yaml"># GitHub Actions example
- name: Analyze Code Quality
  run: |
    bsharp analyze MySolution.sln --out analysis.json
    # Upload analysis.json as artifact
</code></pre>
<h3 id="pre-commit-hook"><a class="header" href="#pre-commit-hook">Pre-commit Hook</a></h3>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

changed_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.cs$')

for file in $changed_files; do
    if ! bsharp parse "$file" &gt; /dev/null 2&gt;&amp;1; then
        echo "Parse error in $file"
        exit 1
    fi
done
</code></pre>
<h3 id="editor-integration"><a class="header" href="#editor-integration">Editor Integration</a></h3>
<pre><code class="language-json">// VS Code tasks.json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Analyze Current File",
            "type": "shell",
            "command": "bsharp",
            "args": [
                "analyze",
                "${file}",
                "--out",
                "${file}.analysis.json"
            ]
        }
    ]
}
</code></pre>
<hr />
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="command-not-found"><a class="header" href="#command-not-found">Command Not Found</a></h3>
<pre><code class="language-bash">$ bsharp: command not found
</code></pre>
<p><strong>Solution:</strong> Add bsharp to PATH or use full path:</p>
<pre><code class="language-bash">/path/to/bsharp/target/release/bsharp parse MyFile.cs
</code></pre>
<h3 id="permission-denied"><a class="header" href="#permission-denied">Permission Denied</a></h3>
<pre><code class="language-bash">$ bsharp parse MyFile.cs
Permission denied
</code></pre>
<p><strong>Solution:</strong> Make binary executable:</p>
<pre><code class="language-bash">chmod +x /path/to/bsharp
</code></pre>
<h3 id="out-of-memory"><a class="header" href="#out-of-memory">Out of Memory</a></h3>
<pre><code class="language-bash">$ bsharp analyze HugeSolution.sln
Error: memory allocation failed
</code></pre>
<p><strong>Solution:</strong> Analyze smaller subsets or increase system memory</p>
<hr />
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h2>
<h3 id="analysis-configuration-1"><a class="header" href="#analysis-configuration-1">Analysis Configuration</a></h3>
<p>Create <code>.bsharp.toml</code> in project root:</p>
<pre><code class="language-toml">[analysis]
max_cyclomatic_complexity = 10
max_method_length = 50

[analysis.quality]
long_method = "warning"
god_class = "error"

[workspace]
follow_refs = true
include = ["**/*.cs"]
exclude = ["**/obj/**", "**/bin/**"]
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Automatically loads .bsharp.toml from current directory
bsharp analyze MyProject.csproj
</code></pre>
<hr />
<h2 id="shell-completion"><a class="header" href="#shell-completion">Shell Completion</a></h2>
<h3 id="bash"><a class="header" href="#bash">Bash</a></h3>
<pre><code class="language-bash"># Generate completion script
bsharp --generate-completion bash &gt; ~/.local/share/bash-completion/completions/bsharp

# Or add to .bashrc
eval "$(bsharp --generate-completion bash)"
</code></pre>
<h3 id="zsh"><a class="header" href="#zsh">Zsh</a></h3>
<pre><code class="language-bash"># Add to .zshrc
eval "$(bsharp --generate-completion zsh)"
</code></pre>
<h3 id="fish"><a class="header" href="#fish">Fish</a></h3>
<pre><code class="language-bash"># Add to config.fish
bsharp --generate-completion fish | source
</code></pre>
<hr />
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="example-1-quick-syntax-check"><a class="header" href="#example-1-quick-syntax-check">Example 1: Quick Syntax Check</a></h3>
<pre><code class="language-bash"># Check if all C# files in directory parse correctly
find . -name "*.cs" -exec bsharp parse {} \; 2&gt;&amp;1 | grep -i error
</code></pre>
<h3 id="example-2-generate-documentation"><a class="header" href="#example-2-generate-documentation">Example 2: Generate Documentation</a></h3>
<pre><code class="language-bash"># Parse all files and extract class/method names
for file in src/**/*.cs; do
    bsharp parse "$file" --output "${file}.json"
done

# Process JSON to generate documentation
# (custom script)
</code></pre>
<h3 id="example-3-code-quality-gate"><a class="header" href="#example-3-code-quality-gate">Example 3: Code Quality Gate</a></h3>
<pre><code class="language-bash">#!/bin/bash
# quality-gate.sh

bsharp analyze MyProject.csproj --out report.json --format json

# Extract error count
errors=$(jq '.diagnostics | map(select(.severity == "error")) | length' report.json)

if [ "$errors" -gt 0 ]; then
    echo "Quality gate failed: $errors errors found"
    exit 1
fi

echo "Quality gate passed"
</code></pre>
<h3 id="example-4-complexity-report"><a class="header" href="#example-4-complexity-report">Example 4: Complexity Report</a></h3>
<pre><code class="language-bash"># Generate complexity report for all methods
bsharp analyze MySolution.sln --out complexity.json

# Extract high-complexity methods
jq '.diagnostics | map(select(.code == "MET001"))' complexity.json
</code></pre>
<hr />
<h2 id="cli-architecture"><a class="header" href="#cli-architecture">CLI Architecture</a></h2>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<p><strong>Location:</strong> <code>src/cli/</code></p>
<pre><code>src/cli/
├── mod.rs              # CLI entry point, clap definitions
└── commands/
    ├── mod.rs          # Command module exports
    ├── parse.rs        # Parse command implementation
    ├── tree.rs         # Tree visualization command
    ├── compile.rs      # Compilation command
    └── analyze.rs      # Analysis command
</code></pre>
<h3 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h3>
<p>Each command follows this pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute(input: PathBuf, /* other args */) -&gt; Result&lt;()&gt; {
    // 1. Validate input
    // 2. Load/parse files
    // 3. Perform operation
    // 4. Generate output
    // 5. Handle errors
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="future-enhancements-3"><a class="header" href="#future-enhancements-3">Future Enhancements</a></h2>
<h3 id="planned-features-3"><a class="header" href="#planned-features-3">Planned Features</a></h3>
<ol>
<li>
<p><strong>Interactive Mode</strong></p>
<ul>
<li>REPL for exploring AST</li>
<li>Interactive analysis</li>
</ul>
</li>
<li>
<p><strong>Watch Mode</strong></p>
<ul>
<li>Monitor files for changes</li>
<li>Re-analyze on save</li>
</ul>
</li>
<li>
<p><strong>Language Server</strong></p>
<ul>
<li>LSP implementation</li>
<li>IDE integration</li>
</ul>
</li>
<li>
<p><strong>Web Interface</strong></p>
<ul>
<li>Browser-based visualization</li>
<li>Interactive reports</li>
</ul>
</li>
</ol>
<hr />
<h2 id="related-documentation-5"><a class="header" href="#related-documentation-5">Related Documentation</a></h2>
<ul>
<li><a href="cli/./parse.html">Parse Command</a> - Detailed parse command documentation</li>
<li><a href="cli/./tree.html">Tree Visualization</a> - AST visualization</li>
<li><a href="cli/./compile.html">Compilation</a> - Compilation process</li>
<li><a href="cli/../analysis/pipeline.html">Analysis Pipeline</a> - Analysis internals</li>
</ul>
<hr />
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/cli/</code></li>
<li><strong>Commands:</strong> <code>src/cli/commands/</code></li>
<li><strong>Clap Documentation:</strong> https://docs.rs/clap/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parse-command"><a class="header" href="#parse-command">Parse Command</a></h1>
<p>The <code>parse</code> command parses C# source code and outputs a JSON representation of the Abstract Syntax Tree (AST).</p>
<hr />
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-bash">bsharp parse &lt;INPUT&gt; [--output &lt;FILE&gt;]
</code></pre>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to C# source file</li>
<li>Must have <code>.cs</code> extension</li>
<li>File must exist and be readable</li>
</ul>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p><strong><code>--output, -o &lt;FILE&gt;</code></strong> (optional)</p>
<ul>
<li>Output file path for JSON</li>
<li>Default: <code>&lt;input&gt;.json</code></li>
<li>Creates parent directories if needed</li>
</ul>
<hr />
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="basic-parsing"><a class="header" href="#basic-parsing">Basic Parsing</a></h3>
<pre><code class="language-bash"># Parse and output to default file (Program.cs.json)
bsharp parse Program.cs

# Parse and specify output file
bsharp parse Program.cs --output ast.json

# Parse and output to stdout (if no --output specified and stdout is not a TTY)
bsharp parse Program.cs
</code></pre>
<h3 id="batch-parsing"><a class="header" href="#batch-parsing">Batch Parsing</a></h3>
<pre><code class="language-bash"># Parse all C# files in directory
for file in src/**/*.cs; do
    bsharp parse "$file" --output "parsed/$(basename $file .cs).json"
done
</code></pre>
<hr />
<h2 id="output-format"><a class="header" href="#output-format">Output Format</a></h2>
<h3 id="json-structure"><a class="header" href="#json-structure">JSON Structure</a></h3>
<pre><code class="language-json">{
  "global_attributes": [],
  "using_directives": [
    {
      "namespace": "System"
    }
  ],
  "declarations": [
    {
      "Class": {
        "attributes": [],
        "modifiers": ["Public"],
        "identifier": {
          "name": "Program"
        },
        "type_parameters": null,
        "base_types": [],
        "body_declarations": [
          {
            "Method": {
              "attributes": [],
              "modifiers": ["Public", "Static"],
              "return_type": {
                "Primitive": "Void"
              },
              "identifier": {
                "name": "Main"
              },
              "parameters": [],
              "body": {
                "Block": []
              }
            }
          }
        ]
      }
    }
  ],
  "file_scoped_namespace": null,
  "top_level_statements": []
}
</code></pre>
<h3 id="ast-node-structure"><a class="header" href="#ast-node-structure">AST Node Structure</a></h3>
<p>All AST nodes follow the naming convention:</p>
<ul>
<li><strong>PascalCase</strong> names</li>
<li><strong>No 'Syntax' suffix</strong></li>
<li>Descriptive names indicating C# construct</li>
</ul>
<p>Examples:</p>
<ul>
<li><code>ClassDeclaration</code> (not <code>ClassDeclarationSyntax</code>)</li>
<li><code>MethodDeclaration</code> (not <code>MethodDeclarationSyntax</code>)</li>
<li><code>IfStatement</code> (not <code>IfStatementSyntax</code>)</li>
</ul>
<hr />
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<h3 id="parse-errors-1"><a class="header" href="#parse-errors-1">Parse Errors</a></h3>
<pre><code class="language-bash">$ bsharp parse InvalidSyntax.cs
Error: Parse failed

0: at line 5, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"

1: in context "class declaration"
</code></pre>
<p><strong>Error Information:</strong></p>
<ul>
<li>Line and column numbers</li>
<li>Context stack showing where parsing failed</li>
<li>Expected vs. actual input</li>
<li>Helpful error messages</li>
</ul>
<h3 id="file-errors"><a class="header" href="#file-errors">File Errors</a></h3>
<pre><code class="language-bash">$ bsharp parse NonExistent.cs
Error: Failed to read file: NonExistent.cs
Caused by: No such file or directory (os error 2)
</code></pre>
<hr />
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="1-syntax-validation"><a class="header" href="#1-syntax-validation">1. Syntax Validation</a></h3>
<pre><code class="language-bash"># Check if file has valid syntax
if bsharp parse MyFile.cs &gt; /dev/null 2&gt;&amp;1; then
    echo "Syntax OK"
else
    echo "Syntax Error"
    exit 1
fi
</code></pre>
<h3 id="2-ast-inspection"><a class="header" href="#2-ast-inspection">2. AST Inspection</a></h3>
<pre><code class="language-bash"># Parse and inspect AST structure
bsharp parse MyClass.cs --output ast.json
jq '.declarations[0].Class.identifier.name' ast.json
</code></pre>
<h3 id="3-code-generation-input"><a class="header" href="#3-code-generation-input">3. Code Generation Input</a></h3>
<pre><code class="language-bash"># Parse C# and generate documentation
bsharp parse MyFile.cs --output ast.json
python generate_docs.py ast.json &gt; docs.md
</code></pre>
<h3 id="4-static-analysis"><a class="header" href="#4-static-analysis">4. Static Analysis</a></h3>
<pre><code class="language-bash"># Parse and analyze with custom tool
bsharp parse MyFile.cs --output ast.json
./my-analyzer ast.json
</code></pre>
<hr />
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="parsing-speed"><a class="header" href="#parsing-speed">Parsing Speed</a></h3>
<ul>
<li><strong>Small files</strong> (&lt; 100 lines): &lt; 10ms</li>
<li><strong>Medium files</strong> (100-1000 lines): 10-100ms</li>
<li><strong>Large files</strong> (1000-10000 lines): 100ms-1s</li>
<li><strong>Very large files</strong> (&gt; 10000 lines): 1-10s</li>
</ul>
<h3 id="memory-usage-1"><a class="header" href="#memory-usage-1">Memory Usage</a></h3>
<ul>
<li>Memory usage scales linearly with file size</li>
<li>Typical: 1-5 MB per 1000 lines of code</li>
<li>Peak memory during AST construction</li>
</ul>
<hr />
<h2 id="integration-1"><a class="header" href="#integration-1">Integration</a></h2>
<h3 id="cicd-pipeline-1"><a class="header" href="#cicd-pipeline-1">CI/CD Pipeline</a></h3>
<pre><code class="language-yaml"># GitHub Actions
- name: Validate C# Syntax
  run: |
    find . -name "*.cs" | while read file; do
      bsharp parse "$file" || exit 1
    done
</code></pre>
<h3 id="pre-commit-hook-1"><a class="header" href="#pre-commit-hook-1">Pre-commit Hook</a></h3>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

git diff --cached --name-only --diff-filter=ACM | grep '\.cs$' | while read file; do
    if ! bsharp parse "$file" &gt; /dev/null 2&gt;&amp;1; then
        echo "Parse error in $file"
        exit 1
    fi
done
</code></pre>
<h3 id="build-script"><a class="header" href="#build-script">Build Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# validate-syntax.sh

errors=0
for file in src/**/*.cs; do
    if ! bsharp parse "$file" &gt; /dev/null 2&gt;&amp;1; then
        echo "ERROR: $file"
        ((errors++))
    fi
done

if [ $errors -gt 0 ]; then
    echo "Found $errors files with syntax errors"
    exit 1
fi
</code></pre>
<hr />
<h2 id="comparison-with-other-tools"><a class="header" href="#comparison-with-other-tools">Comparison with Other Tools</a></h2>
<h3 id="vs-roslyn"><a class="header" href="#vs-roslyn">vs. Roslyn</a></h3>
<ul>
<li><strong>BSharp:</strong> Fast, standalone, JSON output</li>
<li><strong>Roslyn:</strong> Full compiler, .NET required, complex API</li>
</ul>
<h3 id="vs-tree-sitter"><a class="header" href="#vs-tree-sitter">vs. Tree-sitter</a></h3>
<ul>
<li><strong>BSharp:</strong> C#-specific, complete AST</li>
<li><strong>Tree-sitter:</strong> Multi-language, syntax tree only</li>
</ul>
<hr />
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p><strong>Location:</strong> <code>src/cli/commands/parse.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute(input: PathBuf, output: Option&lt;PathBuf&gt;) -&gt; Result&lt;()&gt; {
    // 1. Read source file
    let source = fs::read_to_string(&amp;input)?;
    
    // 2. Parse with BSharp parser
    let parser = Parser::new();
    let cu = parser.parse(&amp;source)
        .map_err(|e| anyhow!("Parse failed: {}", e))?;
    
    // 3. Serialize to JSON
    let json = serde_json::to_string_pretty(&amp;cu)?;
    
    // 4. Write output
    let output_path = output.unwrap_or_else(|| {
        let mut p = input.clone();
        p.set_extension("cs.json");
        p
    });
    
    fs::write(&amp;output_path, json)?;
    
    println!("Parsed successfully: {}", output_path.display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation-6"><a class="header" href="#related-documentation-6">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a> - General CLI usage</li>
<li><a href="cli/./tree.html">Tree Visualization</a> - Visualize parsed AST</li>
<li><a href="cli/../parser/ast-structure.html">AST Structure</a> - AST node reference</li>
<li><a href="cli/../parser/error-handling.html">Error Handling</a> - Parse error details</li>
</ul>
<hr />
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/cli/commands/parse.rs</code></li>
<li><strong>Parser:</strong> <code>src/parser/</code></li>
<li><strong>AST Definitions:</strong> <code>src/syntax/nodes/</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-visualization-command"><a class="header" href="#tree-visualization-command">Tree Visualization Command</a></h1>
<p>The <code>tree</code> command generates an SVG visualization of the Abstract Syntax Tree (AST) from C# source code.</p>
<hr />
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-bash">bsharp tree &lt;INPUT&gt; [--output &lt;FILE&gt;]
</code></pre>
<h3 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to C# source file</li>
<li>Must have <code>.cs</code> extension</li>
</ul>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<p><strong><code>--output, -o &lt;FILE&gt;</code></strong> (optional)</p>
<ul>
<li>Output SVG file path</li>
<li>Default: <code>&lt;input&gt;.svg</code></li>
</ul>
<hr />
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="basic-visualization"><a class="header" href="#basic-visualization">Basic Visualization</a></h3>
<pre><code class="language-bash"># Generate AST visualization
bsharp tree Program.cs

# Specify output file
bsharp tree Program.cs --output ast-diagram.svg
</code></pre>
<h3 id="view-in-browser"><a class="header" href="#view-in-browser">View in Browser</a></h3>
<pre><code class="language-bash"># Generate and open in browser
bsharp tree MyClass.cs --output diagram.svg
open diagram.svg  # macOS
xdg-open diagram.svg  # Linux
start diagram.svg  # Windows
</code></pre>
<hr />
<h2 id="output-format-1"><a class="header" href="#output-format-1">Output Format</a></h2>
<h3 id="svg-structure"><a class="header" href="#svg-structure">SVG Structure</a></h3>
<p>The generated SVG contains:</p>
<ul>
<li><strong>Tree layout</strong> - Hierarchical node arrangement</li>
<li><strong>Node boxes</strong> - AST node types and names</li>
<li><strong>Connecting lines</strong> - Parent-child relationships</li>
<li><strong>Color coding</strong> - Different colors for node types</li>
</ul>
<h3 id="example-output-2"><a class="header" href="#example-output-2">Example Output</a></h3>
<pre><code class="language-svg">&lt;svg width="800" height="600"&gt;
  &lt;!-- CompilationUnit at root --&gt;
  &lt;rect x="400" y="20" width="120" height="40" fill="#e0e0e0"/&gt;
  &lt;text x="460" y="45"&gt;CompilationUnit&lt;/text&gt;
  
  &lt;!-- ClassDeclaration --&gt;
  &lt;line x1="460" y1="60" x2="460" y2="100"/&gt;
  &lt;rect x="400" y="100" width="120" height="40" fill="#90caf9"/&gt;
  &lt;text x="460" y="125"&gt;ClassDeclaration&lt;/text&gt;
  &lt;text x="460" y="140" font-size="10"&gt;Program&lt;/text&gt;
  
  &lt;!-- MethodDeclaration --&gt;
  &lt;line x1="460" y1="140" x2="460" y2="180"/&gt;
  &lt;rect x="400" y="180" width="120" height="40" fill="#a5d6a7"/&gt;
  &lt;text x="460" y="205"&gt;MethodDeclaration&lt;/text&gt;
  &lt;text x="460" y="220" font-size="10"&gt;Main&lt;/text&gt;
&lt;/svg&gt;
</code></pre>
<h3 id="color-scheme"><a class="header" href="#color-scheme">Color Scheme</a></h3>
<ul>
<li><strong>Gray</strong> - Root nodes (CompilationUnit)</li>
<li><strong>Blue</strong> - Type declarations (Class, Interface, Struct)</li>
<li><strong>Green</strong> - Member declarations (Method, Property, Field)</li>
<li><strong>Yellow</strong> - Statements (If, For, While)</li>
<li><strong>Orange</strong> - Expressions (Binary, Invocation)</li>
<li><strong>Purple</strong> - Types (Primitive, Named, Generic)</li>
</ul>
<hr />
<h2 id="visualization-features"><a class="header" href="#visualization-features">Visualization Features</a></h2>
<h3 id="node-information"><a class="header" href="#node-information">Node Information</a></h3>
<p>Each node displays:</p>
<ul>
<li><strong>Node Type</strong> - AST node type name</li>
<li><strong>Identifier</strong> - Name (for named nodes)</li>
<li><strong>Additional Info</strong> - Modifiers, types, etc.</li>
</ul>
<h3 id="tree-layout"><a class="header" href="#tree-layout">Tree Layout</a></h3>
<ul>
<li><strong>Top-down</strong> - Root at top, leaves at bottom</li>
<li><strong>Hierarchical</strong> - Parent-child relationships clear</li>
<li><strong>Balanced</strong> - Nodes distributed evenly</li>
<li><strong>Scalable</strong> - Adjusts to tree size</li>
</ul>
<hr />
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="1-understanding-code-structure"><a class="header" href="#1-understanding-code-structure">1. Understanding Code Structure</a></h3>
<pre><code class="language-bash"># Visualize complex class
bsharp tree ComplexClass.cs --output structure.svg
</code></pre>
<h3 id="2-teachingdocumentation"><a class="header" href="#2-teachingdocumentation">2. Teaching/Documentation</a></h3>
<pre><code class="language-bash"># Generate diagrams for documentation
bsharp tree Example.cs --output docs/ast-example.svg
</code></pre>
<h3 id="3-debugging-parser"><a class="header" href="#3-debugging-parser">3. Debugging Parser</a></h3>
<pre><code class="language-bash"># Verify parser output
bsharp tree TestCase.cs --output debug.svg
</code></pre>
<h3 id="4-code-review"><a class="header" href="#4-code-review">4. Code Review</a></h3>
<pre><code class="language-bash"># Visualize changes
bsharp tree NewFeature.cs --output review.svg
</code></pre>
<hr />
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="large-files-1"><a class="header" href="#large-files-1">Large Files</a></h3>
<ul>
<li>Files &gt; 1000 lines may produce very large SVGs</li>
<li>Consider visualizing specific classes/methods only</li>
</ul>
<h3 id="complex-nesting"><a class="header" href="#complex-nesting">Complex Nesting</a></h3>
<ul>
<li>Deeply nested structures may be hard to read</li>
<li>SVG may require horizontal scrolling</li>
</ul>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<ul>
<li>Generation time increases with AST size</li>
<li>Large files (&gt; 5000 lines) may take several seconds</li>
</ul>
<hr />
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="selective-visualization"><a class="header" href="#selective-visualization">Selective Visualization</a></h3>
<pre><code class="language-bash"># Extract specific class and visualize
# (requires custom script to extract class)
extract-class.sh MyFile.cs MyClass &gt; temp.cs
bsharp tree temp.cs --output MyClass-ast.svg
rm temp.cs
</code></pre>
<h3 id="batch-generation"><a class="header" href="#batch-generation">Batch Generation</a></h3>
<pre><code class="language-bash"># Generate visualizations for all files
for file in src/**/*.cs; do
    output="diagrams/$(basename $file .cs).svg"
    bsharp tree "$file" --output "$output"
done
</code></pre>
<h3 id="integration-with-documentation"><a class="header" href="#integration-with-documentation">Integration with Documentation</a></h3>
<pre><code class="language-markdown"># MyClass Documentation

## AST Structure

![AST Diagram](./diagrams/MyClass.svg)

The class structure shows...
</code></pre>
<hr />
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p><strong>Location:</strong> <code>src/cli/commands/tree.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute(input: PathBuf, output: Option&lt;PathBuf&gt;) -&gt; Result&lt;()&gt; {
    // 1. Parse source file
    let source = fs::read_to_string(&amp;input)?;
    let parser = Parser::new();
    let cu = parser.parse(&amp;source)?;
    
    // 2. Generate SVG from AST
    let svg = generate_svg_tree(&amp;cu)?;
    
    // 3. Write output
    let output_path = output.unwrap_or_else(|| {
        let mut p = input.clone();
        p.set_extension("svg");
        p
    });
    
    fs::write(&amp;output_path, svg)?;
    
    println!("Generated tree: {}", output_path.display());
    Ok(())
}

fn generate_svg_tree(cu: &amp;CompilationUnit) -&gt; Result&lt;String&gt; {
    let mut builder = SvgBuilder::new();
    
    // Build tree structure
    let root = build_tree_node(cu);
    
    // Calculate layout
    let layout = calculate_layout(&amp;root);
    
    // Render to SVG
    builder.render_tree(&amp;root, &amp;layout);
    
    Ok(builder.to_string())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="customization"><a class="header" href="#customization">Customization</a></h2>
<h3 id="future-enhancements-4"><a class="header" href="#future-enhancements-4">Future Enhancements</a></h3>
<ol>
<li>
<p><strong>Interactive SVG</strong></p>
<ul>
<li>Click to expand/collapse nodes</li>
<li>Hover for details</li>
<li>Search functionality</li>
</ul>
</li>
<li>
<p><strong>Export Formats</strong></p>
<ul>
<li>PNG/PDF export</li>
<li>DOT format for Graphviz</li>
<li>PlantUML format</li>
</ul>
</li>
<li>
<p><strong>Filtering</strong></p>
<ul>
<li>Show only specific node types</li>
<li>Hide implementation details</li>
<li>Focus on structure</li>
</ul>
</li>
<li>
<p><strong>Styling</strong></p>
<ul>
<li>Custom color schemes</li>
<li>Font customization</li>
<li>Layout options</li>
</ul>
</li>
</ol>
<hr />
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="svg-too-large"><a class="header" href="#svg-too-large">SVG Too Large</a></h3>
<p><strong>Problem:</strong> Generated SVG is too large to view</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Visualize smaller code sections</li>
<li>Use SVG viewer with zoom/pan</li>
<li>Export to PDF for printing</li>
</ul>
<h3 id="overlapping-nodes"><a class="header" href="#overlapping-nodes">Overlapping Nodes</a></h3>
<p><strong>Problem:</strong> Nodes overlap in complex trees</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Increase SVG dimensions</li>
<li>Simplify code structure</li>
<li>Use horizontal layout (future feature)</li>
</ul>
<h3 id="missing-nodes"><a class="header" href="#missing-nodes">Missing Nodes</a></h3>
<p><strong>Problem:</strong> Some AST nodes not shown</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check parser output with <code>parse</code> command</li>
<li>Report issue if nodes are missing</li>
</ul>
<hr />
<h2 id="related-documentation-7"><a class="header" href="#related-documentation-7">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a> - General CLI usage</li>
<li><a href="cli/./parse.html">Parse Command</a> - Parse to JSON</li>
<li><a href="cli/../parser/ast-structure.html">AST Structure</a> - AST node reference</li>
</ul>
<hr />
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/cli/commands/tree.rs</code></li>
<li><strong>SVG Generation:</strong> Uses <code>svg</code> crate</li>
<li><strong>Layout Algorithm:</strong> Tree layout algorithm</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation-command"><a class="header" href="#compilation-command">Compilation Command</a></h1>
<p>The <code>compile</code> command compiles C# source code to native binary using the Cranelift backend.</p>
<hr />
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-bash">bsharp compile &lt;INPUT&gt;
</code></pre>
<h3 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to C# source file</li>
<li>Must have <code>.cs</code> extension</li>
</ul>
<hr />
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="basic-compilation"><a class="header" href="#basic-compilation">Basic Compilation</a></h3>
<pre><code class="language-bash"># Compile C# file
bsharp compile Program.cs

# Output: Program (executable)
</code></pre>
<h3 id="compilation-process"><a class="header" href="#compilation-process">Compilation Process</a></h3>
<pre><code class="language-bash">$ bsharp compile HelloWorld.cs
Parsing...
Generating IR...
Compiling...
Linking...
Successfully compiled: HelloWorld
</code></pre>
<hr />
<h2 id="compilation-pipeline"><a class="header" href="#compilation-pipeline">Compilation Pipeline</a></h2>
<h3 id="1-parsing"><a class="header" href="#1-parsing">1. Parsing</a></h3>
<p>Parse C# source code to AST:</p>
<pre><code>HelloWorld.cs → AST (CompilationUnit)
</code></pre>
<h3 id="2-ir-generation"><a class="header" href="#2-ir-generation">2. IR Generation</a></h3>
<p>Generate intermediate representation:</p>
<pre><code>AST → Cranelift IR
</code></pre>
<h3 id="3-code-generation"><a class="header" href="#3-code-generation">3. Code Generation</a></h3>
<p>Compile IR to machine code:</p>
<pre><code>Cranelift IR → Native Code
</code></pre>
<h3 id="4-linking"><a class="header" href="#4-linking">4. Linking</a></h3>
<p>Link with runtime and produce executable:</p>
<pre><code>Native Code + Runtime → Executable
</code></pre>
<hr />
<h2 id="supported-features"><a class="header" href="#supported-features">Supported Features</a></h2>
<h3 id="currently-supported"><a class="header" href="#currently-supported">Currently Supported</a></h3>
<ul>
<li>Basic types (int, bool, string)</li>
<li>Simple expressions</li>
<li>Method declarations</li>
<li>Control flow (if, while, for)</li>
<li>Function calls</li>
</ul>
<h3 id="planned-support"><a class="header" href="#planned-support">Planned Support</a></h3>
<ul>
<li>Classes and objects</li>
<li>Inheritance</li>
<li>Generics</li>
<li>LINQ</li>
<li>Async/await</li>
<li>Full .NET BCL integration</li>
</ul>
<hr />
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<h3 id="executable-format"><a class="header" href="#executable-format">Executable Format</a></h3>
<ul>
<li><strong>Linux:</strong> ELF binary</li>
<li><strong>macOS:</strong> Mach-O binary</li>
<li><strong>Windows:</strong> PE executable</li>
</ul>
<h3 id="output-location"><a class="header" href="#output-location">Output Location</a></h3>
<p>Default: Same directory as input, without extension</p>
<pre><code>Program.cs → Program
</code></pre>
<hr />
<h2 id="implementation-status-2"><a class="header" href="#implementation-status-2">Implementation Status</a></h2>
<h3 id="current-state"><a class="header" href="#current-state">Current State</a></h3>
<p><strong>Status:</strong> ⚠️ <strong>Experimental</strong> - Basic compilation infrastructure in place</p>
<p><strong>What Works:</strong></p>
<ul>
<li>Parsing C# to AST</li>
<li>Basic IR generation</li>
<li>Simple code generation with Cranelift</li>
</ul>
<p><strong>What Doesn't Work Yet:</strong></p>
<ul>
<li>Full C# language support</li>
<li>.NET runtime integration</li>
<li>Standard library</li>
<li>Complex types and generics</li>
</ul>
<h3 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h3>
<p><strong>Location:</strong> <code>src/compiler.rs</code>, <code>src/codegen/</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Compiler {
    // Cranelift components
    module: ObjectModule,
    context: Context,
}

impl Compiler {
    pub fn compile(&amp;mut self, cu: &amp;CompilationUnit) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // 1. Generate Cranelift IR from AST
        let ir = self.generate_ir(cu)?;
        
        // 2. Compile IR to machine code
        let code = self.compile_ir(ir)?;
        
        // 3. Link and produce executable
        let binary = self.link(code)?;
        
        Ok(binary)
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="cranelift-backend"><a class="header" href="#cranelift-backend">Cranelift Backend</a></h2>
<h3 id="why-cranelift"><a class="header" href="#why-cranelift">Why Cranelift?</a></h3>
<ul>
<li><strong>Fast Compilation:</strong> Optimized for quick compilation</li>
<li><strong>Portable:</strong> Cross-platform code generation</li>
<li><strong>Rust Integration:</strong> Well-integrated with Rust ecosystem</li>
<li><strong>Simpler than LLVM:</strong> Easier to integrate initially</li>
</ul>
<h3 id="cranelift-ir-example"><a class="header" href="#cranelift-ir-example">Cranelift IR Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// C# code:
// int Add(int a, int b) { return a + b; }

// Cranelift IR:
function u0:0(i32, i32) -&gt; i32 {
block0(v0: i32, v1: i32):
    v2 = iadd v0, v1
    return v2
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<h3 id="language-features"><a class="header" href="#language-features">Language Features</a></h3>
<p><strong>Not Yet Supported:</strong></p>
<ul>
<li>Classes and objects</li>
<li>Inheritance and polymorphism</li>
<li>Generics</li>
<li>LINQ</li>
<li>Async/await</li>
<li>Exceptions</li>
<li>Garbage collection</li>
<li>Most of .NET BCL</li>
</ul>
<h3 id="performance-2"><a class="header" href="#performance-2">Performance</a></h3>
<ul>
<li>No advanced optimizations yet</li>
<li>Basic code generation only</li>
<li>Runtime performance not optimized</li>
</ul>
<h3 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h3>
<ul>
<li>Tested primarily on Linux x86_64</li>
<li>macOS and Windows support experimental</li>
</ul>
<hr />
<h2 id="use-cases-3"><a class="header" href="#use-cases-3">Use Cases</a></h2>
<h3 id="current-use-cases"><a class="header" href="#current-use-cases">Current Use Cases</a></h3>
<ol>
<li>
<p><strong>Experimentation</strong></p>
<ul>
<li>Test compilation pipeline</li>
<li>Explore Cranelift integration</li>
</ul>
</li>
<li>
<p><strong>Simple Programs</strong></p>
<ul>
<li>Basic algorithms</li>
<li>Mathematical computations</li>
<li>Simple CLI tools</li>
</ul>
</li>
</ol>
<h3 id="future-use-cases"><a class="header" href="#future-use-cases">Future Use Cases</a></h3>
<ol>
<li>
<p><strong>Full C# Compilation</strong></p>
<ul>
<li>Complete C# language support</li>
<li>.NET compatibility</li>
</ul>
</li>
<li>
<p><strong>AOT Compilation</strong></p>
<ul>
<li>Ahead-of-time compilation for .NET apps</li>
<li>Native binaries without runtime</li>
</ul>
</li>
<li>
<p><strong>Embedded Systems</strong></p>
<ul>
<li>Compile C# for embedded targets</li>
<li>No runtime overhead</li>
</ul>
</li>
</ol>
<hr />
<h2 id="comparison-with-other-compilers"><a class="header" href="#comparison-with-other-compilers">Comparison with Other Compilers</a></h2>
<h3 id="vs-roslyn-csc"><a class="header" href="#vs-roslyn-csc">vs. Roslyn (csc)</a></h3>
<ul>
<li><strong>Roslyn:</strong> Mature, complete, targets IL</li>
<li><strong>BSharp:</strong> Experimental, targets native code</li>
</ul>
<h3 id="vs-corertnativeaot"><a class="header" href="#vs-corertnativeaot">vs. CoreRT/NativeAOT</a></h3>
<ul>
<li><strong>CoreRT:</strong> Full .NET, production-ready</li>
<li><strong>BSharp:</strong> Simpler, learning project</li>
</ul>
<h3 id="vs-il2cpp"><a class="header" href="#vs-il2cpp">vs. IL2CPP</a></h3>
<ul>
<li><strong>IL2CPP:</strong> Unity's solution, IL → C++ → native</li>
<li><strong>BSharp:</strong> Direct C# → native</li>
</ul>
<hr />
<h2 id="development-roadmap"><a class="header" href="#development-roadmap">Development Roadmap</a></h2>
<h3 id="phase-1-foundation-current"><a class="header" href="#phase-1-foundation-current">Phase 1: Foundation (Current)</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Basic parser</li>
<li><input disabled="" type="checkbox" checked=""/>
Cranelift integration</li>
<li><input disabled="" type="checkbox" checked=""/>
Simple IR generation</li>
<li><input disabled="" type="checkbox"/>
Basic type system</li>
</ul>
<h3 id="phase-2-core-language"><a class="header" href="#phase-2-core-language">Phase 2: Core Language</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Classes and objects</li>
<li><input disabled="" type="checkbox"/>
Methods and properties</li>
<li><input disabled="" type="checkbox"/>
Inheritance</li>
<li><input disabled="" type="checkbox"/>
Basic generics</li>
</ul>
<h3 id="phase-3-advanced-features"><a class="header" href="#phase-3-advanced-features">Phase 3: Advanced Features</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Full generics support</li>
<li><input disabled="" type="checkbox"/>
LINQ</li>
<li><input disabled="" type="checkbox"/>
Async/await</li>
<li><input disabled="" type="checkbox"/>
Exception handling</li>
</ul>
<h3 id="phase-4-runtime-integration"><a class="header" href="#phase-4-runtime-integration">Phase 4: Runtime Integration</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Garbage collector</li>
<li><input disabled="" type="checkbox"/>
.NET BCL bindings</li>
<li><input disabled="" type="checkbox"/>
Interop with C#/IL</li>
</ul>
<hr />
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<h3 id="how-to-help"><a class="header" href="#how-to-help">How to Help</a></h3>
<ol>
<li>
<p><strong>Test Compilation</strong></p>
<ul>
<li>Try compiling simple C# programs</li>
<li>Report issues</li>
</ul>
</li>
<li>
<p><strong>Implement Features</strong></p>
<ul>
<li>Pick a language feature</li>
<li>Implement IR generation</li>
<li>Add tests</li>
</ul>
</li>
<li>
<p><strong>Optimize</strong></p>
<ul>
<li>Profile generated code</li>
<li>Implement optimizations</li>
<li>Benchmark improvements</li>
</ul>
</li>
</ol>
<h3 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h3>
<pre><code class="language-bash"># Clone repository
git clone https://github.com/your-repo/bsharp.git
cd bsharp

# Build with Cranelift
cargo build --release

# Test compilation
cargo run -- compile examples/simple.cs

# Run tests
cargo test
</code></pre>
<hr />
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="compilation-fails"><a class="header" href="#compilation-fails">Compilation Fails</a></h3>
<pre><code class="language-bash">$ bsharp compile MyProgram.cs
Error: Unsupported feature: classes
</code></pre>
<p><strong>Solution:</strong> Check supported features list above</p>
<h3 id="generated-binary-crashes"><a class="header" href="#generated-binary-crashes">Generated Binary Crashes</a></h3>
<pre><code class="language-bash">$ ./MyProgram
Segmentation fault
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Compilation is experimental</li>
<li>Report issue with minimal reproduction</li>
<li>Check for unsupported features</li>
</ul>
<h3 id="linking-errors"><a class="header" href="#linking-errors">Linking Errors</a></h3>
<pre><code class="language-bash">Error: Failed to link: undefined symbol
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Runtime integration incomplete</li>
<li>Some features require runtime support</li>
</ul>
<hr />
<h2 id="related-documentation-8"><a class="header" href="#related-documentation-8">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a> - General CLI usage</li>
<li><a href="cli/./parse.html">Parse Command</a> - Parse C# to AST</li>
<li><a href="cli/../development/architecture.html">Architecture</a> - Compiler design</li>
</ul>
<hr />
<h2 id="references-8"><a class="header" href="#references-8">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/compiler.rs</code>, <code>src/codegen/</code></li>
<li><strong>Cranelift:</strong> https://cranelift.dev/</li>
<li><strong>Dependencies:</strong> See <code>Cargo.toml</code> for Cranelift crates</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analyze-command"><a class="header" href="#analyze-command">Analyze Command</a></h1>
<p>The <code>analyze</code> command performs comprehensive code analysis on C# files, projects, or solutions, generating detailed reports with diagnostics, metrics, and quality assessments.</p>
<hr />
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><code class="language-bash">bsharp analyze &lt;INPUT&gt; [OPTIONS]
</code></pre>
<h3 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to C# source file (<code>.cs</code>)</li>
<li>Path to project file (<code>.csproj</code>)</li>
<li>Path to solution file (<code>.sln</code>)</li>
<li>Path to directory</li>
</ul>
<hr />
<h2 id="options-2"><a class="header" href="#options-2">Options</a></h2>
<h3 id="output-options"><a class="header" href="#output-options">Output Options</a></h3>
<p><strong><code>--out &lt;FILE&gt;</code></strong></p>
<ul>
<li>Output file path for analysis report (JSON)</li>
<li>Default: stdout</li>
<li>Creates parent directories if needed</li>
</ul>
<p><strong><code>--format &lt;FORMAT&gt;</code></strong></p>
<ul>
<li>Output format: <code>json</code> (compact) or <code>pretty-json</code> (indented)</li>
<li>Default: <code>pretty-json</code></li>
</ul>
<h3 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h3>
<p><strong><code>--config &lt;FILE&gt;</code></strong></p>
<ul>
<li>Path to analysis configuration file (JSON or TOML)</li>
<li>Overrides default settings</li>
<li>CLI flags override config file settings</li>
</ul>
<h3 id="workspace-options"><a class="header" href="#workspace-options">Workspace Options</a></h3>
<p><strong><code>--follow-refs &lt;BOOL&gt;</code></strong></p>
<ul>
<li>Follow ProjectReference dependencies transitively</li>
<li>Default: <code>true</code></li>
<li>Set to <code>false</code> to analyze only specified project</li>
</ul>
<p><strong><code>--include &lt;GLOB&gt;...</code></strong></p>
<ul>
<li>Include only files matching glob patterns</li>
<li>Multiple patterns allowed</li>
<li>Example: <code>--include "**/*Service.cs" "**/*Controller.cs"</code></li>
</ul>
<p><strong><code>--exclude &lt;GLOB&gt;...</code></strong></p>
<ul>
<li>Exclude files matching glob patterns</li>
<li>Multiple patterns allowed</li>
<li>Example: <code>--exclude "**/obj/**" "**/bin/**" "**/Tests/**"</code></li>
</ul>
<h3 id="analysis-control"><a class="header" href="#analysis-control">Analysis Control</a></h3>
<p><strong><code>--enable-ruleset &lt;ID&gt;...</code></strong></p>
<ul>
<li>Enable specific rulesets by ID</li>
<li>Multiple IDs allowed</li>
<li>Overrides config file</li>
<li>Example: <code>--enable-ruleset naming quality</code></li>
</ul>
<p><strong><code>--disable-ruleset &lt;ID&gt;...</code></strong></p>
<ul>
<li>Disable specific rulesets by ID</li>
<li>Multiple IDs allowed</li>
<li>Example: <code>--disable-ruleset experimental</code></li>
</ul>
<p><strong><code>--enable-pass &lt;ID&gt;...</code></strong></p>
<ul>
<li>Enable specific analysis passes by ID</li>
<li>Multiple IDs allowed</li>
<li>Example: <code>--enable-pass indexing control_flow</code></li>
</ul>
<p><strong><code>--disable-pass &lt;ID&gt;...</code></strong></p>
<ul>
<li>Disable specific analysis passes by ID</li>
<li>Multiple IDs allowed</li>
<li>Example: <code>--disable-pass dependencies</code></li>
</ul>
<p><strong><code>--severity &lt;CODE=LEVEL&gt;...</code></strong></p>
<ul>
<li>Override diagnostic severity for specific codes</li>
<li>Format: <code>CODE=level</code> where level is <code>error</code>, <code>warning</code>, <code>info</code>, or <code>hint</code></li>
<li>Multiple overrides allowed</li>
<li>Example: <code>--severity MET001=error QUAL010=warning</code></li>
</ul>
<h3 id="legacy-options-single-file-mode"><a class="header" href="#legacy-options-single-file-mode">Legacy Options (Single File Mode)</a></h3>
<p><strong><code>--symbol &lt;NAME&gt;</code></strong></p>
<ul>
<li>Search for specific symbol by name</li>
<li>Only works in single-file mode</li>
<li>Prints symbol locations and information</li>
</ul>
<hr />
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="basic-analysis"><a class="header" href="#basic-analysis">Basic Analysis</a></h3>
<pre><code class="language-bash"># Analyze single file
bsharp analyze MyFile.cs

# Analyze project
bsharp analyze MyProject.csproj

# Analyze solution
bsharp analyze MySolution.sln
</code></pre>
<h3 id="output-to-file"><a class="header" href="#output-to-file">Output to File</a></h3>
<pre><code class="language-bash"># Save report to file
bsharp analyze MyProject.csproj --out report.json

# Compact JSON format
bsharp analyze MyProject.csproj --out report.json --format json
</code></pre>
<h3 id="using-configuration-file"><a class="header" href="#using-configuration-file">Using Configuration File</a></h3>
<pre><code class="language-bash"># Load config from file
bsharp analyze MyProject.csproj --config .bsharp.toml

# Config file with CLI overrides
bsharp analyze MyProject.csproj \
    --config .bsharp.toml \
    --enable-ruleset quality \
    --severity MET001=error
</code></pre>
<h3 id="workspace-filtering"><a class="header" href="#workspace-filtering">Workspace Filtering</a></h3>
<pre><code class="language-bash"># Analyze only service files
bsharp analyze MySolution.sln --include "**/*Service.cs"

# Exclude test files
bsharp analyze MySolution.sln --exclude "**/Tests/**"

# Multiple filters
bsharp analyze MySolution.sln \
    --include "src/**/*.cs" \
    --exclude "**/obj/**" "**/bin/**" "**/Tests/**"
</code></pre>
<h3 id="controlling-analysis"><a class="header" href="#controlling-analysis">Controlling Analysis</a></h3>
<pre><code class="language-bash"># Enable specific rulesets
bsharp analyze MyProject.csproj \
    --enable-ruleset naming quality control_flow

# Disable experimental features
bsharp analyze MyProject.csproj \
    --disable-ruleset experimental

# Enable/disable specific passes
bsharp analyze MyProject.csproj \
    --enable-pass indexing control_flow \
    --disable-pass dependencies
</code></pre>
<h3 id="severity-overrides"><a class="header" href="#severity-overrides">Severity Overrides</a></h3>
<pre><code class="language-bash"># Treat specific warnings as errors
bsharp analyze MyProject.csproj \
    --severity MET001=error \
    --severity QUAL001=error

# Downgrade specific errors to warnings
bsharp analyze MyProject.csproj \
    --severity CS0168=warning
</code></pre>
<h3 id="symbol-search-single-file"><a class="header" href="#symbol-search-single-file">Symbol Search (Single File)</a></h3>
<pre><code class="language-bash"># Find symbol in file
bsharp analyze MyFile.cs --symbol MyClass

# Output:
# Found symbol 'MyClass' at line 10, column 14
</code></pre>
<hr />
<h2 id="analysis-modes"><a class="header" href="#analysis-modes">Analysis Modes</a></h2>
<h3 id="single-file-mode"><a class="header" href="#single-file-mode">Single File Mode</a></h3>
<p><strong>Triggered when:</strong> Input is a <code>.cs</code> file</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Parses single file</li>
<li>Runs analysis pipeline on CompilationUnit</li>
<li>Supports <code>--symbol</code> option for symbol search</li>
<li>Faster for quick checks</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">bsharp analyze Program.cs --out analysis.json
</code></pre>
<h3 id="workspace-mode"><a class="header" href="#workspace-mode">Workspace Mode</a></h3>
<p><strong>Triggered when:</strong> Input is <code>.sln</code>, <code>.csproj</code>, or directory</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Loads entire workspace</li>
<li>Discovers all source files</li>
<li>Follows project references (if <code>--follow-refs true</code>)</li>
<li>Applies include/exclude filters</li>
<li>Analyzes all files deterministically</li>
<li>Aggregates results into single report</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">bsharp analyze MySolution.sln \
    --follow-refs true \
    --exclude "**/Tests/**" \
    --out workspace-analysis.json
</code></pre>
<hr />
<h2 id="configuration-file-format"><a class="header" href="#configuration-file-format">Configuration File Format</a></h2>
<h3 id="toml-format"><a class="header" href="#toml-format">TOML Format</a></h3>
<p><strong><code>.bsharp.toml</code>:</strong></p>
<pre><code class="language-toml">[analysis]
max_cyclomatic_complexity = 10
max_method_length = 50

[analysis.control_flow]
cf_high_complexity_threshold = 10
cf_deep_nesting_threshold = 4

[analysis.quality]
long_method = "warning"
god_class = "error"
empty_catch = "error"

[workspace]
follow_refs = true
include = ["src/**/*.cs"]
exclude = ["**/obj/**", "**/bin/**", "**/Tests/**"]

[enable_rulesets]
naming = true
quality = true
control_flow = true

[enable_passes]
indexing = true
control_flow = true
dependencies = true

[rule_severities]
MET001 = "error"
QUAL001 = "warning"
</code></pre>
<h3 id="json-format"><a class="header" href="#json-format">JSON Format</a></h3>
<p><strong><code>.bsharp.json</code>:</strong></p>
<pre><code class="language-json">{
  "analysis": {
    "max_cyclomatic_complexity": 10,
    "max_method_length": 50,
    "control_flow": {
      "cf_high_complexity_threshold": 10,
      "cf_deep_nesting_threshold": 4
    }
  },
  "workspace": {
    "follow_refs": true,
    "include": ["src/**/*.cs"],
    "exclude": ["**/obj/**", "**/bin/**"]
  },
  "enable_rulesets": {
    "naming": true,
    "quality": true
  },
  "enable_passes": {
    "indexing": true,
    "control_flow": true
  },
  "rule_severities": {
    "MET001": "error",
    "QUAL001": "warning"
  }
}
</code></pre>
<hr />
<h2 id="output-format-2"><a class="header" href="#output-format-2">Output Format</a></h2>
<h3 id="analysis-report-structure"><a class="header" href="#analysis-report-structure">Analysis Report Structure</a></h3>
<pre><code class="language-json">{
  "schema_version": 1,
  "diagnostics": {
    "items": [
      {
        "code": "MET001",
        "severity": "warning",
        "message": "Method has high cyclomatic complexity",
        "file": "src/OrderService.cs",
        "line": 42,
        "column": 17,
        "end_line": 85,
        "end_column": 5
      }
    ]
  },
  "metrics": {
    "total_lines": 1250,
    "code_lines": 980,
    "comment_lines": 150,
    "blank_lines": 120,
    "class_count": 15,
    "interface_count": 3,
    "method_count": 87,
    "total_complexity": 245,
    "max_complexity": 18,
    "max_nesting_depth": 5
  },
  "cfg": {
    "total_methods": 87,
    "high_complexity_count": 5,
    "deep_nesting_count": 3
  },
  "deps": {
    "total_nodes": 15,
    "total_edges": 42,
    "circular_dependencies": 0,
    "max_depth": 4
  },
  "workspace_warnings": [
    "Failed to parse project: MyBrokenProject.csproj"
  ]
}
</code></pre>
<h3 id="diagnostic-fields"><a class="header" href="#diagnostic-fields">Diagnostic Fields</a></h3>
<ul>
<li><strong>code</strong>: Diagnostic code (e.g., <code>MET001</code>, <code>QUAL010</code>)</li>
<li><strong>severity</strong>: <code>error</code>, <code>warning</code>, <code>info</code>, or <code>hint</code></li>
<li><strong>message</strong>: Human-readable description</li>
<li><strong>file</strong>: Source file path</li>
<li><strong>line/column</strong>: Start position</li>
<li><strong>end_line/end_column</strong>: End position (optional)</li>
</ul>
<h3 id="metrics-fields"><a class="header" href="#metrics-fields">Metrics Fields</a></h3>
<ul>
<li><strong>total_lines</strong>: Total lines including blank/comments</li>
<li><strong>code_lines</strong>: Lines with actual code</li>
<li><strong>comment_lines</strong>: Lines with comments</li>
<li><strong>blank_lines</strong>: Empty lines</li>
<li><strong>class_count</strong>: Number of classes</li>
<li><strong>interface_count</strong>: Number of interfaces</li>
<li><strong>method_count</strong>: Number of methods</li>
<li><strong>total_complexity</strong>: Sum of all method complexities</li>
<li><strong>max_complexity</strong>: Highest method complexity</li>
<li><strong>max_nesting_depth</strong>: Deepest nesting level</li>
</ul>
<hr />
<h2 id="available-rulesets"><a class="header" href="#available-rulesets">Available Rulesets</a></h2>
<h3 id="built-in-rulesets"><a class="header" href="#built-in-rulesets">Built-in Rulesets</a></h3>
<p><strong><code>naming</code></strong> - Naming convention rules</p>
<ul>
<li>Class names: PascalCase</li>
<li>Method names: PascalCase</li>
<li>Field names: camelCase with <code>_</code> prefix</li>
<li>Constant names: UPPER_CASE or PascalCase</li>
</ul>
<p><strong><code>quality</code></strong> - Code quality rules</p>
<ul>
<li>Long method detection</li>
<li>Long parameter list</li>
<li>God class detection</li>
<li>Empty catch blocks</li>
<li>Magic numbers</li>
</ul>
<p><strong><code>control_flow</code></strong> - Control flow rules</p>
<ul>
<li>High complexity warnings</li>
<li>Deep nesting warnings</li>
<li>Unreachable code detection</li>
</ul>
<p><strong><code>semantic</code></strong> - Semantic rules</p>
<ul>
<li>Type checking</li>
<li>Null reference analysis</li>
<li>Resource leak detection</li>
</ul>
<hr />
<h2 id="available-passes"><a class="header" href="#available-passes">Available Passes</a></h2>
<h3 id="built-in-passes"><a class="header" href="#built-in-passes">Built-in Passes</a></h3>
<p><strong><code>indexing</code></strong> (Phase: Index)</p>
<ul>
<li>Builds symbol index</li>
<li>Creates name index</li>
<li>Generates FQN map</li>
</ul>
<p><strong><code>control_flow</code></strong> (Phase: Semantic)</p>
<ul>
<li>Analyzes control flow</li>
<li>Calculates complexity metrics</li>
<li>Detects control flow smells</li>
</ul>
<p><strong><code>dependencies</code></strong> (Phase: Global)</p>
<ul>
<li>Builds dependency graph</li>
<li>Detects circular dependencies</li>
<li>Calculates coupling metrics</li>
</ul>
<p><strong><code>reporting</code></strong> (Phase: Reporting)</p>
<ul>
<li>Generates final report</li>
<li>Aggregates diagnostics</li>
<li>Summarizes artifacts</li>
</ul>
<hr />
<h2 id="diagnostic-codes"><a class="header" href="#diagnostic-codes">Diagnostic Codes</a></h2>
<h3 id="metrics-met"><a class="header" href="#metrics-met">Metrics (MET)</a></h3>
<ul>
<li><strong>MET001</strong>: High cyclomatic complexity</li>
<li><strong>MET002</strong>: Deep nesting detected</li>
<li><strong>MET003</strong>: Long method</li>
<li><strong>MET004</strong>: Long parameter list</li>
</ul>
<h3 id="quality-qual"><a class="header" href="#quality-qual">Quality (QUAL)</a></h3>
<ul>
<li><strong>QUAL001</strong>: Long method</li>
<li><strong>QUAL002</strong>: Long parameter list</li>
<li><strong>QUAL010</strong>: Empty catch block</li>
<li><strong>QUAL020</strong>: Naming convention violation</li>
<li><strong>QUAL030</strong>: Resource not disposed</li>
</ul>
<h3 id="control-flow-cf"><a class="header" href="#control-flow-cf">Control Flow (CF)</a></h3>
<ul>
<li><strong>CF001</strong>: Unreachable code</li>
<li><strong>CF002</strong>: High complexity</li>
<li><strong>CF003</strong>: Deep nesting</li>
</ul>
<h3 id="dependencies-dep"><a class="header" href="#dependencies-dep">Dependencies (DEP)</a></h3>
<ul>
<li><strong>DEP001</strong>: Circular dependency</li>
<li><strong>DEP002</strong>: High coupling</li>
<li><strong>DEP003</strong>: Unstable dependency</li>
</ul>
<hr />
<h2 id="performance-3"><a class="header" href="#performance-3">Performance</a></h2>
<h3 id="analysis-speed"><a class="header" href="#analysis-speed">Analysis Speed</a></h3>
<ul>
<li><strong>Single file</strong> (&lt; 1000 lines): &lt; 100ms</li>
<li><strong>Small project</strong> (&lt; 10 files): &lt; 500ms</li>
<li><strong>Medium project</strong> (10-50 files): 500ms-2s</li>
<li><strong>Large solution</strong> (100+ files): 2-10s</li>
</ul>
<h3 id="memory-usage-2"><a class="header" href="#memory-usage-2">Memory Usage</a></h3>
<ul>
<li>Scales with codebase size</li>
<li>Typical: 50-200 MB for medium projects</li>
<li>Artifacts cached in memory during analysis</li>
</ul>
<h3 id="parallel-analysis"><a class="header" href="#parallel-analysis">Parallel Analysis</a></h3>
<p>With <code>parallel_analysis</code> feature enabled:</p>
<pre><code class="language-bash">cargo build --release --features parallel_analysis
</code></pre>
<p>Files analyzed in parallel, significantly faster for large workspaces.</p>
<hr />
<h2 id="integration-2"><a class="header" href="#integration-2">Integration</a></h2>
<h3 id="cicd-pipeline-2"><a class="header" href="#cicd-pipeline-2">CI/CD Pipeline</a></h3>
<pre><code class="language-yaml"># GitHub Actions
- name: Code Quality Analysis
  run: |
    bsharp analyze MySolution.sln \
      --out analysis.json \
      --format json \
      --severity MET001=error QUAL001=error
    
    # Check for errors
    errors=$(jq '.diagnostics.items | map(select(.severity == "error")) | length' analysis.json)
    if [ "$errors" -gt 0 ]; then
      echo "Quality gate failed: $errors errors"
      exit 1
    fi
</code></pre>
<h3 id="pre-commit-hook-2"><a class="header" href="#pre-commit-hook-2">Pre-commit Hook</a></h3>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

changed_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.cs$')

for file in $changed_files; do
    result=$(bsharp analyze "$file" --format json 2&gt;/dev/null)
    errors=$(echo "$result" | jq '.diagnostics.items | map(select(.severity == "error")) | length')
    
    if [ "$errors" -gt 0 ]; then
        echo "Analysis errors in $file"
        exit 1
    fi
done
</code></pre>
<h3 id="quality-gate-script"><a class="header" href="#quality-gate-script">Quality Gate Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# quality-gate.sh

bsharp analyze MySolution.sln \
    --out report.json \
    --format json \
    --enable-ruleset naming quality control_flow \
    --severity MET001=error QUAL001=error

# Extract metrics
errors=$(jq '.diagnostics.items | map(select(.severity == "error")) | length' report.json)
max_complexity=$(jq '.metrics.max_complexity' report.json)

echo "Errors: $errors"
echo "Max Complexity: $max_complexity"

if [ "$errors" -gt 0 ]; then
    echo "❌ Quality gate failed: $errors errors found"
    exit 1
fi

if [ "$max_complexity" -gt 15 ]; then
    echo "❌ Quality gate failed: complexity $max_complexity exceeds threshold 15"
    exit 1
fi

echo "✅ Quality gate passed"
</code></pre>
<hr />
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="analysis-fails"><a class="header" href="#analysis-fails">Analysis Fails</a></h3>
<pre><code class="language-bash">$ bsharp analyze MyProject.csproj
Error: Failed to load workspace
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Check project file is valid XML</li>
<li>Verify all referenced projects exist</li>
<li>Use <code>--follow-refs false</code> to skip references</li>
</ul>
<h3 id="out-of-memory-1"><a class="header" href="#out-of-memory-1">Out of Memory</a></h3>
<pre><code class="language-bash">Error: memory allocation failed
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Analyze smaller subsets with <code>--include</code>/<code>--exclude</code></li>
<li>Disable expensive passes with <code>--disable-pass</code></li>
<li>Increase system memory</li>
</ul>
<h3 id="slow-analysis"><a class="header" href="#slow-analysis">Slow Analysis</a></h3>
<p><strong>Solutions:</strong></p>
<ul>
<li>Build with <code>parallel_analysis</code> feature</li>
<li>Exclude unnecessary files</li>
<li>Disable unused rulesets/passes</li>
</ul>
<hr />
<h2 id="related-documentation-9"><a class="header" href="#related-documentation-9">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a> - General CLI usage</li>
<li><a href="cli/../analysis/pipeline.html">Analysis Pipeline</a> - Analysis internals</li>
<li><a href="cli/../analysis/metrics.html">Metrics Collection</a> - Metrics details</li>
<li><a href="cli/../analysis/quality.html">Code Quality</a> - Quality rules</li>
</ul>
<hr />
<h2 id="references-9"><a class="header" href="#references-9">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/cli/commands/analyze.rs</code></li>
<li><strong>Pipeline:</strong> <code>src/analysis/framework/pipeline.rs</code></li>
<li><strong>Configuration:</strong> <code>src/analysis/context.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-loading"><a class="header" href="#workspace-loading">Workspace Loading</a></h1>
<p>The BSharp workspace loading system provides comprehensive support for loading C# projects and solutions, including solution files (.sln), project files (.csproj), and directory-based discovery.</p>
<hr />
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p><strong>Location:</strong> <code>src/workspace/</code></p>
<p>The workspace loader:</p>
<ul>
<li>Parses Visual Studio solution files (.sln)</li>
<li>Parses MSBuild project files (.csproj)</li>
<li>Discovers source files</li>
<li>Resolves project references</li>
<li>Handles multiple projects deterministically</li>
</ul>
<hr />
<h2 id="workspace-model"><a class="header" href="#workspace-model">Workspace Model</a></h2>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Workspace {
    pub root: PathBuf,
    pub projects: Vec&lt;Project&gt;,
    pub solution: Option&lt;Solution&gt;,
    pub source_map: SourceMap,
}

pub struct Project {
    pub name: String,
    pub path: PathBuf,
    pub target_framework: String,
    pub output_type: String,
    pub files: Vec&lt;ProjectFile&gt;,
    pub references: Vec&lt;ProjectRef&gt;,
    pub package_references: Vec&lt;PackageReference&gt;,
    pub errors: Vec&lt;String&gt;,
}

pub struct Solution {
    pub name: String,
    pub path: PathBuf,
    pub projects: Vec&lt;SolutionProject&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="loading-workspaces"><a class="header" href="#loading-workspaces">Loading Workspaces</a></h2>
<h3 id="workspaceloader-api"><a class="header" href="#workspaceloader-api">WorkspaceLoader API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WorkspaceLoader;

impl WorkspaceLoader {
    // Load from any path (auto-detects type)
    pub fn from_path(path: &amp;Path) -&gt; Result&lt;Workspace&gt;;
    
    // Load with options
    pub fn from_path_with_options(
        path: &amp;Path, 
        opts: WorkspaceLoadOptions
    ) -&gt; Result&lt;Workspace&gt;;
}

pub struct WorkspaceLoadOptions {
    pub follow_refs: bool,  // Follow ProjectReference transitively
}
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-from-solution-file"><a class="header" href="#loading-from-solution-file">Loading from Solution File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::workspace::WorkspaceLoader;

let workspace = WorkspaceLoader::from_path(Path::new("MySolution.sln"))?;

println!("Loaded {} projects", workspace.projects.len());
for project in &amp;workspace.projects {
    println!("  - {}: {} files", project.name, project.files.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-from-project-file"><a class="header" href="#loading-from-project-file">Loading from Project File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(Path::new("MyProject.csproj"))?;

// Automatically follows ProjectReference if follow_refs = true
assert!(workspace.projects.len() &gt;= 1);
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-from-directory"><a class="header" href="#loading-from-directory">Loading from Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(Path::new("./src"))?;

// Discovers .sln or .csproj files in directory
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="solution-file-parsing"><a class="header" href="#solution-file-parsing">Solution File Parsing</a></h2>
<h3 id="solution-format"><a class="header" href="#solution-format">Solution Format</a></h3>
<p><strong>Example .sln:</strong></p>
<pre><code>Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyApp", "MyApp\MyApp.csproj", "{GUID}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyLib", "MyLib\MyLib.csproj", "{GUID}"
EndProject
</code></pre>
<h3 id="parsing-implementation"><a class="header" href="#parsing-implementation">Parsing Implementation</a></h3>
<p><strong>Location:</strong> <code>src/workspace/sln.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SolutionReader;

impl SolutionReader {
    pub fn read(path: &amp;Path) -&gt; Result&lt;Solution&gt; {
        let content = fs::read_to_string(path)?;
        Self::parse(&amp;content, path)
    }
    
    fn parse(content: &amp;str, base_path: &amp;Path) -&gt; Result&lt;Solution&gt; {
        // Parse solution format
        // Extract project entries
        // Resolve project paths
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solution-structure"><a class="header" href="#solution-structure">Solution Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Solution {
    pub name: String,
    pub path: PathBuf,
    pub projects: Vec&lt;SolutionProject&gt;,
}

pub struct SolutionProject {
    pub name: String,
    pub path: PathBuf,
    pub type_guid: String,
    pub guid: String,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="project-file-parsing"><a class="header" href="#project-file-parsing">Project File Parsing</a></h2>
<h3 id="project-format"><a class="header" href="#project-format">Project Format</a></h3>
<p><strong>Example .csproj:</strong></p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
  &lt;/PropertyGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;Compile Include="Program.cs" /&gt;
    &lt;Compile Include="Utils.cs" /&gt;
  &lt;/ItemGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\MyLib\MyLib.csproj" /&gt;
  &lt;/ItemGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Newtonsoft.Json" Version="13.0.1" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<h3 id="parsing-implementation-1"><a class="header" href="#parsing-implementation-1">Parsing Implementation</a></h3>
<p><strong>Location:</strong> <code>src/workspace/csproj.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CsprojReader;

impl CsprojReader {
    pub fn read(path: &amp;Path) -&gt; Result&lt;Project&gt; {
        let content = fs::read_to_string(path)?;
        Self::parse(&amp;content, path)
    }
    
    fn parse(content: &amp;str, project_path: &amp;Path) -&gt; Result&lt;Project&gt; {
        // Parse XML
        // Extract properties (TargetFramework, OutputType)
        // Discover source files (Compile items)
        // Extract ProjectReference entries
        // Extract PackageReference entries
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="source-file-discovery"><a class="header" href="#source-file-discovery">Source File Discovery</a></h3>
<p><strong>Glob Patterns:</strong></p>
<ul>
<li>Default: <code>**/*.cs</code> (all C# files recursively)</li>
<li>Respects <code>&lt;Compile Include="..." /&gt;</code> items</li>
<li>Respects <code>&lt;Compile Remove="..." /&gt;</code> exclusions</li>
<li>Excludes <code>obj/</code> and <code>bin/</code> directories</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn discover_source_files(project_dir: &amp;Path) -&gt; Vec&lt;ProjectFile&gt; {
    let pattern = project_dir.join("**/*.cs");
    let mut files = Vec::new();
    
    for entry in glob::glob(pattern.to_str().unwrap()) {
        let path = entry.unwrap();
        
        // Skip obj/ and bin/
        if path.components().any(|c| c.as_os_str() == "obj" || c.as_os_str() == "bin") {
            continue;
        }
        
        files.push(ProjectFile {
            path,
            kind: ProjectFileKind::Compile,
        });
    }
    
    files
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="project-references"><a class="header" href="#project-references">Project References</a></h2>
<h3 id="transitive-resolution"><a class="header" href="#transitive-resolution">Transitive Resolution</a></h3>
<p><strong>follow_refs Option:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opts = WorkspaceLoadOptions { follow_refs: true };
let workspace = WorkspaceLoader::from_path_with_options(path, opts)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Behavior:</strong></p>
<ul>
<li>Follows <code>&lt;ProjectReference&gt;</code> transitively</li>
<li>Loads all referenced projects</li>
<li>Avoids duplicates</li>
<li>Stays within workspace root</li>
<li>Deterministic ordering (sorted by path)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>MyApp.csproj
  → MyLib.csproj
    → MyCore.csproj

Result: [MyApp, MyLib, MyCore]
</code></pre>
<h3 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn follow_project_references(root: &amp;Path, projects: &amp;mut Vec&lt;Project&gt;) {
    let mut seen = HashSet::new();
    let mut queue = VecDeque::new();
    
    // Add initial projects
    for proj in projects.iter() {
        seen.insert(proj.path.clone());
        queue.push_back(proj.path.clone());
    }
    
    // BFS traversal
    while let Some(proj_path) = queue.pop_front() {
        let proj = match CsprojReader::read(&amp;proj_path) {
            Ok(p) =&gt; p,
            Err(_) =&gt; continue,
        };
        
        for ref_path in proj.references.iter().map(|r| &amp;r.path) {
            // Resolve relative to project directory
            let abs_path = proj_path.parent().unwrap().join(ref_path);
            
            // Skip if outside root
            if !abs_path.starts_with(root) {
                continue;
            }
            
            // Skip if already seen
            if seen.insert(abs_path.clone()) {
                queue.push_back(abs_path.clone());
                
                // Load and add project
                if let Ok(referenced_proj) = CsprojReader::read(&amp;abs_path) {
                    projects.push(referenced_proj);
                }
            }
        }
    }
    
    // Sort for determinism
    projects.sort_by(|a, b| a.path.cmp(&amp;b.path));
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="source-map"><a class="header" href="#source-map">Source Map</a></h2>
<h3 id="purpose"><a class="header" href="#purpose">Purpose</a></h3>
<p>The <code>SourceMap</code> provides fast lookup of source files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SourceMap {
    files: HashMap&lt;PathBuf, SourceFileInfo&gt;,
}

impl SourceMap {
    pub fn get(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;SourceFileInfo&gt;;
    pub fn all_files(&amp;self) -&gt; Vec&lt;&amp;Path&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(path)?;

// Look up file
if let Some(info) = workspace.source_map.get(Path::new("Program.cs")) {
    println!("Found in project: {}", info.project_name);
}

// Iterate all files
for file_path in workspace.source_map.all_files() {
    println!("File: {}", file_path.display());
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<h3 id="resilient-loading"><a class="header" href="#resilient-loading">Resilient Loading</a></h3>
<p><strong>Philosophy:</strong> Continue loading even if individual projects fail</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Failed projects recorded as stubs with errors
let workspace = WorkspaceLoader::from_path(sln_path)?;

for project in &amp;workspace.projects {
    if !project.errors.is_empty() {
        eprintln!("Errors in {}: {:?}", project.name, project.errors);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-types-1"><a class="header" href="#error-types-1">Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum WorkspaceError {
    IoError(io::Error),
    ParseError(String),
    InvalidPath(String),
    Unsupported(String),
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="cli-integration-1"><a class="header" href="#cli-integration-1">CLI Integration</a></h2>
<h3 id="analyze-command-1"><a class="header" href="#analyze-command-1">Analyze Command</a></h3>
<pre><code class="language-bash"># Analyze solution
bsharp analyze MySolution.sln

# Analyze project
bsharp analyze MyProject.csproj

# Follow references (default: true)
bsharp analyze MyProject.csproj --follow-refs true

# Don't follow references
bsharp analyze MyProject.csproj --follow-refs false
</code></pre>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<pre><code class="language-bash"># Include only specific files
bsharp analyze MySolution.sln --include "**/*Service.cs"

# Exclude test files
bsharp analyze MySolution.sln --exclude "**/Tests/**"

# Multiple patterns
bsharp analyze MySolution.sln \
    --include "src/**/*.cs" \
    --exclude "**/obj/**" "**/bin/**"
</code></pre>
<hr />
<h2 id="deterministic-behavior"><a class="header" href="#deterministic-behavior">Deterministic Behavior</a></h2>
<h3 id="guarantees"><a class="header" href="#guarantees">Guarantees</a></h3>
<ol>
<li><strong>Project Order:</strong> Always sorted by absolute path</li>
<li><strong>File Order:</strong> Always sorted within each project</li>
<li><strong>Deduplication:</strong> No duplicate projects or files</li>
<li><strong>Reproducible:</strong> Same input always produces same output</li>
</ol>
<h3 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sort projects
projects.sort_by(|a, b| a.path.cmp(&amp;b.path));

// Deduplicate by path
let mut seen = HashSet::new();
projects.retain(|p| seen.insert(p.path.clone()));

// Sort files within each project
for project in &amp;mut projects {
    project.files.sort_by(|a, b| a.path.cmp(&amp;b.path));
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-4"><a class="header" href="#performance-4">Performance</a></h2>
<h3 id="loading-speed"><a class="header" href="#loading-speed">Loading Speed</a></h3>
<ul>
<li><strong>Small solution</strong> (1-5 projects): &lt; 100ms</li>
<li><strong>Medium solution</strong> (5-20 projects): 100-500ms</li>
<li><strong>Large solution</strong> (20-100 projects): 500ms-2s</li>
</ul>
<h3 id="memory-usage-3"><a class="header" href="#memory-usage-3">Memory Usage</a></h3>
<ul>
<li>Minimal: Only metadata loaded, not source content</li>
<li>Typical: 1-5 MB per solution</li>
</ul>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<ul>
<li>Parallel project loading (with <code>parallel_analysis</code> feature)</li>
<li>Lazy source file reading</li>
<li>Efficient path canonicalization</li>
</ul>
<hr />
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="example-1-load-and-analyze"><a class="header" href="#example-1-load-and-analyze">Example 1: Load and Analyze</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::workspace::WorkspaceLoader;
use bsharp::syntax::Parser;

let workspace = WorkspaceLoader::from_path(Path::new("MySolution.sln"))?;

let parser = Parser::new();
for project in &amp;workspace.projects {
    for file in &amp;project.files {
        let source = fs::read_to_string(&amp;file.path)?;
        match parser.parse(&amp;source) {
            Ok(cu) =&gt; println!("Parsed: {}", file.path.display()),
            Err(e) =&gt; eprintln!("Error in {}: {}", file.path.display(), e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-project-statistics"><a class="header" href="#example-2-project-statistics">Example 2: Project Statistics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(path)?;

println!("Solution: {}", workspace.solution.as_ref().unwrap().name);
println!("Projects: {}", workspace.projects.len());

let total_files: usize = workspace.projects.iter()
    .map(|p| p.files.len())
    .sum();
println!("Total files: {}", total_files);

for project in &amp;workspace.projects {
    println!("  {}: {} files", project.name, project.files.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-dependency-graph"><a class="header" href="#example-3-dependency-graph">Example 3: Dependency Graph</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(path)?;

println!("Project Dependencies:");
for project in &amp;workspace.projects {
    if !project.references.is_empty() {
        println!("{}:", project.name);
        for ref_ in &amp;project.references {
            println!("  → {}", ref_.name);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h3>
<p><strong>Location:</strong> <code>tests/fixtures/</code></p>
<pre><code>tests/fixtures/
├── happy_path/
│   ├── test.sln
│   ├── testApplication/
│   │   ├── testApplication.csproj
│   │   └── Program.cs
│   └── testDependency/
│       ├── testDependency.csproj
│       └── Library.cs
└── complex/
    └── ...
</code></pre>
<h3 id="test-examples"><a class="header" href="#test-examples">Test Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_load_solution() {
    let sln_path = PathBuf::from("tests/fixtures/happy_path/test.sln");
    let workspace = WorkspaceLoader::from_path(&amp;sln_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 2);
    assert!(workspace.solution.is_some());
}

#[test]
fn test_follow_references() {
    let proj_path = PathBuf::from("tests/fixtures/happy_path/testApplication/testApplication.csproj");
    let workspace = WorkspaceLoader::from_path(&amp;proj_path).unwrap();
    
    // Should load both testApplication and testDependency
    assert_eq!(workspace.projects.len(), 2);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="future-enhancements-5"><a class="header" href="#future-enhancements-5">Future Enhancements</a></h2>
<h3 id="planned-features-4"><a class="header" href="#planned-features-4">Planned Features</a></h3>
<ol>
<li>
<p><strong>NuGet Package Resolution</strong></p>
<ul>
<li>Resolve package references</li>
<li>Download packages if needed</li>
<li>Parse package assemblies</li>
</ul>
</li>
<li>
<p><strong>MSBuild Integration</strong></p>
<ul>
<li>Full MSBuild evaluation</li>
<li>Property expansion</li>
<li>Target execution</li>
</ul>
</li>
<li>
<p><strong>Multi-targeting Support</strong></p>
<ul>
<li>Handle multiple target frameworks</li>
<li>Conditional compilation</li>
</ul>
</li>
<li>
<p><strong>Incremental Loading</strong></p>
<ul>
<li>Cache workspace metadata</li>
<li>Reload only changed projects</li>
</ul>
</li>
</ol>
<hr />
<h2 id="related-documentation-10"><a class="header" href="#related-documentation-10">Related Documentation</a></h2>
<ul>
<li><a href="workspace/../cli/overview.html">CLI Overview</a> - CLI integration</li>
<li><a href="workspace/../analysis/pipeline.html">Analysis Pipeline</a> - Using workspace in analysis</li>
<li><a href="workspace/../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references-10"><a class="header" href="#references-10">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/workspace/</code></li>
<li><strong>Loader:</strong> <code>src/workspace/loader.rs</code></li>
<li><strong>Solution Parser:</strong> <code>src/workspace/sln.rs</code></li>
<li><strong>Project Parser:</strong> <code>src/workspace/csproj.rs</code></li>
<li><strong>Model:</strong> <code>src/workspace/model.rs</code></li>
<li><strong>Tests:</strong> <code>tests/workspace/</code> (planned)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-bsharp"><a class="header" href="#contributing-to-bsharp">Contributing to BSharp</a></h1>
<p>Thank you for your interest in contributing to BSharp! This document provides guidelines for contributing to the project.</p>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>Rust 1.70 or later</li>
<li>Git</li>
<li>A text editor or IDE with Rust support</li>
</ul>
<h3 id="building-the-project"><a class="header" href="#building-the-project">Building the Project</a></h3>
<ol>
<li>Clone the repository:</li>
</ol>
<pre><code class="language-bash">git clone https://github.com/your-repo/bsharp.git
cd bsharp
</code></pre>
<h4 id="parser-testing-best-practices"><a class="header" href="#parser-testing-best-practices">Parser Testing Best Practices</a></h4>
<ul>
<li>Prefer <code>expect_ok(input, parse(input))</code> from <code>syntax::test_helpers</code> when asserting successful parses. It prints readable, rustc-like diagnostics on failure via <code>format_error_tree</code>.</li>
<li>Keep tests focused and minimal; add a separate negative test when ambiguity is possible (e.g., ternary vs <code>?.</code> vs <code>??</code>, range vs dot vs float).</li>
<li>For lookahead/disambiguation boundaries, add cases to <code>tests/parser/expressions/lookahead_boundaries2_tests.rs</code>.</li>
<li>For complex constructs (e.g., <code>new</code> with object/collection initializers), add positive and negative cases near <code>tests/parser/expressions/new_expression_tests.rs</code> and <code>target_typed_new_tests.rs</code>.</li>
<li>Invalid-input diagnostics: place small snapshot-style assertions in <code>tests/parser/expressions/invalid_diagnostics_tests.rs</code> that check for line/column and caret presence. Avoid overfitting on exact wording.</li>
<li>When adding delimited constructs (parentheses, brackets, braces), guard the closing delimiter with <code>cut(...)</code> once committed to that branch to prevent misleading backtracking.</li>
<li>Always wrap sub-parsers with <code>bws(...)</code> to ensure whitespace/comments are handled consistently.</li>
</ul>
<h4 id="adding-new-parser-test-files"><a class="header" href="#adding-new-parser-test-files">Adding New Parser Test Files</a></h4>
<ul>
<li>In <code>tests/parser/expressions/</code>, simply add a new <code>*_tests.rs</code> file; it will be discovered by the existing integration test harness.</li>
<li>For declarations/statements/types, follow the existing directory structure under <code>tests/parser/</code> and mimic module organization.</li>
<li>Keep tests deterministic and avoid relying on environment-specific paths or random data.</li>
</ul>
<ol start="2">
<li>Build the project:</li>
</ol>
<pre><code class="language-bash">cargo build
</code></pre>
<ol start="3">
<li>Run tests:</li>
</ol>
<pre><code class="language-bash">cargo test
</code></pre>
<ol start="4">
<li>Run the CLI tool:</li>
</ol>
<pre><code class="language-bash">cargo run -- --help
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>Understanding the codebase organization:</p>
<pre><code>src/
├── parser/           # Parser implementations (expressions, statements, etc.)
├── syntax/           # Parser infrastructure (AST nodes, helpers, errors)
├── analysis/         # Code analysis framework
├── workspace/        # Solution and project file loading
├── cli/              # Command-line interface
└── lib.rs           # Library entry point
</code></pre>
<h3 id="code-style"><a class="header" href="#code-style">Code Style</a></h3>
<p>Follow Rust conventions:</p>
<ul>
<li>Use <code>cargo fmt</code> to format code</li>
<li>Use <code>cargo clippy</code> to check for common issues</li>
<li>Follow naming conventions (<code>snake_case</code> for functions, <code>PascalCase</code> for types)</li>
<li>Add documentation comments for public APIs</li>
</ul>
<h3 id="testing-1"><a class="header" href="#testing-1">Testing</a></h3>
<p>All contributions should include appropriate tests:</p>
<h4 id="parser-tests"><a class="header" href="#parser-tests">Parser Tests</a></h4>
<p><strong>IMPORTANT:</strong> All tests must be in external files under <code>tests/</code> directory, NOT inline <code>#[cfg(test)]</code> modules.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ CORRECT: External test file
// tests/parser/declarations/class_declaration_tests.rs

use bsharp::syntax::test_helpers::expect_ok;
use bsharp::parser::expressions::declarations::parse_class_declaration;

#[test]
fn test_parse_simple_class() {
    let input = "public class MyClass { }";
    let class = expect_ok(input, parse_class_declaration(input));
    assert_eq!(class.identifier.name, "MyClass");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="analysis-tests"><a class="header" href="#analysis-tests">Analysis Tests</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/analysis/complexity_tests.rs

use bsharp::syntax::Parser;
use bsharp::analysis::metrics::cyclomatic_complexity;

#[test]
fn test_complexity_analysis() {
    let source = r#"
        public class Test {
            public void Method() {
                if (true) {
                    for (int i = 0; i &lt; 10; i++) {
                        // complexity += 2
                    }
                }
            }
        }
    "#;
    
    let parser = Parser::new();
    let cu = parser.parse(source).unwrap();
    
    // Find the method and calculate complexity
    // (implementation details depend on analysis API)
    
    assert_eq!(complexity, 3);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li>Add rustdoc comments for public functions and types</li>
<li>Update this documentation when adding new features</li>
<li>Include examples in documentation</li>
</ul>
<h3 id="adding-new-language-features"><a class="header" href="#adding-new-language-features">Adding New Language Features</a></h3>
<p>When adding support for new C# language features:</p>
<ol>
<li><strong>Define AST Nodes</strong>: Add node definitions in <code>src/syntax/nodes/</code></li>
<li><strong>Implement Parser</strong>: Add parser in appropriate <code>src/parser/</code> subdirectory</li>
<li><strong>Add Tests</strong>: Include comprehensive tests in <code>tests/parser/</code> directory</li>
<li><strong>Update Navigation</strong>: Extend navigation traits if needed</li>
<li><strong>Document</strong>: Add documentation for the new feature</li>
</ol>
<p>Example process for adding a new expression type:</p>
<ol>
<li>Define the AST node:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/syntax/nodes/expressions/new_expression.rs
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct NewExpression {
    pub keyword: String,  // "new"
    pub arguments: Vec&lt;Expression&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Add to Expression enum:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/syntax/nodes/expressions/expression.rs
pub enum Expression {
    // ... existing variants
    New(NewExpression),
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Implement parser:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/parser/expressions/new_expression_parser.rs
pub fn parse_new_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, NewExpression&gt; {
    // Parser implementation
}
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li>Add tests:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/parser/expressions/new_expression_tests.rs
#[test]
fn test_parse_new_expression() {
    // Test implementation
}
<span class="boring">}</span></code></pre></pre>
<h2 id="submitting-changes"><a class="header" href="#submitting-changes">Submitting Changes</a></h2>
<h3 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h3>
<ol>
<li>Fork the repository</li>
<li>Create a feature branch: <code>git checkout -b feature/new-feature</code></li>
<li>Make your changes</li>
<li>Run tests: <code>cargo test</code></li>
<li>Run formatting: <code>cargo fmt</code></li>
<li>Run clippy: <code>cargo clippy</code></li>
<li>Commit changes with clear messages</li>
<li>Push to your fork</li>
<li>Create a pull request</li>
</ol>
<h3 id="commit-messages"><a class="header" href="#commit-messages">Commit Messages</a></h3>
<p>Use clear, descriptive commit messages:</p>
<pre><code>feat: add support for C# 11 file-scoped types

- Add parser for file-scoped type declarations
- Update AST to handle new syntax
- Add comprehensive tests
- Update documentation

Fixes #123
</code></pre>
<h3 id="pull-request-requirements"><a class="header" href="#pull-request-requirements">Pull Request Requirements</a></h3>
<ul>
<li>All tests must pass</li>
<li>Code must be formatted with <code>cargo fmt</code></li>
<li>No clippy warnings</li>
<li>Include tests for new functionality</li>
<li>Update documentation if needed</li>
</ul>
<h2 id="common-development-tasks"><a class="header" href="#common-development-tasks">Common Development Tasks</a></h2>
<h3 id="adding-a-new-parser"><a class="header" href="#adding-a-new-parser">Adding a New Parser</a></h3>
<ol>
<li>Define the AST node structure</li>
<li>Implement the parser function</li>
<li>Add the parser to the appropriate module</li>
<li>Write comprehensive tests</li>
<li>Update integration points</li>
</ol>
<h3 id="extending-analysis"><a class="header" href="#extending-analysis">Extending Analysis</a></h3>
<ol>
<li>Define analysis traits if needed</li>
<li>Implement analyzer struct</li>
<li>Add configuration options</li>
<li>Write tests with various scenarios</li>
<li>Update CLI integration</li>
</ol>
<h3 id="debugging-parser-issues"><a class="header" href="#debugging-parser-issues">Debugging Parser Issues</a></h3>
<p>Use these tools for debugging:</p>
<pre><code class="language-bash"># Test specific parser with debug output
RUST_LOG=debug cargo test test_name -- --nocapture

# Run parser on test file
cargo run -- parse debug_cases/test.cs --output debug.json

# Check parse tree structure
cargo run -- tree debug_cases/test.cs --output debug.svg
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li>Check existing issues and documentation</li>
<li>Ask questions in GitHub issues</li>
<li>Join community discussions</li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<ul>
<li>Be respectful and inclusive</li>
<li>Focus on constructive feedback</li>
<li>Help others learn and grow</li>
<li>Maintain a positive environment</li>
</ul>
<p>Thank you for contributing to BSharp!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h1>
<p>This document provides comprehensive guidance on testing in the BSharp project, covering test organization, best practices, and debugging strategies.</p>
<hr />
<h2 id="test-organization-philosophy"><a class="header" href="#test-organization-philosophy">Test Organization Philosophy</a></h2>
<h3 id="external-test-structure"><a class="header" href="#external-test-structure">External Test Structure</a></h3>
<p><strong>Critical Principle:</strong> All parser tests are located in the <code>tests/</code> directory, <strong>NOT</strong> inline within parser modules.</p>
<pre><code>tests/
├── lib.rs                    # Test crate root
├── parser/
│   ├── mod.rs               # Parser test module
│   ├── expressions/
│   │   ├── expression_tests.rs
│   │   ├── lambda_expression_tests.rs
│   │   ├── pattern_matching_tests.rs
│   │   ├── ambiguity_tests.rs
│   │   ├── lookahead_boundaries2_tests.rs
│   │   └── ...
│   ├── statements/
│   │   ├── if_statement_tests.rs
│   │   ├── for_statement_tests.rs
│   │   ├── expression_statement_tests.rs
│   │   └── ...
│   ├── declarations/
│   │   ├── class_declaration_tests.rs
│   │   ├── interface_declaration_parser_tests.rs
│   │   ├── recovery_tests.rs
│   │   └── ...
│   ├── types/
│   │   ├── type_tests.rs
│   │   ├── advanced_type_tests.rs
│   │   └── ...
│   ├── preprocessor/
│   │   └── ...
│   └── keyword_parsers_tests.rs
└── fixtures/
    ├── happy_path/
    │   ├── testApplication/
    │   └── testDependency/
    └── complex/
        ├── testApplication/
        └── testDependency/
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Test code separate from implementation</li>
<li><strong>Compilation Efficiency</strong>: Tests don't bloat production binary</li>
<li><strong>Organization</strong>: Clear structure mirrors parser organization</li>
<li><strong>Maintainability</strong>: Easy to find and update tests</li>
</ul>
<p><strong>What NOT to Do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ NEVER do this in src/parser/ files
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_something() {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What to Do Instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Create tests/parser/expressions/my_feature_tests.rs
use bsharp::syntax::test_helpers::expect_ok;
use bsharp::parser::expressions::parse_my_feature;

#[test]
fn test_my_feature() {
    let input = "my feature syntax";
    let result = parse_my_feature(input);
    let ast = expect_ok(input, result);
    // assertions...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-helpers"><a class="header" href="#test-helpers">Test Helpers</a></h2>
<h3 id="expect_ok---readable-test-failures"><a class="header" href="#expect_ok---readable-test-failures"><code>expect_ok()</code> - Readable Test Failures</a></h3>
<p><strong>Location:</strong> <code>src/syntax/test_helpers.rs</code></p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::syntax::test_helpers::expect_ok;

#[test]
fn test_parse_class() {
    let input = "public class MyClass { }";
    let result = parse_class_declaration(input);
    let class = expect_ok(input, result);
    
    assert_eq!(class.identifier.name, "MyClass");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Automatic Error Formatting</strong>: Pretty-prints <code>ErrorTree</code> on failure</li>
<li><strong>Readable Diagnostics</strong>: Shows parse failure context with caret</li>
<li><strong>Panic on Failure</strong>: Test fails with clear error message</li>
</ul>
<p><strong>Error Output Example:</strong></p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"

1: in context "class declaration"
</code></pre>
<h3 id="other-test-helpers"><a class="header" href="#other-test-helpers">Other Test Helpers</a></h3>
<p><strong><code>parse_input_unwrap()</code></strong> - Unwrap parse result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (remaining, ast) = parse_input_unwrap(parse_expression(input));
assert_eq!(remaining, "");  // Verify full consumption
<span class="boring">}</span></code></pre></pre>
<p><strong><code>assert_parse_error()</code></strong> - Verify parse failures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_parse_error(parse_expression("invalid syntax"));
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parser-testing-best-practices-1"><a class="header" href="#parser-testing-best-practices-1">Parser Testing Best Practices</a></h2>
<h3 id="1-prefer-expect_ok-for-successful-parses"><a class="header" href="#1-prefer-expect_ok-for-successful-parses">1. Prefer <code>expect_ok()</code> for Successful Parses</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_if_statement() {
    let input = "if (x &gt; 0) { return x; }";
    let stmt = expect_ok(input, parse_if_statement(input));
    
    // Now assert on the AST structure
    match stmt {
        Statement::If(if_stmt) =&gt; {
            // Verify condition, consequence, etc.
        }
        _ =&gt; panic!("Expected IfStatement"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-keep-tests-focused-and-minimal"><a class="header" href="#2-keep-tests-focused-and-minimal">2. Keep Tests Focused and Minimal</a></h3>
<p><strong>Good:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_simple_lambda() {
    let input = "x =&gt; x * 2";
    let expr = expect_ok(input, parse_lambda_expression(input));
    // Test one thing
}

#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input));
    // Test another thing
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Bad:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_all_lambda_forms() {
    // Testing too many things in one test
    // Hard to debug when it fails
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-add-negative-tests-for-ambiguity"><a class="header" href="#3-add-negative-tests-for-ambiguity">3. Add Negative Tests for Ambiguity</a></h3>
<p>When disambiguation is possible, add tests for both valid and invalid cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ternary_vs_nullable() {
    // Valid ternary
    let input = "x ? y : z";
    expect_ok(input, parse_conditional_expression(input));
    
    // Valid null-conditional (different test)
}

#[test]
fn test_null_conditional_operator() {
    let input = "obj?.Property";
    expect_ok(input, parse_postfix_expression(input));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-test-lookaheaddisambiguation-boundaries"><a class="header" href="#4-test-lookaheaddisambiguation-boundaries">4. Test Lookahead/Disambiguation Boundaries</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/lookahead_boundaries2_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_range_vs_dot_vs_float() {
    // Range operator
    expect_ok("1..10", parse_range_expression("1..10"));
    
    // Member access
    expect_ok("obj.Method", parse_postfix_expression("obj.Method"));
    
    // Float literal
    expect_ok("3.14", parse_literal("3.14"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-test-complex-constructs"><a class="header" href="#5-test-complex-constructs">5. Test Complex Constructs</a></h3>
<p>For complex constructs like <code>new</code> expressions with initializers:</p>
<p><strong>Location:</strong> <code>tests/parser/expressions/new_expression_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_new_with_object_initializer() {
    let input = "new Person { Name = \"John\", Age = 30 }";
    let expr = expect_ok(input, parse_new_expression(input));
    // Verify structure
}

#[test]
fn test_new_with_collection_initializer() {
    let input = "new List&lt;int&gt; { 1, 2, 3 }";
    let expr = expect_ok(input, parse_new_expression(input));
    // Verify structure
}

#[test]
fn test_target_typed_new() {
    let input = "new(42, \"test\")";
    let expr = expect_ok(input, parse_new_expression(input));
    // Verify structure
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-test-invalid-input-diagnostics"><a class="header" href="#6-test-invalid-input-diagnostics">6. Test Invalid Input Diagnostics</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/invalid_diagnostics_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_unclosed_paren_diagnostic() {
    let input = "(x + y";
    let result = parse_expression(input);
    
    assert!(result.is_err());
    // Optionally check error contains expected message
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Guidelines:</strong></p>
<ul>
<li>Keep small snapshot-style assertions</li>
<li>Check for line/column and caret presence</li>
<li>Avoid overfitting on exact wording (may change)</li>
</ul>
<h3 id="7-guard-closing-delimiters-with-cut"><a class="header" href="#7-guard-closing-delimiters-with-cut">7. Guard Closing Delimiters with <code>cut()</code></a></h3>
<p>When adding delimited constructs, ensure closing delimiters use <code>cut()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::combinator::cut;
use crate::syntax::parser_helpers::{bdelimited, bchar};

fn parse_parenthesized(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    bdelimited(
        bchar('('),
        parse_expression,
        cut(bchar(')'))  // ✅ Prevents misleading backtracking
    )(input)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="8-wrap-sub-parsers-with-bws"><a class="header" href="#8-wrap-sub-parsers-with-bws">8. Wrap Sub-Parsers with <code>bws()</code></a></h3>
<p>Ensure whitespace/comments are handled consistently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::syntax::parser_helpers::bws;

fn parse_if_statement(input: &amp;str) -&gt; BResult&lt;&amp;str, Statement&gt; {
    let (input, _) = bws(keyword("if"))(input)?;
    let (input, _) = bws(bchar('('))(input)?;
    let (input, condition) = bws(parse_expression)(input)?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-discovery-and-execution"><a class="header" href="#test-discovery-and-execution">Test Discovery and Execution</a></h2>
<h3 id="running-all-tests"><a class="header" href="#running-all-tests">Running All Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="running-specific-test-suites"><a class="header" href="#running-specific-test-suites">Running Specific Test Suites</a></h3>
<pre><code class="language-bash"># All parser tests
cargo test --test parser

# Specific module
cargo test --test parser expression_tests

# Specific test
cargo test --test parser test_lambda_expression
</code></pre>
<h3 id="running-with-output"><a class="header" href="#running-with-output">Running with Output</a></h3>
<pre><code class="language-bash"># Show println! output
cargo test -- --nocapture

# Show test names as they run
cargo test -- --nocapture --test-threads=1
</code></pre>
<h3 id="running-with-debug-logging"><a class="header" href="#running-with-debug-logging">Running with Debug Logging</a></h3>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_name -- --nocapture
</code></pre>
<hr />
<h2 id="test-fixtures-1"><a class="header" href="#test-fixtures-1">Test Fixtures</a></h2>
<h3 id="fixture-organization"><a class="header" href="#fixture-organization">Fixture Organization</a></h3>
<pre><code>tests/fixtures/
├── happy_path/           # Valid, well-formed C# projects
│   ├── testApplication/
│   │   ├── Program.cs
│   │   ├── testApplication.csproj
│   │   └── ...
│   └── testDependency/
│       └── ...
└── complex/              # Complex, real-world scenarios
    ├── testApplication/
    └── testDependency/
</code></pre>
<h3 id="using-fixtures-in-tests"><a class="header" href="#using-fixtures-in-tests">Using Fixtures in Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::PathBuf;

#[test]
fn test_parse_fixture() {
    let fixture_path = PathBuf::from("tests/fixtures/happy_path/testApplication/Program.cs");
    let source = fs::read_to_string(&amp;fixture_path).unwrap();
    
    let parser = Parser::new();
    let result = parser.parse(&amp;source);
    
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fixture-guidelines"><a class="header" href="#fixture-guidelines">Fixture Guidelines</a></h3>
<ul>
<li><strong>Valid Code</strong>: Fixtures should be valid C# that compiles</li>
<li><strong>Realistic</strong>: Use real-world patterns, not contrived examples</li>
<li><strong>Documented</strong>: Add README.md explaining fixture purpose</li>
<li><strong>Minimal</strong>: Keep fixtures as small as possible while testing feature</li>
</ul>
<hr />
<h2 id="snapshot-testing"><a class="header" href="#snapshot-testing">Snapshot Testing</a></h2>
<h3 id="using-insta-for-snapshot-tests"><a class="header" href="#using-insta-for-snapshot-tests">Using <code>insta</code> for Snapshot Tests</a></h3>
<p><strong>Installation:</strong> Already included in <code>Cargo.toml</code> dev-dependencies</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use insta::assert_json_snapshot;

#[test]
fn test_class_ast_structure() {
    let input = "public class MyClass { public int Field; }";
    let result = parse_class_declaration(input);
    let class = expect_ok(input, result);
    
    // Creates snapshot file on first run
    assert_json_snapshot!(class);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reviewing-snapshots"><a class="header" href="#reviewing-snapshots">Reviewing Snapshots</a></h3>
<pre><code class="language-bash"># Review snapshot changes
cargo insta review

# Accept all changes
cargo insta accept

# Reject all changes
cargo insta reject
</code></pre>
<h3 id="snapshot-guidelines"><a class="header" href="#snapshot-guidelines">Snapshot Guidelines</a></h3>
<ul>
<li><strong>Complex Structures</strong>: Use for complex AST structures</li>
<li><strong>Regression Prevention</strong>: Catch unintended changes</li>
<li><strong>Review Carefully</strong>: Always review snapshot diffs</li>
<li><strong>Commit Snapshots</strong>: Include snapshot files in git</li>
</ul>
<hr />
<h2 id="debugging-test-failures"><a class="header" href="#debugging-test-failures">Debugging Test Failures</a></h2>
<h3 id="strategy-1-use-expect_ok-error-output"><a class="header" href="#strategy-1-use-expect_ok-error-output">Strategy 1: Use <code>expect_ok()</code> Error Output</a></h3>
<p>When a test fails, <code>expect_ok()</code> shows the parse error:</p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"
</code></pre>
<h3 id="strategy-2-add-debug-logging"><a class="header" href="#strategy-2-add-debug-logging">Strategy 2: Add Debug Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_with_logging() {
    env_logger::init();  // Initialize logger
    
    let input = "complex syntax";
    log::debug!("Parsing: {}", input);
    
    let result = parse_expression(input);
    log::debug!("Result: {:?}", result);
    
    expect_ok(input, result);
}
<span class="boring">}</span></code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_with_logging -- --nocapture
</code></pre>
<h3 id="strategy-3-test-smaller-components"><a class="header" href="#strategy-3-test-smaller-components">Strategy 3: Test Smaller Components</a></h3>
<p>If a complex parser fails, test its sub-parsers individually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_method_declaration() {
    // Fails - too complex
    let input = "public async Task&lt;int&gt; Method(int x) { return x; }";
    expect_ok(input, parse_method_declaration(input));
}

// Break it down:

#[test]
fn test_method_modifiers() {
    let input = "public async";
    expect_ok(input, parse_modifiers(input));
}

#[test]
fn test_method_return_type() {
    let input = "Task&lt;int&gt;";
    expect_ok(input, parse_type(input));
}

#[test]
fn test_method_parameters() {
    let input = "(int x)";
    expect_ok(input, parse_parameter_list(input));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-4-use-parser-debugging-tools"><a class="header" href="#strategy-4-use-parser-debugging-tools">Strategy 4: Use Parser Debugging Tools</a></h3>
<pre><code class="language-bash"># Parse file and output JSON
cargo run -- parse debug_cases/test.cs --output debug.json

# Generate AST visualization
cargo run -- tree debug_cases/test.cs --output debug.svg
</code></pre>
<h3 id="strategy-5-check-error-recovery"><a class="header" href="#strategy-5-check-error-recovery">Strategy 5: Check Error Recovery</a></h3>
<p>For declaration error recovery tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_recovery_from_malformed_member() {
    let input = r#"
    public class MyClass {
        public int ValidField;
        public invalid syntax here;  // Malformed
        public int AnotherValidField;  // Should recover
    }
    "#;
    
    let result = parse_class_declaration(input);
    // Should parse despite error
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="workspace-loading-tests"><a class="header" href="#workspace-loading-tests">Workspace Loading Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::workspace::WorkspaceLoader;

#[test]
fn test_load_solution() {
    let sln_path = PathBuf::from("tests/fixtures/happy_path/test.sln");
    let workspace = WorkspaceLoader::from_path(&amp;sln_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 2);
    assert!(workspace.solution.is_some());
}

#[test]
fn test_load_csproj() {
    let csproj_path = PathBuf::from("tests/fixtures/happy_path/testApplication/testApplication.csproj");
    let workspace = WorkspaceLoader::from_path(&amp;csproj_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="analysis-pipeline-tests"><a class="header" href="#analysis-pipeline-tests">Analysis Pipeline Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::framework::pipeline::AnalyzerPipeline;
use bsharp::analysis::framework::session::AnalysisSession;

#[test]
fn test_analysis_pipeline() {
    let source = "public class Test { public void Method() { } }";
    let parser = Parser::new();
    let cu = parser.parse(source).unwrap();
    
    let mut session = AnalysisSession::new();
    AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
    
    let report = session.into_report();
    assert!(report.diagnostics.is_empty());  // No errors
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]  // Run with --ignored flag
fn bench_parse_large_file() {
    use std::time::Instant;
    
    let source = fs::read_to_string("tests/fixtures/large_file.cs").unwrap();
    let parser = Parser::new();
    
    let start = Instant::now();
    let result = parser.parse(&amp;source);
    let duration = start.elapsed();
    
    assert!(result.is_ok());
    println!("Parse time: {:?}", duration);
    
    // Assert reasonable performance
    assert!(duration.as_millis() &lt; 1000, "Parse took too long");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="running-performance-tests"><a class="header" href="#running-performance-tests">Running Performance Tests</a></h3>
<pre><code class="language-bash">cargo test --ignored -- bench_
</code></pre>
<hr />
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="ci-test-strategy"><a class="header" href="#ci-test-strategy">CI Test Strategy</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml (example)
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Run tests
        run: cargo test --all-features
      - name: Run clippy
        run: cargo clippy -- -D warnings
      - name: Check formatting
        run: cargo fmt -- --check
</code></pre>
<hr />
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<h3 id="measuring-coverage"><a class="header" href="#measuring-coverage">Measuring Coverage</a></h3>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Run coverage
cargo tarpaulin --out Html --output-dir coverage
</code></pre>
<h3 id="coverage-goals"><a class="header" href="#coverage-goals">Coverage Goals</a></h3>
<ul>
<li><strong>Parser Core</strong>: 90%+ coverage</li>
<li><strong>Analysis Framework</strong>: 80%+ coverage</li>
<li><strong>CLI Commands</strong>: 70%+ coverage</li>
<li><strong>Workspace Loading</strong>: 80%+ coverage</li>
</ul>
<hr />
<h2 id="common-testing-patterns"><a class="header" href="#common-testing-patterns">Common Testing Patterns</a></h2>
<h3 id="pattern-1-positive-and-negative-tests"><a class="header" href="#pattern-1-positive-and-negative-tests">Pattern 1: Positive and Negative Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_valid_syntax() {
    let input = "valid syntax";
    expect_ok(input, parse_feature(input));
}

#[test]
fn test_invalid_syntax() {
    let input = "invalid syntax";
    assert!(parse_feature(input).is_err());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-boundary-testing"><a class="header" href="#pattern-2-boundary-testing">Pattern 2: Boundary Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_empty_input() {
    assert!(parse_feature("").is_err());
}

#[test]
fn test_minimal_input() {
    expect_ok("x", parse_feature("x"));
}

#[test]
fn test_maximal_input() {
    let input = "very complex nested structure...";
    expect_ok(input, parse_feature(input));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-equivalence-testing"><a class="header" href="#pattern-3-equivalence-testing">Pattern 3: Equivalence Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_whitespace_insensitive() {
    let compact = "if(x){y;}";
    let spaced = "if (x) { y; }";
    
    let ast1 = expect_ok(compact, parse_if_statement(compact));
    let ast2 = expect_ok(spaced, parse_if_statement(spaced));
    
    assert_eq!(ast1, ast2);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-maintenance"><a class="header" href="#test-maintenance">Test Maintenance</a></h2>
<h3 id="when-to-update-tests"><a class="header" href="#when-to-update-tests">When to Update Tests</a></h3>
<ol>
<li><strong>API Changes</strong>: Update tests when parser API changes</li>
<li><strong>Bug Fixes</strong>: Add regression tests for fixed bugs</li>
<li><strong>New Features</strong>: Add tests for new language features</li>
<li><strong>Refactoring</strong>: Ensure tests still pass after refactoring</li>
</ol>
<h3 id="test-cleanup"><a class="header" href="#test-cleanup">Test Cleanup</a></h3>
<ul>
<li><strong>Remove Duplicate Tests</strong>: Consolidate similar tests</li>
<li><strong>Update Outdated Tests</strong>: Fix tests using deprecated APIs</li>
<li><strong>Remove Dead Tests</strong>: Delete tests for removed features</li>
<li><strong>Improve Names</strong>: Use descriptive test names</li>
</ul>
<h3 id="test-documentation"><a class="header" href="#test-documentation">Test Documentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tests that lambda expressions with multiple parameters are parsed correctly.
/// 
/// This test verifies:
/// - Parameter list parsing
/// - Arrow token recognition
/// - Expression body parsing
#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input));
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="testing-checklist"><a class="header" href="#testing-checklist">Testing Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Tests in <code>tests/</code> directory, not inline</li>
<li><input disabled="" type="checkbox"/>
Use <code>expect_ok()</code> for readable failures</li>
<li><input disabled="" type="checkbox"/>
Keep tests focused and minimal</li>
<li><input disabled="" type="checkbox"/>
Add negative tests for ambiguity</li>
<li><input disabled="" type="checkbox"/>
Test lookahead/disambiguation boundaries</li>
<li><input disabled="" type="checkbox"/>
Test complex constructs thoroughly</li>
<li><input disabled="" type="checkbox"/>
Use <code>cut()</code> for closing delimiters</li>
<li><input disabled="" type="checkbox"/>
Wrap sub-parsers with <code>bws()</code></li>
<li><input disabled="" type="checkbox"/>
Add fixtures for integration tests</li>
<li><input disabled="" type="checkbox"/>
Use snapshot tests for complex structures</li>
<li><input disabled="" type="checkbox"/>
Document test purpose and coverage</li>
</ul>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<ul>
<li><strong>Test Helpers</strong>: <code>src/syntax/test_helpers.rs</code></li>
<li><strong>Example Tests</strong>: <code>tests/parser/expressions/</code></li>
<li><strong>Fixtures</strong>: <code>tests/fixtures/</code></li>
<li><strong>Contributing Guide</strong>: <code>docs/development/contributing.md</code></li>
<li><strong>Architecture</strong>: <code>docs/development/architecture.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decisions"><a class="header" href="#architecture-decisions">Architecture Decisions</a></h1>
<p>This document explains the key architectural decisions made in the BSharp project, their rationale, and their implications for contributors.</p>
<hr />
<h2 id="core-design-philosophy"><a class="header" href="#core-design-philosophy">Core Design Philosophy</a></h2>
<p>BSharp is designed as a <strong>modular, extensible C# parser and analysis toolkit</strong> written in Rust. The architecture prioritizes:</p>
<ol>
<li><strong>Correctness</strong> - Accurate parsing of C# syntax</li>
<li><strong>Performance</strong> - Efficient parsing and analysis of large codebases</li>
<li><strong>Maintainability</strong> - Clear module boundaries and minimal coupling</li>
<li><strong>Extensibility</strong> - Easy addition of new language features and analyzers</li>
</ol>
<hr />
<h2 id="parser-architecture"><a class="header" href="#parser-architecture">Parser Architecture</a></h2>
<h3 id="why-nom-parser-combinators"><a class="header" href="#why-nom-parser-combinators">Why nom Parser Combinators?</a></h3>
<p><strong>Decision:</strong> Use the <code>nom</code> parser combinator library as the foundation for parsing.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Composability</strong>: Small, focused parsers combine to handle complex syntax</li>
<li><strong>Type Safety</strong>: Rust's type system catches parser errors at compile time</li>
<li><strong>Performance</strong>: Zero-copy parsing with minimal allocations</li>
<li><strong>Testability</strong>: Individual parser functions are easily unit tested</li>
<li><strong>Maintainability</strong>: Declarative style is easier to understand than hand-written parsers</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<ul>
<li>Learning curve for contributors unfamiliar with parser combinators</li>
<li>Error messages require additional work (addressed with nom-supreme)</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li>Core parsing infrastructure: <code>src/syntax/parser_helpers.rs</code></li>
<li>Parser implementations: <code>src/parser/</code></li>
<li>All parsers return <code>BResult&lt;I, O&gt;</code> type alias</li>
</ul>
<h3 id="error-handling-strategy-1"><a class="header" href="#error-handling-strategy-1">Error Handling Strategy</a></h3>
<p><strong>Decision:</strong> Use <code>nom-supreme::ErrorTree</code> for all parser errors.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Rich Context</strong>: Tree structure preserves full parse failure path</li>
<li><strong>Better Diagnostics</strong>: Context annotations via <code>.context()</code> method</li>
<li><strong>Integration</strong>: Seamless integration with nom combinators</li>
<li><strong>Debugging</strong>: Pretty-printing via <code>format_error_tree()</code></li>
</ul>
<p><strong>Evolution:</strong></p>
<ul>
<li>Initially used custom <code>BSharpParseError</code> type</li>
<li>Migrated to <code>ErrorTree</code> for better diagnostics</li>
<li>Custom error type deprecated and removed</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BResult&lt;I, O&gt; = IResult&lt;I, O, ErrorTree&lt;I&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Helper Functions:</strong></p>
<ul>
<li><code>context()</code> - Adds contextual information</li>
<li><code>cut()</code> - Commits to parse branch (prevents misleading backtracking)</li>
<li><code>bws()</code> - Whitespace-aware wrapper with error context</li>
<li><code>bdelimited()</code> - Delimited parsing with cut on closing delimiter</li>
</ul>
<h3 id="module-organization"><a class="header" href="#module-organization">Module Organization</a></h3>
<p><strong>Decision:</strong> Separate <code>parser/</code> (implementations) from <code>syntax/</code> (infrastructure).</p>
<p><strong>Structure:</strong></p>
<pre><code>src/
├── parser/           # Parser implementations
│   ├── expressions/  # Expression parsers
│   ├── keywords/     # Keyword parsing (modularized)
│   ├── types/        # Type system parsers
│   └── ...
├── syntax/           # Parser infrastructure
│   ├── ast.rs        # Root AST definitions
│   ├── nodes/        # AST node definitions
│   ├── parser_helpers.rs  # Parsing utilities
│   ├── errors.rs     # Error formatting
│   └── ...
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Infrastructure vs implementation</li>
<li><strong>Reusability</strong>: Helpers used across all parsers</li>
<li><strong>API Clarity</strong>: <code>syntax</code> module is the public API</li>
<li><strong>Testing</strong>: Infrastructure can be tested independently</li>
</ul>
<h3 id="keyword-modularization"><a class="header" href="#keyword-modularization">Keyword Modularization</a></h3>
<p><strong>Decision:</strong> Organize keywords by category in dedicated modules.</p>
<p><strong>Structure:</strong></p>
<pre><code>src/parser/keywords/
├── mod.rs                      # Keyword infrastructure
├── access_keywords.rs          # public, private, protected, internal
├── accessor_keywords.rs        # get, set, init, add, remove
├── type_keywords.rs            # class, struct, interface, enum, record
├── modifier_keywords.rs        # static, abstract, virtual, sealed
├── flow_control_keywords.rs    # if, else, switch, case, default
├── iteration_keywords.rs       # for, foreach, while, do
├── expression_keywords.rs      # new, this, base, typeof, sizeof
├── linq_query_keywords.rs      # from, where, select, orderby
└── ...
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Maintainability</strong>: Easy to find and update keyword parsers</li>
<li><strong>Consistency</strong>: Uniform keyword parsing strategy</li>
<li><strong>Word Boundaries</strong>: All keywords use <code>keyword()</code> helper for boundary checking</li>
<li><strong>Prevents Bugs</strong>: Avoids partial matches (e.g., "int" vs "int32")</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>keyword()</code> function enforces <code>[A-Za-z0-9_]</code> word boundaries</li>
<li>Macro-based keyword parser generation for consistency</li>
<li>Centralized keyword list prevents drift</li>
</ul>
<hr />
<h2 id="ast-design"><a class="header" href="#ast-design">AST Design</a></h2>
<h3 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h3>
<p><strong>Decision:</strong> Use PascalCase names without 'Syntax' suffix for all AST nodes.</p>
<p><strong>Examples:</strong></p>
<ul>
<li><code>ClassDeclaration</code> (not <code>ClassDeclarationSyntax</code>)</li>
<li><code>MethodDeclaration</code> (not <code>MethodDeclarationSyntax</code>)</li>
<li><code>ExpressionStatement</code> (not <code>ExpressionStatementSyntax</code>)</li>
<li><code>IfStatement</code> (not <code>IfStatementSyntax</code>)</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Clarity</strong>: Shorter, clearer names</li>
<li><strong>Roslyn Inspiration</strong>: Mirrors Roslyn's structure where appropriate</li>
<li><strong>Consistency</strong>: Uniform naming across entire codebase</li>
<li><strong>User Preference</strong>: Explicit design decision (documented in memories)</li>
</ul>
<p><strong>Implications:</strong></p>
<ul>
<li>All AST node types follow this convention</li>
<li>Test code uses these names</li>
<li>Documentation uses these names</li>
<li>Breaking change from earlier versions with 'Syntax' suffix</li>
</ul>
<h3 id="ast-ownership-model"><a class="header" href="#ast-ownership-model">AST Ownership Model</a></h3>
<p><strong>Decision:</strong> Parent nodes own their children; no circular references.</p>
<p><strong>Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ClassDeclaration {
    pub attributes: Vec&lt;Attribute&gt;,
    pub modifiers: Vec&lt;Modifier&gt;,
    pub identifier: Identifier,
    pub type_parameters: Option&lt;Vec&lt;TypeParameter&gt;&gt;,
    pub base_types: Vec&lt;Type&gt;,
    pub body_declarations: Vec&lt;ClassBodyDeclaration&gt;,  // Owned
    pub type_parameter_constraints: Vec&lt;TypeParameterConstraint&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Rust Ownership</strong>: Leverages Rust's ownership system</li>
<li><strong>Memory Safety</strong>: No reference cycles or lifetime complexity</li>
<li><strong>Simplicity</strong>: Clear ownership semantics</li>
<li><strong>Traversal</strong>: Navigation traits provide search without ownership issues</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<ul>
<li>Cannot directly reference parent from child</li>
<li>Navigation requires traversal from root</li>
<li>Mitigated by <code>AstNavigate</code> and <code>FindDeclarations</code> traits</li>
</ul>
<h3 id="zero-copy-parsing-1"><a class="header" href="#zero-copy-parsing-1">Zero-Copy Parsing</a></h3>
<p><strong>Decision:</strong> Minimize string allocations during parsing where possible.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>String slices reference original input</li>
<li>Identifiers store <code>String</code> (owned) for convenience</li>
<li>Literals preserve original format as <code>String</code></li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Performance</strong>: Reduces allocation overhead</li>
<li><strong>Memory Efficiency</strong>: Lower memory footprint</li>
<li><strong>Trade-off</strong>: Some allocations necessary for AST lifetime</li>
</ul>
<hr />
<h2 id="analysis-framework"><a class="header" href="#analysis-framework">Analysis Framework</a></h2>
<h3 id="framework-driven-architecture"><a class="header" href="#framework-driven-architecture">Framework-Driven Architecture</a></h3>
<p><strong>Decision:</strong> Implement a pipeline-based analysis framework with passes, rules, and visitors.</p>
<p><strong>Structure:</strong></p>
<pre><code>src/analysis/
├── framework/        # Core analysis infrastructure
│   ├── pipeline.rs   # Analysis pipeline orchestration
│   ├── passes.rs     # Analysis pass trait and phases
│   ├── rules.rs      # Rule trait and rulesets
│   ├── walker.rs     # AST walker and visitor pattern
│   ├── registry.rs   # Analyzer registry
│   └── session.rs    # Analysis session and state
├── passes/           # Concrete analysis passes
├── rules/            # Concrete analysis rules
├── artifacts/        # Analysis artifacts (symbols, metrics, CFG)
└── ...
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Extensibility</strong>: Easy to add new analyzers</li>
<li><strong>Composability</strong>: Passes and rules compose via registry</li>
<li><strong>Performance</strong>: Single-pass traversal for local rules</li>
<li><strong>Configurability</strong>: Enable/disable passes and rules via config</li>
</ul>
<p><strong>Phases:</strong></p>
<ol>
<li><strong>Index</strong> - Symbol indexing and scope building</li>
<li><strong>Local</strong> - Single-pass local rules and metrics collection</li>
<li><strong>Global</strong> - Cross-file analysis (dependencies, etc.)</li>
<li><strong>Semantic</strong> - Type checking and semantic rules</li>
<li><strong>Reporting</strong> - Report generation and formatting</li>
</ol>
<h3 id="visitor-pattern"><a class="header" href="#visitor-pattern">Visitor Pattern</a></h3>
<p><strong>Decision:</strong> Use visitor pattern for AST traversal.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Visit {
    fn enter(&amp;mut self, node: &amp;NodeRef, session: &amp;mut AnalysisSession);
    fn exit(&amp;mut self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {}
}

pub struct AstWalker {
    visitors: Vec&lt;Box&lt;dyn Visit&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Traversal logic separate from analysis logic</li>
<li><strong>Composability</strong>: Multiple visitors in single traversal</li>
<li><strong>Performance</strong>: Single pass for multiple analyses</li>
<li><strong>Extensibility</strong>: Easy to add new visitors</li>
</ul>
<h3 id="navigation-traits-1"><a class="header" href="#navigation-traits-1">Navigation Traits</a></h3>
<p><strong>Decision:</strong> Provide <code>AstNavigate</code> and <code>FindDeclarations</code> traits for AST search.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>AstNavigate</code> - Find statements (if, for, while, switch, try, using)</li>
<li><code>FindDeclarations</code> - Find declarations (classes, methods, interfaces, etc.)</li>
<li>Implemented for <code>CompilationUnit</code> and major AST nodes</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Convenience</strong>: High-level search API</li>
<li><strong>Reusability</strong>: Common patterns extracted</li>
<li><strong>Type Safety</strong>: Returns strongly-typed results</li>
<li><strong>CLI Integration</strong>: Used by analyze command for symbol search</li>
</ul>
<hr />
<h2 id="workspace-loading-1"><a class="header" href="#workspace-loading-1">Workspace Loading</a></h2>
<h3 id="multi-format-support"><a class="header" href="#multi-format-support">Multi-Format Support</a></h3>
<p><strong>Decision:</strong> Support loading from .sln, .csproj, or directory.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WorkspaceLoader;

impl WorkspaceLoader {
    pub fn from_path(path: &amp;Path) -&gt; Result&lt;Workspace&gt;;
    pub fn from_path_with_options(path: &amp;Path, opts: WorkspaceLoadOptions) -&gt; Result&lt;Workspace&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Flexibility</strong>: Support different entry points</li>
<li><strong>IDE Integration</strong>: Match IDE project loading behavior</li>
<li><strong>Incremental Analysis</strong>: Load only what's needed</li>
</ul>
<p><strong>Features:</strong></p>
<ul>
<li>Solution file (.sln) parsing</li>
<li>Project file (.csproj) parsing with XML</li>
<li>Transitive ProjectReference following</li>
<li>Source file discovery with glob patterns</li>
<li>Deterministic project ordering</li>
</ul>
<h3 id="error-resilience"><a class="header" href="#error-resilience">Error Resilience</a></h3>
<p><strong>Decision:</strong> Continue loading workspace even if individual projects fail.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>Failed projects recorded as stubs with error messages</li>
<li>Workspace loading succeeds with partial results</li>
<li>Errors accessible via <code>Project::errors</code> field</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Robustness</strong>: Don't fail entire workspace for one bad project</li>
<li><strong>User Experience</strong>: Show what can be analyzed</li>
<li><strong>Debugging</strong>: Error messages preserved for investigation</li>
</ul>
<hr />
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h2>
<h3 id="external-test-organization"><a class="header" href="#external-test-organization">External Test Organization</a></h3>
<p><strong>Decision:</strong> All parser tests in <code>tests/</code> directory, not inline <code>#[cfg(test)]</code> modules.</p>
<p><strong>Structure:</strong></p>
<pre><code>tests/
├── parser/
│   ├── expressions/
│   │   ├── expression_tests.rs
│   │   ├── lambda_expression_tests.rs
│   │   └── ...
│   ├── statements/
│   │   ├── if_statement_tests.rs
│   │   └── ...
│   ├── declarations/
│   │   ├── class_declaration_tests.rs
│   │   └── ...
│   └── types/
│       └── type_tests.rs
└── fixtures/
    ├── happy_path/
    └── complex/
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation</strong>: Test code separate from implementation</li>
<li><strong>Organization</strong>: Clear test structure mirrors parser structure</li>
<li><strong>Compilation</strong>: Tests don't bloat production binary</li>
<li><strong>User Preference</strong>: Explicit design decision (documented in memories)</li>
</ul>
<p><strong>Implications:</strong></p>
<ul>
<li>NO <code>#[cfg(test)] mod tests {}</code> in <code>src/parser/</code> files</li>
<li>All tests use <code>tests/parser/</code> structure</li>
<li>Test helpers in <code>src/syntax/test_helpers.rs</code></li>
</ul>
<h3 id="test-helpers-1"><a class="header" href="#test-helpers-1">Test Helpers</a></h3>
<p><strong>Decision:</strong> Provide <code>expect_ok()</code> helper for readable test failures.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn expect_ok&lt;T&gt;(input: &amp;str, result: BResult&lt;&amp;str, T&gt;) -&gt; T {
    match result {
        Ok((_, value)) =&gt; value,
        Err(e) =&gt; {
            eprintln!("{}", format_error_tree(&amp;input, &amp;e));
            panic!("Parse failed");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Diagnostics</strong>: Pretty-printed errors on failure</li>
<li><strong>Debugging</strong>: Shows parse failure context</li>
<li><strong>Consistency</strong>: Uniform test error reporting</li>
</ul>
<h3 id="snapshot-testing-1"><a class="header" href="#snapshot-testing-1">Snapshot Testing</a></h3>
<p><strong>Decision:</strong> Use <code>insta</code> crate for snapshot testing.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>Cargo.toml</code> includes <code>insta</code> in dev-dependencies</li>
<li>Snapshot tests for complex AST structures</li>
<li>JSON serialization for comparison</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Regression Prevention</strong>: Catch unintended AST changes</li>
<li><strong>Review</strong>: Visual diff of AST changes</li>
<li><strong>Maintenance</strong>: Update snapshots when intentional</li>
</ul>
<hr />
<h2 id="performance-considerations-4"><a class="header" href="#performance-considerations-4">Performance Considerations</a></h2>
<h3 id="parallel-analysis-1"><a class="header" href="#parallel-analysis-1">Parallel Analysis</a></h3>
<p><strong>Decision:</strong> Optional parallel analysis via <code>rayon</code> feature.</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-toml">[features]
parallel_analysis = ["rayon"]
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Scalability</strong>: Faster analysis for large workspaces</li>
<li><strong>Optional</strong>: Not required for single-file use cases</li>
<li><strong>Trade-off</strong>: Adds dependency and complexity</li>
</ul>
<h3 id="incremental-parsing"><a class="header" href="#incremental-parsing">Incremental Parsing</a></h3>
<p><strong>Decision:</strong> Not implemented yet; designed for future addition.</p>
<p><strong>Future Design:</strong></p>
<ul>
<li>Cache parsed ASTs by file hash</li>
<li>Reparse only changed files</li>
<li>Incremental analysis based on change scope</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Performance</strong>: Critical for IDE integration</li>
<li><strong>Complexity</strong>: Requires careful cache invalidation</li>
<li><strong>Priority</strong>: Deferred until core features stable</li>
</ul>
<hr />
<h2 id="compiler-backend"><a class="header" href="#compiler-backend">Compiler Backend</a></h2>
<h3 id="cranelift-integration"><a class="header" href="#cranelift-integration">Cranelift Integration</a></h3>
<p><strong>Decision:</strong> Use Cranelift as the code generation backend.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>src/codegen/</code> - Code generation infrastructure</li>
<li><code>src/compiler.rs</code> - Compilation orchestration</li>
<li>Cranelift dependencies in <code>Cargo.toml</code></li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Performance</strong>: Fast JIT and AOT compilation</li>
<li><strong>Portability</strong>: Cross-platform code generation</li>
<li><strong>Rust Integration</strong>: Well-integrated with Rust ecosystem</li>
<li><strong>Simplicity</strong>: Simpler than LLVM for initial implementation</li>
</ul>
<p><strong>Status:</strong></p>
<ul>
<li>Basic infrastructure in place</li>
<li>Full compilation pipeline under development</li>
</ul>
<hr />
<h2 id="cli-design"><a class="header" href="#cli-design">CLI Design</a></h2>
<h3 id="subcommand-structure"><a class="header" href="#subcommand-structure">Subcommand Structure</a></h3>
<p><strong>Decision:</strong> Use <code>clap</code> with subcommands for different operations.</p>
<p><strong>Commands:</strong></p>
<ul>
<li><code>parse</code> - Parse C# file to JSON</li>
<li><code>tree</code> - Generate SVG visualization</li>
<li><code>compile</code> - Compile C# file</li>
<li><code>analyze</code> - Run analysis and generate report</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Clarity</strong>: Each command has clear purpose</li>
<li><strong>Extensibility</strong>: Easy to add new commands</li>
<li><strong>Discoverability</strong>: <code>--help</code> shows all options</li>
<li><strong>Consistency</strong>: Follows common CLI patterns</li>
</ul>
<h3 id="output-formats-1"><a class="header" href="#output-formats-1">Output Formats</a></h3>
<p><strong>Decision:</strong> Support multiple output formats (JSON, pretty-JSON, SVG).</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>JSON for machine consumption</li>
<li>Pretty-JSON for human readability</li>
<li>SVG for visualization</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Integration</strong>: JSON for tool integration</li>
<li><strong>Debugging</strong>: Pretty-JSON for manual inspection</li>
<li><strong>Visualization</strong>: SVG for understanding AST structure</li>
</ul>
<hr />
<h2 id="future-extensibility"><a class="header" href="#future-extensibility">Future Extensibility</a></h2>
<h3 id="planned-enhancements"><a class="header" href="#planned-enhancements">Planned Enhancements</a></h3>
<ol>
<li>
<p><strong>Incremental Parsing</strong></p>
<ul>
<li>Cache parsed ASTs</li>
<li>Reparse only changed regions</li>
<li>Critical for IDE integration</li>
</ul>
</li>
<li>
<p><strong>Language Server Protocol (LSP)</strong></p>
<ul>
<li>IDE integration</li>
<li>Real-time diagnostics</li>
<li>Code completion</li>
</ul>
</li>
<li>
<p><strong>More Analysis Passes</strong></p>
<ul>
<li>Nullability analysis</li>
<li>Lifetime analysis</li>
<li>Security analysis</li>
</ul>
</li>
<li>
<p><strong>Code Transformation</strong></p>
<ul>
<li>AST modification API</li>
<li>Code generation from AST</li>
<li>Refactoring support</li>
</ul>
</li>
</ol>
<h3 id="design-for-extension"><a class="header" href="#design-for-extension">Design for Extension</a></h3>
<p><strong>Principles:</strong></p>
<ul>
<li><strong>Trait-Based</strong>: Use traits for extensibility points</li>
<li><strong>Registry Pattern</strong>: Dynamic registration of analyzers</li>
<li><strong>Configuration</strong>: Enable/disable features via config</li>
<li><strong>Versioning</strong>: Stable API with clear versioning</li>
</ul>
<hr />
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<h3 id="what-worked-well"><a class="header" href="#what-worked-well">What Worked Well</a></h3>
<ol>
<li><strong>Parser Combinators</strong>: Excellent for composability and testing</li>
<li><strong>Module Organization</strong>: Clear boundaries reduce coupling</li>
<li><strong>Error Context</strong>: <code>ErrorTree</code> provides excellent diagnostics</li>
<li><strong>External Tests</strong>: Clean separation improves maintainability</li>
</ol>
<h3 id="what-wed-do-differently"><a class="header" href="#what-wed-do-differently">What We'd Do Differently</a></h3>
<ol>
<li><strong>Earlier Keyword Modularization</strong>: Should have organized keywords from start</li>
<li><strong>Error Type Migration</strong>: Earlier adoption of <code>ErrorTree</code> would have saved refactoring</li>
<li><strong>Documentation</strong>: More inline documentation from the beginning</li>
</ol>
<h3 id="recent-refactoring"><a class="header" href="#recent-refactoring">Recent Refactoring</a></h3>
<p>Major refactoring improvements completed:</p>
<ul>
<li>Expression precedence chain builder implemented</li>
<li>Statement group deduplication completed</li>
<li>Consistent error recovery with <code>skip_to_member_boundary_top_level()</code></li>
<li>Whitespace handling standardization via <code>bws()</code> combinator</li>
<li>Keyword modularization by category</li>
</ul>
<hr />
<h2 id="contributing-guidelines"><a class="header" href="#contributing-guidelines">Contributing Guidelines</a></h2>
<p>When adding new features, follow these architectural principles:</p>
<ol>
<li><strong>Use Existing Patterns</strong>: Follow established parser patterns</li>
<li><strong>Add Tests</strong>: External tests in <code>tests/</code> directory</li>
<li><strong>Document Decisions</strong>: Update this file for significant changes</li>
<li><strong>Error Context</strong>: Add <code>.context()</code> calls for debugging</li>
<li><strong>Naming Convention</strong>: PascalCase without 'Syntax' suffix</li>
<li><strong>Keyword Boundaries</strong>: Use <code>keyword()</code> helper for all keywords</li>
</ol>
<p>See <code>docs/development/contributing.md</code> for detailed contribution guidelines.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
