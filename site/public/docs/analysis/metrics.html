<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Metrics Collection - BSharp C# Parser Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BSharp C# Parser Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h1>
<p>The BSharp metrics system collects comprehensive code metrics during analysis to assess code complexity, size, and maintainability.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/metrics/</code></p>
<p>The metrics system provides:</p>
<ul>
<li><strong>Basic Metrics</strong> - Lines of code, statement counts, declaration counts</li>
<li><strong>Complexity Metrics</strong> - Cyclomatic complexity, cognitive complexity, nesting depth</li>
<li><strong>Maintainability Metrics</strong> - Maintainability index, Halstead metrics</li>
</ul>
<hr />
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<pre><code>src/bsharp_analysis/src/metrics/
├── core.rs     # AstAnalysis data structure (aggregated counts)
└── shared.rs   # Helpers: decision_points, max_nesting_of, count_statements, etc.
</code></pre>
<h3 id="how-metrics-are-produced"><a class="header" href="#how-metrics-are-produced">How metrics are produced</a></h3>
<ul>
<li><code>MetricsPass</code> runs in <code>Phase::LocalRules</code> and computes an <code>AstAnalysis</code> artifact using the Query API to enumerate declarations, plus lightweight walkers for statement counts.</li>
<li>Access <code>AstAnalysis</code> from <code>AnalysisSession</code> after running the pipeline.</li>
</ul>
<hr />
<h2 id="metric-types"><a class="header" href="#metric-types">Metric Types</a></h2>
<h3 id="1-basic-metrics"><a class="header" href="#1-basic-metrics">1. Basic Metrics</a></h3>
<p><strong>AstAnalysis Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AstAnalysis {
    // Size metrics
    pub total_lines: usize,
    pub code_lines: usize,
    pub comment_lines: usize,
    pub blank_lines: usize,
    
    // Declaration counts
    pub namespace_count: usize,
    pub class_count: usize,
    pub interface_count: usize,
    pub struct_count: usize,
    pub enum_count: usize,
    pub method_count: usize,
    pub property_count: usize,
    pub field_count: usize,
    
    // Statement counts
    pub statement_count: usize,
    pub expression_count: usize,
    
    // Complexity (aggregated)
    pub total_complexity: usize,
    pub max_complexity: usize,
    pub max_nesting_depth: usize,
}
<span class="boring">}</span></code></pre></pre>
<!-- Collection via trait impl removed; metrics are produced by MetricsPass during the pipeline. -->
<h3 id="2-complexity-metrics"><a class="header" href="#2-complexity-metrics">2. Complexity Metrics</a></h3>
<h4 id="cyclomatic-complexity"><a class="header" href="#cyclomatic-complexity">Cyclomatic Complexity</a></h4>
<p><strong>Definition:</strong> Number of linearly independent paths through code</p>
<p><strong>Formula:</strong> <code>CC = E - N + 2P</code></p>
<ul>
<li>E = edges in control flow graph</li>
<li>N = nodes in control flow graph</li>
<li>P = connected components (usually 1)</li>
</ul>
<p><strong>Simplified:</strong> <code>CC = 1 + number of decision points</code></p>
<p><strong>Decision Points:</strong></p>
<ul>
<li><code>if</code>, <code>else if</code></li>
<li><code>case</code> in <code>switch</code></li>
<li><code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code></li>
<li><code>&amp;&amp;</code>, <code>||</code> in conditions</li>
<li><code>catch</code> clauses</li>
<li><code>?:</code> ternary operator</li>
<li><code>??</code> null-coalescing operator</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {  // CC = 1 (base)
    if (order == null) {                 // +1 = 2
        throw new ArgumentNullException();
    }
    
    if (order.IsValid) {                 // +1 = 3
        if (order.Amount &gt; 1000) {       // +1 = 4
            ApplyDiscount(order);
        }
        SaveOrder(order);
    } else {                             // else doesn't add
        LogError(order);
    }
}
// Total CC = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cyclomatic_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 1;  // Base complexity
    
    if let Some(body) = &amp;method.body {
        complexity += count_decision_points(body);
    }
    
    complexity
}

fn count_decision_points(stmt: &amp;Statement) -&gt; usize {
    let mut count = 0;
    
    walk_statements(stmt, &amp;mut |s| {
        match s {
            Statement::If(_) =&gt; count += 1,
            Statement::For(_) =&gt; count += 1,
            Statement::ForEach(_) =&gt; count += 1,
            Statement::While(_) =&gt; count += 1,
            Statement::DoWhile(_) =&gt; count += 1,
            Statement::Switch(sw) =&gt; {
                // Each case is a decision point
                count += sw.sections.len();
            }
            Statement::Try(try_stmt) =&gt; {
                // Each catch is a decision point
                count += try_stmt.catch_clauses.len();
            }
            _ =&gt; {}
        }
    });
    
    // Also count logical operators in expressions
    // count += count_logical_operators(stmt);
    
    count
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-10:</strong> Simple, low risk</li>
<li><strong>11-20:</strong> Moderate complexity, moderate risk</li>
<li><strong>21-50:</strong> Complex, high risk</li>
<li><strong>50+:</strong> Very complex, very high risk - refactor recommended</li>
</ul>
<h4 id="cognitive-complexity"><a class="header" href="#cognitive-complexity">Cognitive Complexity</a></h4>
<p><strong>Definition:</strong> Measure of how difficult code is to understand</p>
<p><strong>Increments:</strong></p>
<ul>
<li><strong>+1</strong> for each: <code>if</code>, <code>else if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>, <code>catch</code>, <code>?:</code>, <code>??</code></li>
<li><strong>+1</strong> for each level of nesting (nested control structures)</li>
<li><strong>+1</strong> for each <code>break</code> or <code>continue</code> that jumps out of nested structure</li>
<li><strong>+1</strong> for each recursive call</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Process(List&lt;int&gt; items) {
    if (items != null) {                 // +1 (if)
        foreach (var item in items) {    // +1 (loop) +1 (nesting) = +2
            if (item &gt; 0) {              // +1 (if) +2 (nesting) = +3
                Process(item);           // +1 (recursion) +3 (nesting) = +4
            }
        }
    }
}
// Total Cognitive Complexity = 1 + 2 + 3 + 4 = 10
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cognitive_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 0;
    
    if let Some(body) = &amp;method.body {
        complexity = calculate_cognitive_complexity(body, 0);
    }
    
    complexity
}

fn calculate_cognitive_complexity(stmt: &amp;Statement, nesting_level: usize) -&gt; usize {
    let mut complexity = 0;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            complexity += 1 + nesting_level;  // if + nesting penalty
            complexity += calculate_cognitive_complexity(&amp;if_stmt.consequence, nesting_level + 1);
            if let Some(alt) = &amp;if_stmt.alternative {
                complexity += calculate_cognitive_complexity(alt, nesting_level + 1);
            }
        }
        Statement::For(for_stmt) =&gt; {
            complexity += 1 + nesting_level;
            if let Some(body) = &amp;for_stmt.body {
                complexity += calculate_cognitive_complexity(body, nesting_level + 1);
            }
        }
        // ... other statement types
        _ =&gt; {}
    }
    
    complexity
}
<span class="boring">}</span></code></pre></pre>
<h4 id="nesting-depth"><a class="header" href="#nesting-depth">Nesting Depth</a></h4>
<p><strong>Definition:</strong> Maximum depth of nested control structures</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Example() {
    if (condition1) {              // Depth 1
        while (condition2) {       // Depth 2
            if (condition3) {      // Depth 3
                for (int i = 0; i &lt; 10; i++) {  // Depth 4
                    // Code here
                }
            }
        }
    }
}
// Max Nesting Depth = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn max_nesting_depth(method: &amp;MethodDeclaration) -&gt; usize {
    method.body.as_ref()
        .map(|body| calculate_max_nesting(body, 0))
        .unwrap_or(0)
}

fn calculate_max_nesting(stmt: &amp;Statement, current_depth: usize) -&gt; usize {
    let mut max_depth = current_depth;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            let then_depth = calculate_max_nesting(&amp;if_stmt.consequence, current_depth + 1);
            max_depth = max_depth.max(then_depth);
            
            if let Some(alt) = &amp;if_stmt.alternative {
                let else_depth = calculate_max_nesting(alt, current_depth + 1);
                max_depth = max_depth.max(else_depth);
            }
        }
        Statement::Block(stmts) =&gt; {
            for s in stmts {
                let depth = calculate_max_nesting(s, current_depth);
                max_depth = max_depth.max(depth);
            }
        }
        // ... other nesting statements
        _ =&gt; {}
    }
    
    max_depth
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-3:</strong> Acceptable</li>
<li><strong>4-5:</strong> Consider refactoring</li>
<li><strong>6+:</strong> Refactor recommended</li>
</ul>
<h3 id="planned-maintainability-metrics"><a class="header" href="#planned-maintainability-metrics">Planned: Maintainability Metrics</a></h3>
<h4 id="maintainability-index"><a class="header" href="#maintainability-index">Maintainability Index</a></h4>
<p><strong>Definition:</strong> Composite metric indicating code maintainability</p>
<p><strong>Formula (Microsoft version):</strong></p>
<pre><code>MI = MAX(0, (171 - 5.2 * ln(HV) - 0.23 * CC - 16.2 * ln(LOC)) * 100 / 171)
</code></pre>
<p>Where:</p>
<ul>
<li><strong>HV</strong> = Halstead Volume</li>
<li><strong>CC</strong> = Cyclomatic Complexity</li>
<li><strong>LOC</strong> = Lines of Code</li>
</ul>
<p><strong>Scale:</strong></p>
<ul>
<li><strong>85-100:</strong> Good maintainability (green)</li>
<li><strong>65-84:</strong> Moderate maintainability (yellow)</li>
<li><strong>0-64:</strong> Difficult to maintain (red)</li>
</ul>
<p>Note: Maintainability Index is not implemented in the current codebase. This section outlines potential future work.</p>
<pre><pre class="playground"><code class="language-rust">pub fn maintainability_index(
    halstead_volume: f64,
    cyclomatic_complexity: usize,
    lines_of_code: usize
) -&gt; f64 {
    let hv_term = 5.2 * halstead_volume.ln();
    let cc_term = 0.23 * (cyclomatic_complexity as f64);
    let loc_term = 16.2 * (lines_of_code as f64).ln();
    
    let mi = 171.0 - hv_term - cc_term - loc_term;
    let normalized = (mi * 100.0 / 171.0).max(0.0);
    
    normalized
}</code></pre></pre>
<h4 id="planned-halstead-metrics"><a class="header" href="#planned-halstead-metrics">Planned: Halstead Metrics</a></h4>
<p><strong>Operators and Operands:</strong></p>
<ul>
<li><strong>n1</strong> = number of distinct operators</li>
<li><strong>n2</strong> = number of distinct operands</li>
<li><strong>N1</strong> = total number of operators</li>
<li><strong>N2</strong> = total number of operands</li>
</ul>
<p><strong>Derived Metrics:</strong></p>
<ul>
<li><strong>Program Vocabulary:</strong> <code>n = n1 + n2</code></li>
<li><strong>Program Length:</strong> <code>N = N1 + N2</code></li>
<li><strong>Calculated Length:</strong> <code>N' = n1 * log2(n1) + n2 * log2(n2)</code></li>
<li><strong>Volume:</strong> <code>V = N * log2(n)</code></li>
<li><strong>Difficulty:</strong> <code>D = (n1 / 2) * (N2 / n2)</code></li>
<li><strong>Effort:</strong> <code>E = D * V</code></li>
<li><strong>Time to Program:</strong> <code>T = E / 18</code> seconds</li>
<li><strong>Bugs Delivered:</strong> <code>B = V / 3000</code></li>
</ul>
<p>Note: Halstead metrics are not implemented in the current codebase.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HalsteadMetrics {
    pub distinct_operators: usize,    // n1
    pub distinct_operands: usize,     // n2
    pub total_operators: usize,       // N1
    pub total_operands: usize,        // N2
    pub vocabulary: usize,            // n
    pub length: usize,                // N
    pub volume: f64,                  // V
    pub difficulty: f64,              // D
    pub effort: f64,                  // E
    pub time_to_program: f64,         // T
    pub bugs_delivered: f64,          // B
}

impl HalsteadMetrics {
    pub fn calculate(operators: &amp;HashSet&lt;String&gt;, operands: &amp;HashSet&lt;String&gt;,
                     op_count: usize, operand_count: usize) -&gt; Self {
        let n1 = operators.len();
        let n2 = operands.len();
        let n = n1 + n2;
        let N = op_count + operand_count;
        
        let volume = (N as f64) * (n as f64).log2();
        let difficulty = (n1 as f64 / 2.0) * (operand_count as f64 / n2 as f64);
        let effort = difficulty * volume;
        let time = effort / 18.0;
        let bugs = volume / 3000.0;
        
        HalsteadMetrics {
            distinct_operators: n1,
            distinct_operands: n2,
            total_operators: op_count,
            total_operands: operand_count,
            vocabulary: n,
            length: N,
            volume,
            difficulty,
            effort,
            time_to_program: time,
            bugs_delivered: bugs,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="metrics-collection-in-the-pipeline"><a class="header" href="#metrics-collection-in-the-pipeline">Metrics Collection in the Pipeline</a></h2>
<p><code>MetricsPass</code> is registered in the analyzer registry and runs during <code>Phase::LocalRules</code>. It enumerates classes/structs/methods via <code>Query</code> and uses helpers from <code>bsharp_analysis::metrics::shared</code> to compute statement counts, decision points (cyclomatic complexity), and nesting.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::context::AnalysisContext;
use bsharp_analysis::framework::pipeline::AnalyzerPipeline;
use bsharp_analysis::framework::session::AnalysisSession;
use bsharp_analysis::metrics::AstAnalysis;
use bsharp_parser::facade::Parser;

let source = r#"public class C { public void M() { if (true) { } } }"#;
let (cu, spans) = Parser::new().parse_with_spans(source)?;
let mut session = AnalysisSession::new(AnalysisContext::new("file.cs", source), spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
let ast = session.artifacts.get::&lt;AstAnalysis&gt;().expect("AstAnalysis");
println!("classes={}, methods={}, ifs={}", ast.total_classes, ast.total_methods, ast.total_if_statements);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h2>
<h3 id="analyze-metrics"><a class="header" href="#analyze-metrics">Analyze Metrics</a></h3>
<pre><code class="language-bash"># Analyze single file
bsharp analyze MyFile.cs

# Analyze project
bsharp analyze MyProject.csproj --out metrics.json

# Analyze solution
bsharp analyze MySolution.sln --out metrics.json --format pretty-json
</code></pre>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code class="language-json">{
  "schema_version": 1,
  "metrics": {
    "total_lines": 1250,
    "code_lines": 980,
    "comment_lines": 150,
    "blank_lines": 120,
    "class_count": 15,
    "method_count": 87,
    "total_complexity": 245,
    "max_complexity": 18,
    "max_nesting_depth": 5
  }
}
</code></pre>
<hr />
<h2 id="thresholds-and-warnings"><a class="header" href="#thresholds-and-warnings">Thresholds and Warnings</a></h2>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<pre><code class="language-toml">[analysis.metrics]
max_cyclomatic_complexity = 10
max_cognitive_complexity = 15
max_nesting_depth = 4
max_method_length = 50
min_maintainability_index = 65
</code></pre>
<h3 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h3>
<p><strong>High Complexity Warning:</strong></p>
<pre><code>warning[MET001]: Method has high cyclomatic complexity
  --&gt; src/OrderProcessor.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ complexity = 18 (threshold: 10)
   |
   = help: Consider breaking this method into smaller methods
</code></pre>
<p><strong>Deep Nesting Warning:</strong></p>
<pre><code>warning[MET002]: Deep nesting detected
  --&gt; src/Validator.cs:15:9
   |
15 |         if (condition1) {
   |         ^^ nesting depth = 5 (threshold: 4)
   |
   = help: Consider extracting nested logic into separate methods
</code></pre>
<hr />
<h2 id="programmatic-usage"><a class="header" href="#programmatic-usage">Programmatic Usage</a></h2>
<h3 id="analyzing-a-method"><a class="header" href="#analyzing-a-method">Analyzing a Method</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::metrics::{cyclomatic_complexity, cognitive_complexity, max_nesting_depth};

let method = parse_method("public void MyMethod() { ... }");

let cc = cyclomatic_complexity(&amp;method);
let cog = cognitive_complexity(&amp;method);
let nesting = max_nesting_depth(&amp;method);

println!("Cyclomatic Complexity: {}", cc);
println!("Cognitive Complexity: {}", cog);
println!("Max Nesting Depth: {}", nesting);
<span class="boring">}</span></code></pre></pre>
<h3 id="analyzing-a-file-via-the-pipeline"><a class="header" href="#analyzing-a-file-via-the-pipeline">Analyzing a file via the pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (cu, spans) = Parser::new().parse_with_spans(source_code)?;
let mut session = AnalysisSession::new(AnalysisContext::new("file.cs", source_code), spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
let metrics = session.artifacts.get::&lt;AstAnalysis&gt;().expect("AstAnalysis");
println!("Classes: {}", metrics.total_classes);
println!("Methods: {}", metrics.total_methods);
println!("Cyclomatic Complexity: {}", metrics.cyclomatic_complexity);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="./pipeline.html">Analysis Pipeline</a> - How metrics fit in the pipeline</li>
<li><a href="./control-flow.html">Control Flow Analysis</a> - Related complexity analysis</li>
<li><a href="./quality.html">Code Quality</a> - Quality assessment using metrics</li>
<li><a href="../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_analysis/src/metrics/</code></li>
<li><strong>Pass:</strong> <code>src/bsharp_analysis/src/passes/metrics.rs</code></li>
<li><strong>Tests:</strong> <code>src/bsharp_tests/src/analysis/metrics/</code> (planned)</li>
<li><strong>Standards:</strong> ISO/IEC 25023 (Software Quality Metrics)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../analysis/dependencies.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../analysis/types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../analysis/dependencies.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../analysis/types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
