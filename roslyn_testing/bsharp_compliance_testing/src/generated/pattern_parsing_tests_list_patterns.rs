// Auto-generated from Roslyn: PatternParsingTests_ListPatterns
use crate::custom_asserts::after_parse;
use crate::custom_asserts::after_parse::CaseData;
use crate::custom_asserts::roslyn_asserts::ExpectedDiagnostics;
use bsharp_parser::bsharp::parse_csharp_source_strict;
use bsharp_parser::syntax::span::Span;
/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_00 (case 1)
#[test]
fn list_pattern_00() {
    let src = r#"c is [[]]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [[]]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_00",
                    1,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_00",
                    1,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_00",
            1,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_00 (case 2)
#[test]
fn list_pattern_00_case_2() {
    let src = r#"c is [[]]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [[]]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_00",
                    2,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_00",
                    2,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_00",
            2,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_01 (case 3)
#[test]
fn list_pattern_01() {
    let src = r#"c is [[],] v"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [[],] v; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_01",
                    3,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_01",
                    3,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_01",
            3,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_01 (case 4)
#[test]
fn list_pattern_01_case_2() {
    let src = r#"c is [[],] v"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [[],] v; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_01",
                    4,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_01",
                    4,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_01",
            4,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_02 (case 5)
#[test]
fn list_pattern_02() {
    let src = r#"c is [ 1, prop: 0 ]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 2,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [ 1, prop: 0 ]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_02",
                    5,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_02",
                    5,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_02",
            5,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_03 (case 6)
#[test]
fn list_pattern_03() {
    let src = r#"c is [ , ]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [ , ]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_03",
                    6,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_03",
                    6,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_03",
            6,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_04 (case 7)
#[test]
fn list_pattern_04() {
    let src = r#"c is ()[]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is ()[]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_04",
                    7,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_04",
                    7,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_04",
            7,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_05 (case 8)
#[test]
fn list_pattern_05() {
    let src = r#"c is {}[]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is {}[]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_05",
                    8,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_05",
                    8,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_05",
            8,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_06 (case 9)
#[test]
fn list_pattern_06() {
    let src = r#"c is [List<int>]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [List<int>]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_06",
                    9,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_06",
                    9,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_06",
            9,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_07 (case 10)
#[test]
fn list_pattern_07() {
    let src = r#"c is [string[]]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [string[]]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_07",
                    10,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_07",
                    10,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_07",
            10,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_08 (case 11)
#[test]
fn list_pattern_08() {
    let src = r#"c is [var(x,y)]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [var(x,y)]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_08",
                    11,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_08",
                    11,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_08",
            11,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.ListPattern_09 (case 12)
#[test]
fn list_pattern_09() {
    let src = r#"c is [>0]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [>0]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_09",
                    12,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "ListPattern_09",
                    12,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "ListPattern_09",
            12,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.NoRegressionOnArrayTypePattern_01 (case 13)
#[test]
fn no_regression_on_array_type_pattern_01() {
    let src = r#"c is string[]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is string[]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "NoRegressionOnArrayTypePattern_01",
                    13,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "NoRegressionOnArrayTypePattern_01",
                    13,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "NoRegressionOnArrayTypePattern_01",
            13,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.NoRegressionOnArrayTypePattern_02 (case 14)
#[test]
fn no_regression_on_array_type_pattern_02() {
    let src = r#"c is a[0]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is a[0]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "NoRegressionOnArrayTypePattern_02",
                    14,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "NoRegressionOnArrayTypePattern_02",
                    14,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "NoRegressionOnArrayTypePattern_02",
            14,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_01 (case 15)
#[test]
fn slice_pattern_01() {
    let src = r#"c is [..]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [..]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_01",
                    15,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_01",
                    15,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_01",
            15,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_01 (case 16)
#[test]
fn slice_pattern_01_case_2() {
    let src = r#"c is [..]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [..]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_01",
                    16,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_01",
                    16,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_01",
            16,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_02 (case 17)
#[test]
fn slice_pattern_02() {
    let src = r#"c is [.. var x]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. var x]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_02",
                    17,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_02",
                    17,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_02",
            17,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_03 (case 18)
#[test]
fn slice_pattern_03() {
    let src = r#"c is .."#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is ..; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_03",
                    18,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_03",
                    18,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_03",
            18,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_04 (case 19)
#[test]
fn slice_pattern_04() {
    let src = r#"c is ...."#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is ....; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_04",
                    19,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_04",
                    19,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_04",
            19,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_05 (case 20)
#[test]
fn slice_pattern_05() {
    let src = r#"c is [..[]]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [..[]]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_05",
                    20,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_05",
                    20,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_05",
            20,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_06 (case 21)
#[test]
fn slice_pattern_06() {
    let src = r#"c is [.. not p]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. not p]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_06",
                    21,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_06",
                    21,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_06",
            21,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_07 (case 22)
#[test]
fn slice_pattern_07() {
    let src = r#"c is [.. p or q]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. p or q]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_07",
                    22,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_07",
                    22,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_07",
            22,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_08 (case 23)
#[test]
fn slice_pattern_08() {
    let src = r#"c is [.. p or .. q]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. p or .. q]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_08",
                    23,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_08",
                    23,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_08",
            23,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_09 (case 24)
#[test]
fn slice_pattern_09() {
    let src = r#"c is .. var x"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is .. var x; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_09",
                    24,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_09",
                    24,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_09",
            24,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_10 (case 25)
#[test]
fn slice_pattern_10() {
    let src = r#"c is .. Type"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is .. Type; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_10",
                    25,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_10",
                    25,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_10",
            25,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_11 (case 26)
#[test]
fn slice_pattern_11() {
    let src = r#"c is [var x ..]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [var x ..]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_11",
                    26,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_11",
                    26,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_11",
            26,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_12 (case 27)
#[test]
fn slice_pattern_12() {
    let src = r#"c is var x .."#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is var x ..; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_12",
                    27,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_12",
                    27,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_12",
            27,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_13 (case 28)
#[test]
fn slice_pattern_13() {
    let src = r#"c is [[]..]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [[]..]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_13",
                    28,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_13",
                    28,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_13",
            28,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_14 (case 29)
#[test]
fn slice_pattern_14() {
    let src = r#"c is not p .."#;
    let expected = Some(ExpectedDiagnostics {
        count: 2,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is not p ..; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_14",
                    29,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_14",
                    29,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_14",
            29,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_15 (case 30)
#[test]
fn slice_pattern_15() {
    let src = r#"c is not .."#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is not ..; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_15",
                    30,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_15",
                    30,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_15",
            30,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_16 (case 31)
#[test]
fn slice_pattern_16() {
    let src = r#"c is [..] .."#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [..] ..; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_16",
                    31,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_16",
                    31,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_16",
            31,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_17 (case 32)
#[test]
fn slice_pattern_17() {
    let src = r#"c is a .. or b .."#;
    let expected = Some(ExpectedDiagnostics {
        count: 2,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is a .. or b ..; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_17",
                    32,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_17",
                    32,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_17",
            32,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_18 (case 33)
#[test]
fn slice_pattern_18() {
    let src = r#"c is (var x) .. > 0"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is (var x) .. > 0; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_18",
                    33,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_18",
                    33,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_18",
            33,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_19 (case 34)
#[test]
fn slice_pattern_19() {
    let src = r#"c is [..>5]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [..>5]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_19",
                    34,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_19",
                    34,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_19",
            34,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_20 (case 35)
#[test]
fn slice_pattern_20() {
    let src = r#"c is [.. string?]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. string?]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_20",
                    35,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_20",
                    35,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_20",
            35,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_21 (case 36)
#[test]
fn slice_pattern_21() {
    let src = r#"c is [.. string? slice]"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. string? slice]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_21",
                    36,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_21",
                    36,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_21",
            36,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_22 (case 37)
#[test]
fn slice_pattern_22() {
    let src = r#"c is [.. string? slice, ')']"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. string? slice, ')']; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_22",
                    37,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_22",
                    37,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_22",
            37,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_23 (case 38)
#[test]
fn slice_pattern_23() {
    let src = r#"c is [.. string? slice ')']"#;
    let expected: Option<ExpectedDiagnostics> = None;
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. string? slice ')']; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_23",
                    38,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_23",
                    38,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_23",
            38,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_24 (case 39)
#[test]
fn slice_pattern_24() {
    let src = r#"c is [.. string[]? slice "")""]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. string[]? slice "")""]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_24",
                    39,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_24",
                    39,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_24",
            39,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_25 (case 40)
#[test]
fn slice_pattern_25() {
    let src = r#"c is [.. int[]? slice 5]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. int[]? slice 5]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_25",
                    40,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_25",
                    40,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_25",
            40,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_26 (case 41)
#[test]
fn slice_pattern_26() {
    let src = r#"c is [.. int[]? slice int i]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. int[]? slice int i]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_26",
                    41,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_26",
                    41,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_26",
            41,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_27 (case 42)
#[test]
fn slice_pattern_27() {
    let src = r#"c is [.. string[]? slice string s]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. string[]? slice string s]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_27",
                    42,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_27",
                    42,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_27",
            42,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}

/// Roslyn: PatternParsingTests_ListPatterns.SlicePattern_28 (case 43)
#[test]
fn slice_pattern_28() {
    let src = r#"c is [.. char[]? slice char ch]"#;
    let expected = Some(ExpectedDiagnostics {
        count: 1,
        items: vec![],
    });
    let span = Span::new(src);
    let src2 = r#"class C { void M() { c is [.. char[]? slice char ch]; } }"#;
    let span2 = Span::new(src2);
    let r = parse_csharp_source_strict(span2);
    if let Some(expected) = expected {
        match r {
            Ok((_rest, unit)) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_28",
                    43,
                    Some(expected.clone()),
                    CaseData::File {
                        unit: &unit,
                        src: src2,
                        original: Some(src),
                    },
                );
            }
            Err(_) => {
                after_parse::after_parse_with_expected(
                    "pattern_parsing_tests_list_patterns",
                    "PatternParsingTests_ListPatterns",
                    "SlicePattern_28",
                    43,
                    Some(expected.clone()),
                    CaseData::Empty,
                );
            }
        }
    } else {
        assert!(r.is_ok(), "parse failed: {:?}", r.err());
        let (_rest, unit) = r.unwrap();
        after_parse::after_parse_with_expected(
            "pattern_parsing_tests_list_patterns",
            "PatternParsingTests_ListPatterns",
            "SlicePattern_28",
            43,
            None,
            CaseData::File {
                unit: &unit,
                src: src2,
                original: Some(src),
            },
        );
    }
}
