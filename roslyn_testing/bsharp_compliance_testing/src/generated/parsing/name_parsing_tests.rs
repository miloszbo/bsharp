// Auto-generated STRUCTURE tests from Roslyn: NameParsingTests
use bsharp_parser::syntax::span::Span;
use bsharp_parser::bsharp::parse_csharp_source_strict;
use crate::custom_asserts::structure_assert;
#[test]
fn parse_generic_name_invocation_with_omitted_type_arguments() {
    let src = r#"x\u00ady"#;
    let span = Span::new(src);
    let r = parse_csharp_source_strict(span);
    if let Ok((_rest, unit)) = r {
        let expected = structure_assert::ExpectedTree { root: structure_assert::ExpectedNode { kind: "CompilationUnit".to_string(), token_value: None, children: vec![    structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("C".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "MethodDeclaration".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "PredefinedType".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T1".to_string()), children: vec![] }] },                 structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T2".to_string()), children: vec![] }] }] },             structure_assert::ExpectedNode { kind: "ParameterList".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "Block".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "ExpressionStatement".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "InvocationExpression".to_string(), token_value: None, children: vec![                        structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                            structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] },                                 structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] }] }] },                         structure_assert::ExpectedNode { kind: "ArgumentList".to_string(), token_value: None, children: vec![] }] }] }] }] }] }] } };
        structure_assert::assert_tree(&expected, &unit);
    }
}

#[test]
fn parse_generic_name_invocation_with_omitted_type_arguments_csharp_1() {
    let src = r#"x\u00ady"#;
    let span = Span::new(src);
    let r = parse_csharp_source_strict(span);
    if let Ok((_rest, unit)) = r {
        let expected = structure_assert::ExpectedTree { root: structure_assert::ExpectedNode { kind: "CompilationUnit".to_string(), token_value: None, children: vec![    structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("C".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "MethodDeclaration".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "PredefinedType".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T1".to_string()), children: vec![] }] },                 structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T2".to_string()), children: vec![] }] }] },             structure_assert::ExpectedNode { kind: "ParameterList".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "Block".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "ExpressionStatement".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "InvocationExpression".to_string(), token_value: None, children: vec![                        structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                            structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] },                                 structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] }] }] },                         structure_assert::ExpectedNode { kind: "ArgumentList".to_string(), token_value: None, children: vec![] }] }] }] }] }] }] } };
        structure_assert::assert_tree(&expected, &unit);
    }
}

#[test]
fn parse_generic_name_invocation_with_omitted_type_arguments_2() {
    let src = r#"x\u00ady"#;
    let span = Span::new(src);
    let r = parse_csharp_source_strict(span);
    if let Ok((_rest, unit)) = r {
        let expected = structure_assert::ExpectedTree { root: structure_assert::ExpectedNode { kind: "CompilationUnit".to_string(), token_value: None, children: vec![    structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("X".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T".to_string()), children: vec![] }] }] }] },     structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("C".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "MethodDeclaration".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "PredefinedType".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T1".to_string()), children: vec![] }] },                 structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T2".to_string()), children: vec![] }] }] },             structure_assert::ExpectedNode { kind: "ParameterList".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "Block".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "ExpressionStatement".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "InvocationExpression".to_string(), token_value: None, children: vec![                        structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                            structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                structure_assert::ExpectedNode { kind: "PredefinedType".to_string(), token_value: None, children: vec![] },                                 structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                                    structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                        structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] }] }] }] }] },                         structure_assert::ExpectedNode { kind: "ArgumentList".to_string(), token_value: None, children: vec![] }] }] }] }] }] }] } };
        structure_assert::assert_tree(&expected, &unit);
    }
}

#[test]
fn parse_generic_name_invocation_with_omitted_type_arguments_3() {
    let src = r#"x\u00ady"#;
    let span = Span::new(src);
    let r = parse_csharp_source_strict(span);
    if let Ok((_rest, unit)) = r {
        let expected = structure_assert::ExpectedTree { root: structure_assert::ExpectedNode { kind: "CompilationUnit".to_string(), token_value: None, children: vec![    structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("X".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T".to_string()), children: vec![] }] }] }] },     structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("C".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "MethodDeclaration".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "PredefinedType".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T1".to_string()), children: vec![] }] },                 structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T2".to_string()), children: vec![] }] }] },             structure_assert::ExpectedNode { kind: "ParameterList".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "Block".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "ExpressionStatement".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "InvocationExpression".to_string(), token_value: None, children: vec![                        structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                            structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                                    structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                        structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] }] }] },                                 structure_assert::ExpectedNode { kind: "PredefinedType".to_string(), token_value: None, children: vec![] }] }] },                         structure_assert::ExpectedNode { kind: "ArgumentList".to_string(), token_value: None, children: vec![] }] }] }] }] }] }] } };
        structure_assert::assert_tree(&expected, &unit);
    }
}

#[test]
fn parse_generic_name_invocation_with_omitted_type_arguments_4() {
    let src = r#"x\u00ady"#;
    let span = Span::new(src);
    let r = parse_csharp_source_strict(span);
    if let Ok((_rest, unit)) = r {
        let expected = structure_assert::ExpectedTree { root: structure_assert::ExpectedNode { kind: "CompilationUnit".to_string(), token_value: None, children: vec![    structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("X".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T".to_string()), children: vec![] }] }] }] },     structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("Y".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("A".to_string()), children: vec![] }] },             structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("B".to_string()), children: vec![] }] }] }] },     structure_assert::ExpectedNode { kind: "ClassDeclaration".to_string(), token_value: None, children: vec![        structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("C".to_string()), children: vec![] },         structure_assert::ExpectedNode { kind: "MethodDeclaration".to_string(), token_value: None, children: vec![            structure_assert::ExpectedNode { kind: "PredefinedType".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "TypeParameterList".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T1".to_string()), children: vec![] }] },                 structure_assert::ExpectedNode { kind: "TypeParameter".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "IdentifierName".to_string(), token_value: Some("T2".to_string()), children: vec![] }] }] },             structure_assert::ExpectedNode { kind: "ParameterList".to_string(), token_value: None, children: vec![] },             structure_assert::ExpectedNode { kind: "Block".to_string(), token_value: None, children: vec![                structure_assert::ExpectedNode { kind: "ExpressionStatement".to_string(), token_value: None, children: vec![                    structure_assert::ExpectedNode { kind: "InvocationExpression".to_string(), token_value: None, children: vec![                        structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                            structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                                    structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                        structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] }] }] },                                 structure_assert::ExpectedNode { kind: "GenericName".to_string(), token_value: None, children: vec![                                    structure_assert::ExpectedNode { kind: "TypeArgumentList".to_string(), token_value: None, children: vec![                                        structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] },                                         structure_assert::ExpectedNode { kind: "OmittedTypeArgument".to_string(), token_value: None, children: vec![] }] }] }] }] },                         structure_assert::ExpectedNode { kind: "ArgumentList".to_string(), token_value: None, children: vec![] }] }] }] }] }] }] } };
        structure_assert::assert_tree(&expected, &unit);
    }
}

